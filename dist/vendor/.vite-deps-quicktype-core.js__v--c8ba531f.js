import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "/vendor/.vite-deps-chunk-GFT2G5UO.js__v--c8ba531f.js";

// node_modules/collection-utils/dist/index.js
var require_dist = __commonJS({
  "node_modules/collection-utils/dist/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashCodeInit = 17;
    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash = hash & hash;
      }
      return hash;
    }
    exports.hashString = hashString;
    function addHashCode(acc, h) {
      return acc * 31 + (h | 0) | 0;
    }
    exports.addHashCode = addHashCode;
    function withDefault(x, theDefault) {
      if (x !== void 0) {
        return x;
      }
      return theDefault;
    }
    exports.withDefault = withDefault;
    function definedMap(x, f) {
      if (x === void 0)
        return void 0;
      return f(x);
    }
    exports.definedMap = definedMap;
    function definedMapWithDefault(x, theDefault, f) {
      return withDefault(definedMap(x, f), theDefault);
    }
    exports.definedMapWithDefault = definedMapWithDefault;
    function hasOwnProperty(obj, name) {
      if (obj === void 0 || obj === null)
        return false;
      return Object.prototype.hasOwnProperty.call(obj, name);
    }
    exports.hasOwnProperty = hasOwnProperty;
    function iterableFind(it, p) {
      for (const v of it) {
        if (p(v)) {
          return v;
        }
      }
      return void 0;
    }
    exports.iterableFind = iterableFind;
    function iterableEvery(it, p) {
      for (const v of it) {
        if (!p(v)) {
          return false;
        }
      }
      return true;
    }
    exports.iterableEvery = iterableEvery;
    function iterableSome(it, p) {
      for (const v of it) {
        if (p(v)) {
          return true;
        }
      }
      return false;
    }
    exports.iterableSome = iterableSome;
    function iterableFirst(it) {
      for (const v of it) {
        return v;
      }
      return void 0;
    }
    exports.iterableFirst = iterableFirst;
    function iterableMax(it) {
      let max = void 0;
      for (const v of it) {
        if (max === void 0 || v > max) {
          max = v;
        }
      }
      return max;
    }
    exports.iterableMax = iterableMax;
    function iterableMinBy(it, key) {
      let min = void 0;
      let minValue = void 0;
      for (const v of it) {
        const k = key(v);
        if (min === void 0 || k < min) {
          min = k;
          minValue = v;
        }
      }
      return minValue;
    }
    exports.iterableMinBy = iterableMinBy;
    function iterableReduce(it, unit, reducer) {
      let result = unit;
      for (const v of it) {
        result = reducer(result, v);
      }
      return result;
    }
    exports.iterableReduce = iterableReduce;
    function* iterableEnumerate(it) {
      let i = 0;
      for (const v of it) {
        yield [i, v];
        i += 1;
      }
    }
    exports.iterableEnumerate = iterableEnumerate;
    function* iterableSkip(it, n) {
      let i = 0;
      for (const v of it) {
        if (i >= n) {
          yield v;
        } else {
          i += 1;
        }
      }
    }
    exports.iterableSkip = iterableSkip;
    function arrayGetFromEnd(arr, i) {
      const l = arr.length;
      if (i > l)
        return void 0;
      return arr[l - i];
    }
    exports.arrayGetFromEnd = arrayGetFromEnd;
    function arrayLast(arr) {
      return arrayGetFromEnd(arr, 1);
    }
    exports.arrayLast = arrayLast;
    function arrayPop(arr) {
      const l = arr.length;
      if (l === 0) {
        throw new Error("Cannot pop empty array");
      }
      return arr.slice(0, l - 1);
    }
    exports.arrayPop = arrayPop;
    function arrayIntercalate(separator, items) {
      const acc = [];
      for (const x of items) {
        if (acc.length > 0)
          acc.push(separator);
        acc.push(x);
      }
      return acc;
    }
    exports.arrayIntercalate = arrayIntercalate;
    function arrayMapSync(set2, f) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = [];
        let i = 0;
        for (const v of set2) {
          result.push(yield f(v, i));
          i += 1;
        }
        return result;
      });
    }
    exports.arrayMapSync = arrayMapSync;
    function compareKeys(sa, sb) {
      if (sa < sb)
        return -1;
      if (sa > sb)
        return 1;
      return 0;
    }
    function arraySortByInto(arr, sortKey) {
      return arr.sort((a, b) => compareKeys(sortKey(a), sortKey(b)));
    }
    exports.arraySortByInto = arraySortByInto;
    function toReadonlyArray(it) {
      if (Array.isArray(it))
        return it;
      return Array.from(it);
    }
    exports.toReadonlyArray = toReadonlyArray;
    function mapMap(m, f) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        result.set(k, f(v, k));
      }
      return result;
    }
    exports.mapMap = mapMap;
    function mapFirst(m) {
      for (const v of m.values()) {
        return v;
      }
      return void 0;
    }
    exports.mapFirst = mapFirst;
    function mapContains(m, valueToFind) {
      for (const v of m.values()) {
        if (v === valueToFind) {
          return true;
        }
      }
      return false;
    }
    exports.mapContains = mapContains;
    function mapSome(m, p) {
      for (const [k, v] of m) {
        if (p(v, k)) {
          return true;
        }
      }
      return false;
    }
    exports.mapSome = mapSome;
    function mapMergeInto(dest, src) {
      for (const [k, v] of src) {
        dest.set(k, v);
      }
      return dest;
    }
    exports.mapMergeInto = mapMergeInto;
    function mapMerge(ma, mb) {
      const result = new Map(ma);
      mapMergeInto(result, mb);
      return result;
    }
    exports.mapMerge = mapMerge;
    function mapMergeWithInto(ma, merger, mb) {
      for (const [k, vb] of mb) {
        const va = ma.get(k);
        const v = va === void 0 ? vb : merger(va, vb, k);
        ma.set(k, v);
      }
      return ma;
    }
    exports.mapMergeWithInto = mapMergeWithInto;
    function mapMergeWith(ma, merger, mb) {
      const result = new Map(ma);
      mapMergeWithInto(result, merger, mb);
      return result;
    }
    exports.mapMergeWith = mapMergeWith;
    function mapFilter(m, p) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        if (p(v, k)) {
          result.set(k, v);
        }
      }
      return result;
    }
    exports.mapFilter = mapFilter;
    function mapFilterMap(m, f) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        const w = f(v, k);
        if (w !== void 0) {
          result.set(k, w);
        }
      }
      return result;
    }
    exports.mapFilterMap = mapFilterMap;
    function mapSortToArray(m, sortKey) {
      return arraySortByInto(Array.from(m), ([k, v]) => sortKey(v, k));
    }
    exports.mapSortToArray = mapSortToArray;
    function mapSortBy(m, sortKey) {
      return new Map(mapSortToArray(m, sortKey));
    }
    exports.mapSortBy = mapSortBy;
    function mapSortByKey(m) {
      return mapSortBy(m, (_, k) => k);
    }
    exports.mapSortByKey = mapSortByKey;
    function mapMapEntries(m, f) {
      const result = /* @__PURE__ */ new Map();
      for (const [k, v] of m) {
        const [l, w] = f(v, k);
        result.set(l, w);
      }
      return result;
    }
    exports.mapMapEntries = mapMapEntries;
    function mapUpdateInto(m, k, updater) {
      m.set(k, updater(m.get(k)));
      return m;
    }
    exports.mapUpdateInto = mapUpdateInto;
    function mapFromObject(obj) {
      const result = /* @__PURE__ */ new Map();
      for (const k of Object.getOwnPropertyNames(obj)) {
        result.set(k, obj[k]);
      }
      return result;
    }
    exports.mapFromObject = mapFromObject;
    function mapToObject(m) {
      const result = {};
      for (const [k, v] of m) {
        result[k] = v;
      }
      return result;
    }
    exports.mapToObject = mapToObject;
    function mapFromIterable(it, valueForKey) {
      const result = /* @__PURE__ */ new Map();
      for (const k of it) {
        result.set(k, valueForKey(k));
      }
      return result;
    }
    exports.mapFromIterable = mapFromIterable;
    function mapFind(it, p) {
      for (const [k, v] of it) {
        if (p(v, k)) {
          return v;
        }
      }
      return void 0;
    }
    exports.mapFind = mapFind;
    function mapTranspose(maps) {
      const result = /* @__PURE__ */ new Map();
      for (const m of maps) {
        for (const [k, v] of m) {
          let arr = result.get(k);
          if (arr === void 0) {
            arr = [];
            result.set(k, arr);
          }
          arr.push(v);
        }
      }
      return result;
    }
    exports.mapTranspose = mapTranspose;
    function mapMapSync(m, f) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = /* @__PURE__ */ new Map();
        for (const [k, v] of m) {
          result.set(k, yield f(v, k));
        }
        return result;
      });
    }
    exports.mapMapSync = mapMapSync;
    function setIsSuperset(set2, subset) {
      for (const elem of subset) {
        if (!set2.has(elem))
          return false;
      }
      return true;
    }
    exports.setIsSuperset = setIsSuperset;
    function setUnionManyInto(dest, srcs) {
      for (const src of srcs) {
        for (const v of src) {
          dest.add(v);
        }
      }
      return dest;
    }
    exports.setUnionManyInto = setUnionManyInto;
    function setUnionInto(dest, ...srcs) {
      return setUnionManyInto(dest, srcs);
    }
    exports.setUnionInto = setUnionInto;
    function setIntersect(s1, s2) {
      const result = /* @__PURE__ */ new Set();
      for (const v of s1) {
        if (s2.has(v)) {
          result.add(v);
        }
      }
      return result;
    }
    exports.setIntersect = setIntersect;
    function setSubtract(src, diff) {
      const result = new Set(src);
      for (const v of diff) {
        result.delete(v);
      }
      return result;
    }
    exports.setSubtract = setSubtract;
    function setUnion(...sets) {
      const result = /* @__PURE__ */ new Set();
      setUnionInto(result, ...sets);
      return result;
    }
    exports.setUnion = setUnion;
    function setMap(set2, f) {
      const result = /* @__PURE__ */ new Set();
      for (const v of set2) {
        result.add(f(v));
      }
      return result;
    }
    exports.setMap = setMap;
    function setFilter(set2, p) {
      const result = /* @__PURE__ */ new Set();
      for (const v of set2) {
        if (p(v)) {
          result.add(v);
        }
      }
      return result;
    }
    exports.setFilter = setFilter;
    function setFilterMap(set2, f) {
      const result = /* @__PURE__ */ new Set();
      for (const v of set2) {
        const u = f(v);
        if (u !== void 0) {
          result.add(u);
        }
      }
      return result;
    }
    exports.setFilterMap = setFilterMap;
    function setSortBy(it, sortKey) {
      return new Set(arraySortByInto(Array.from(it), sortKey));
    }
    exports.setSortBy = setSortBy;
    function setGroupBy(it, grouper) {
      const result = /* @__PURE__ */ new Map();
      for (const v of it) {
        const g = grouper(v);
        let group = result.get(g);
        if (group === void 0) {
          group = /* @__PURE__ */ new Set();
          result.set(g, group);
        }
        group.add(v);
      }
      return result;
    }
    exports.setGroupBy = setGroupBy;
    function toReadonlySet(it) {
      if (it instanceof Set)
        return it;
      return new Set(it);
    }
    exports.toReadonlySet = toReadonlySet;
    var EqualityMap = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      set(k, v) {
        let h = hashCodeOf(k) | 0;
        for (; ; ) {
          const kvp = this._map.get(h);
          if (kvp === void 0) {
            this._map.set(h, [k, v]);
            return;
          }
          if (areEqual(k, kvp[0])) {
            kvp[1] = v;
            return;
          }
          h = h + 1 | 0;
        }
      }
      get(k) {
        let h = hashCodeOf(k) | 0;
        for (; ; ) {
          const kvp = this._map.get(h);
          if (kvp === void 0) {
            return void 0;
          }
          if (areEqual(k, kvp[0])) {
            return kvp[1];
          }
          h = h + 1 | 0;
        }
      }
      has(k) {
        return this.get(k) !== void 0;
      }
      *values() {
        for (const [, [, v]] of this._map) {
          yield v;
        }
      }
    };
    exports.EqualityMap = EqualityMap;
    function areEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (a === void 0 || b === void 0 || a === null || b === null) {
        return false;
      }
      if (typeof a.equals === "function" && typeof b.equals === "function") {
        return a.equals(b);
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size)
          return false;
        for (const x of a) {
          if (!b.has(x))
            return false;
        }
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size)
          return false;
        for (const [k, v] of a) {
          const w = b.get(k);
          if (!areEqual(v, w))
            return false;
        }
        return true;
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        const n = a.length;
        if (n !== b.length)
          return false;
        for (let i = 0; i < n; i++) {
          if (!areEqual(a[i], b[i]))
            return false;
        }
        return true;
      }
      return false;
    }
    exports.areEqual = areEqual;
    function hashCodeOf(x) {
      if (typeof x === "number")
        return x | 0;
      if (typeof x === "string")
        return hashString(x);
      let h = exports.hashCodeInit;
      if (x === void 0)
        return h;
      if (x === true)
        return h + 1 | 0;
      if (x === false)
        return h + 2 | 0;
      if (x === null)
        return h + 3 | 0;
      if (typeof x.hashCode === "function") {
        return x.hashCode();
      }
      if (x instanceof Set) {
        for (const y of x) {
          h += hashCodeOf(y);
        }
        return h;
      }
      if (x instanceof Map) {
        let g = exports.hashCodeInit;
        for (const [k, v] of x) {
          g += hashCodeOf(k);
          h += hashCodeOf(v);
        }
        return addHashCode(g, h);
      }
      if (Array.isArray(x)) {
        for (const y of x) {
          h = addHashCode(h, hashCodeOf(y));
        }
        return h;
      }
      throw new Error(`Cannot hash ${x}`);
    }
    exports.hashCodeOf = hashCodeOf;
  }
});

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module) {
    (function(root, pluralize) {
      if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
        module.exports = pluralize();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize();
        });
      } else {
        root.pluralize = pluralize();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token) {
        if (word === token)
          return token;
        if (word === word.toLowerCase())
          return token.toLowerCase();
        if (word === word.toUpperCase())
          return token.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        return token.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index) {
          return args[index] || "";
        });
      }
      function replace(word, rule) {
        return word.replace(rule[0], function(match, index) {
          var result = interpolate(rule[1], arguments);
          if (match === "") {
            return restoreCase(word[index - 1], result);
          }
          return restoreCase(match, result);
        });
      }
      function sanitizeWord(token, word, rules) {
        if (!token.length || uncountables.hasOwnProperty(token)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word))
            return replace(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word, token);
          }
          if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word, replaceMap[token]);
          }
          return sanitizeWord(token, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token))
            return true;
          if (replaceMap.hasOwnProperty(token))
            return false;
          return sanitizeWord(token, token, rules) === token;
        };
      }
      function pluralize(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize.singular(word) : pluralize.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize.addPluralRule(word, "$0");
        pluralize.addSingularRule(word, "$0");
      };
      pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eÃ©]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize.addUncountableRule);
      return pluralize;
    });
  }
});

// node_modules/quicktype-core/dist/support/Chance.js
var require_Chance = __commonJS({
  "node_modules/quicktype-core/dist/support/Chance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chance = void 0;
    var MersenneTwister = class {
      constructor(seed) {
        if (seed === void 0) {
          seed = Math.floor(Math.random() * Math.pow(10, 13));
        }
        this.N = 624;
        this.M = 397;
        this.MATRIX_A = 2567483615;
        this.UPPER_MASK = 2147483648;
        this.LOWER_MASK = 2147483647;
        this.mt = new Array(this.N);
        this.mti = this.N + 1;
        this.init_genrand(seed);
      }
      /* initializes mt[N] with a seed */
      init_genrand(s) {
        this.mt[0] = s >>> 0;
        for (this.mti = 1; this.mti < this.N; this.mti++) {
          s = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
          this.mt[this.mti] = (((s & 4294901760) >>> 16) * 1812433253 << 16) + (s & 65535) * 1812433253 + this.mti;
          this.mt[this.mti] >>>= 0;
        }
      }
      /* generates a random number on [0,0xffffffff]-interval */
      genrand_int32() {
        let y;
        let mag01 = [0, this.MATRIX_A];
        if (this.mti >= this.N) {
          let kk;
          if (this.mti === this.N + 1) {
            this.init_genrand(5489);
          }
          for (kk = 0; kk < this.N - this.M; kk++) {
            y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
            this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ mag01[y & 1];
          }
          for (; kk < this.N - 1; kk++) {
            y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
            this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ mag01[y & 1];
          }
          y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
          this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ mag01[y & 1];
          this.mti = 0;
        }
        y = this.mt[this.mti++];
        y ^= y >>> 11;
        y ^= y << 7 & 2636928640;
        y ^= y << 15 & 4022730752;
        y ^= y >>> 18;
        return y >>> 0;
      }
      /* generates a random number on [0,1)-real-interval */
      random() {
        return this.genrand_int32() * (1 / 4294967296);
      }
    };
    var Chance = class {
      constructor(seed) {
        this.seed = seed;
        this.mt = new MersenneTwister(this.seed);
      }
      random() {
        return this.mt.random();
      }
      /**
       *  Return a random integer
       *
       *  NOTE the max and min are INCLUDED in the range. So:
       *  chance.integer({min: 1, max: 3});
       *  would return either 1, 2, or 3.
       *
       *  @param {Object} [options={}] can specify a min and/or max
       *  @returns {Number} a single random integer number
       *  @throws {RangeError} min cannot be greater than max
       */
      integer(options) {
        return Math.floor(this.random() * (options.max - options.min + 1) + options.min);
      }
      /**
       *  Return a random natural
       *
       *  NOTE the max and min are INCLUDED in the range. So:
       *  chance.natural({min: 1, max: 3});
       *  would return either 1, 2, or 3.
       *
       *  @param {Object} [options={}] can specify a min and/or maxm or a numerals count.
       *  @returns {Number} a single random integer number
       *  @throws {RangeError} min cannot be greater than max
       */
      natural(options) {
        return this.integer({ min: 0, max: options.max });
      }
      pick(arr) {
        if (arr.length === 0) {
          throw new RangeError("Chance: Cannot pick() from an empty array");
        }
        return arr[this.natural({ max: arr.length - 1 })];
      }
      animal() {
        const animalTypeArray = ["desert", "forest", "ocean", "zoo", "farm", "pet", "grassland"];
        return this.pick(animals[this.pick(animalTypeArray)]);
      }
      city() {
        return this.pick(cities);
      }
    };
    exports.Chance = Chance;
    var animals = {
      // list of ocean animals comes from https://owlcation.com/stem/list-of-ocean-animals
      ocean: [
        "Acantharea",
        "Anemone",
        "Angelfish King",
        "Ahi Tuna",
        "Albacore",
        "American Oyster",
        "Anchovy",
        "Armored Snail",
        "Arctic Char",
        "Atlantic Bluefin Tuna",
        "Atlantic Cod",
        "Atlantic Goliath Grouper",
        "Atlantic Trumpetfish",
        "Atlantic Wolffish",
        "Baleen Whale",
        "Banded Butterflyfish",
        "Banded Coral Shrimp",
        "Banded Sea Krait",
        "Barnacle",
        "Barndoor Skate",
        "Barracuda",
        "Basking Shark",
        "Bass",
        "Beluga Whale",
        "Bluebanded Goby",
        "Bluehead Wrasse",
        "Bluefish",
        "Bluestreak Cleaner-Wrasse",
        "Blue Marlin",
        "Blue Shark",
        "Blue Spiny Lobster",
        "Blue Tang",
        "Blue Whale",
        "Broadclub Cuttlefish",
        "Bull Shark",
        "Chambered Nautilus",
        "Chilean Basket Star",
        "Chilean Jack Mackerel",
        "Chinook Salmon",
        "Christmas Tree Worm",
        "Clam",
        "Clown Anemonefish",
        "Clown Triggerfish",
        "Cod",
        "Coelacanth",
        "Cockscomb Cup Coral",
        "Common Fangtooth",
        "Conch",
        "Cookiecutter Shark",
        "Copepod",
        "Coral",
        "Corydoras",
        "Cownose Ray",
        "Crab",
        "Crown-of-Thorns Starfish",
        "Cushion Star",
        "Cuttlefish",
        "California Sea Otters",
        "Dolphin",
        "Dolphinfish",
        "Dory",
        "Devil Fish",
        "Dugong",
        "Dumbo Octopus",
        "Dungeness Crab",
        "Eccentric Sand Dollar",
        "Edible Sea Cucumber",
        "Eel",
        "Elephant Seal",
        "Elkhorn Coral",
        "Emperor Shrimp",
        "Estuarine Crocodile",
        "Fathead Sculpin",
        "Fiddler Crab",
        "Fin Whale",
        "Flameback",
        "Flamingo Tongue Snail",
        "Flashlight Fish",
        "Flatback Turtle",
        "Flatfish",
        "Flying Fish",
        "Flounder",
        "Fluke",
        "French Angelfish",
        "Frilled Shark",
        "Fugu (also called Pufferfish)",
        "Gar",
        "Geoduck",
        "Giant Barrel Sponge",
        "Giant Caribbean Sea Anemone",
        "Giant Clam",
        "Giant Isopod",
        "Giant Kingfish",
        "Giant Oarfish",
        "Giant Pacific Octopus",
        "Giant Pyrosome",
        "Giant Sea Star",
        "Giant Squid",
        "Glowing Sucker Octopus",
        "Giant Tube Worm",
        "Goblin Shark",
        "Goosefish",
        "Great White Shark",
        "Greenland Shark",
        "Grey Atlantic Seal",
        "Grouper",
        "Grunion",
        "Guineafowl Puffer",
        "Haddock",
        "Hake",
        "Halibut",
        "Hammerhead Shark",
        "Hapuka",
        "Harbor Porpoise",
        "Harbor Seal",
        "Hatchetfish",
        "Hawaiian Monk Seal",
        "Hawksbill Turtle",
        "Hector's Dolphin",
        "Hermit Crab",
        "Herring",
        "Hoki",
        "Horn Shark",
        "Horseshoe Crab",
        "Humpback Anglerfish",
        "Humpback Whale",
        "Icefish",
        "Imperator Angelfish",
        "Irukandji Jellyfish",
        "Isopod",
        "Ivory Bush Coral",
        "Japanese Spider Crab",
        "Jellyfish",
        "John Dory",
        "Juan Fernandez Fur Seal",
        "Killer Whale",
        "Kiwa Hirsuta",
        "Krill",
        "Lagoon Triggerfish",
        "Lamprey",
        "Leafy Seadragon",
        "Leopard Seal",
        "Limpet",
        "Ling",
        "Lionfish",
        "Lions Mane Jellyfish",
        "Lobe Coral",
        "Lobster",
        "Loggerhead Turtle",
        "Longnose Sawshark",
        "Longsnout Seahorse",
        "Lophelia Coral",
        "Marrus Orthocanna",
        "Manatee",
        "Manta Ray",
        "Marlin",
        "Megamouth Shark",
        "Mexican Lookdown",
        "Mimic Octopus",
        "Moon Jelly",
        "Mollusk",
        "Monkfish",
        "Moray Eel",
        "Mullet",
        "Mussel",
        "Megaladon",
        "Napoleon Wrasse",
        "Nassau Grouper",
        "Narwhal",
        "Nautilus",
        "Needlefish",
        "Northern Seahorse",
        "North Atlantic Right Whale",
        "Northern Red Snapper",
        "Norway Lobster",
        "Nudibranch",
        "Nurse Shark",
        "Oarfish",
        "Ocean Sunfish",
        "Oceanic Whitetip Shark",
        "Octopus",
        "Olive Sea Snake",
        "Orange Roughy",
        "Ostracod",
        "Otter",
        "Oyster",
        "Pacific Angelshark",
        "Pacific Blackdragon",
        "Pacific Halibut",
        "Pacific Sardine",
        "Pacific Sea Nettle Jellyfish",
        "Pacific White Sided Dolphin",
        "Pantropical Spotted Dolphin",
        "Patagonian Toothfish",
        "Peacock Mantis Shrimp",
        "Pelagic Thresher Shark",
        "Penguin",
        "Peruvian Anchoveta",
        "Pilchard",
        "Pink Salmon",
        "Pinniped",
        "Plankton",
        "Porpoise",
        "Polar Bear",
        "Portuguese Man o' War",
        "Pycnogonid Sea Spider",
        "Quahog",
        "Queen Angelfish",
        "Queen Conch",
        "Queen Parrotfish",
        "Queensland Grouper",
        "Ragfish",
        "Ratfish",
        "Rattail Fish",
        "Ray",
        "Red Drum",
        "Red King Crab",
        "Ringed Seal",
        "Risso's Dolphin",
        "Ross Seals",
        "Sablefish",
        "Salmon",
        "Sand Dollar",
        "Sandbar Shark",
        "Sawfish",
        "Sarcastic Fringehead",
        "Scalloped Hammerhead Shark",
        "Seahorse",
        "Sea Cucumber",
        "Sea Lion",
        "Sea Urchin",
        "Seal",
        "Shark",
        "Shortfin Mako Shark",
        "Shovelnose Guitarfish",
        "Shrimp",
        "Silverside Fish",
        "Skipjack Tuna",
        "Slender Snipe Eel",
        "Smalltooth Sawfish",
        "Smelts",
        "Sockeye Salmon",
        "Southern Stingray",
        "Sponge",
        "Spotted Porcupinefish",
        "Spotted Dolphin",
        "Spotted Eagle Ray",
        "Spotted Moray",
        "Squid",
        "Squidworm",
        "Starfish",
        "Stickleback",
        "Stonefish",
        "Stoplight Loosejaw",
        "Sturgeon",
        "Swordfish",
        "Tan Bristlemouth",
        "Tasseled Wobbegong",
        "Terrible Claw Lobster",
        "Threespot Damselfish",
        "Tiger Prawn",
        "Tiger Shark",
        "Tilefish",
        "Toadfish",
        "Tropical Two-Wing Flyfish",
        "Tuna",
        "Umbrella Squid",
        "Velvet Crab",
        "Venus Flytrap Sea Anemone",
        "Vigtorniella Worm",
        "Viperfish",
        "Vampire Squid",
        "Vaquita",
        "Wahoo",
        "Walrus",
        "West Indian Manatee",
        "Whale",
        "Whale Shark",
        "Whiptail Gulper",
        "White-Beaked Dolphin",
        "White-Ring Garden Eel",
        "White Shrimp",
        "Wobbegong",
        "Wrasse",
        "Wreckfish",
        "Xiphosura",
        "Yellowtail Damselfish",
        "Yelloweye Rockfish",
        "Yellow Cup Black Coral",
        "Yellow Tube Sponge",
        "Yellowfin Tuna",
        "Zebrashark",
        "Zooplankton"
      ],
      // list of desert, grassland, and forest animals comes from http://www.skyenimals.com/
      desert: [
        "Aardwolf",
        "Addax",
        "African Wild Ass",
        "Ant",
        "Antelope",
        "Armadillo",
        "Baboon",
        "Badger",
        "Bat",
        "Bearded Dragon",
        "Beetle",
        "Bird",
        "Black-footed Cat",
        "Boa",
        "Brown Bear",
        "Bustard",
        "Butterfly",
        "Camel",
        "Caracal",
        "Caracara",
        "Caterpillar",
        "Centipede",
        "Cheetah",
        "Chipmunk",
        "Chuckwalla",
        "Climbing Mouse",
        "Coati",
        "Cobra",
        "Cotton Rat",
        "Cougar",
        "Courser",
        "Crane Fly",
        "Crow",
        "Dassie Rat",
        "Dove",
        "Dunnart",
        "Eagle",
        "Echidna",
        "Elephant",
        "Emu",
        "Falcon",
        "Fly",
        "Fox",
        "Frogmouth",
        "Gecko",
        "Geoffroy's Cat",
        "Gerbil",
        "Grasshopper",
        "Guanaco",
        "Gundi",
        "Hamster",
        "Hawk",
        "Hedgehog",
        "Hyena",
        "Hyrax",
        "Jackal",
        "Kangaroo",
        "Kangaroo Rat",
        "Kestrel",
        "Kowari",
        "Kultarr",
        "Leopard",
        "Lion",
        "Macaw",
        "Meerkat",
        "Mouse",
        "Oryx",
        "Ostrich",
        "Owl",
        "Pronghorn",
        "Python",
        "Rabbit",
        "Raccoon",
        "Rattlesnake",
        "Rhinoceros",
        "Sand Cat",
        "Spectacled Bear",
        "Spiny Mouse",
        "Starling",
        "Stick Bug",
        "Tarantula",
        "Tit",
        "Toad",
        "Tortoise",
        "Tyrant Flycatcher",
        "Viper",
        "Vulture",
        "Waxwing",
        "Xerus",
        "Zebra"
      ],
      grassland: [
        "Aardvark",
        "Aardwolf",
        "Accentor",
        "African Buffalo",
        "African Wild Dog",
        "Alpaca",
        "Anaconda",
        "Ant",
        "Anteater",
        "Antelope",
        "Armadillo",
        "Baboon",
        "Badger",
        "Bandicoot",
        "Barbet",
        "Bat",
        "Bee",
        "Bee-eater",
        "Beetle",
        "Bird",
        "Bison",
        "Black-footed Cat",
        "Black-footed Ferret",
        "Bluebird",
        "Boa",
        "Bowerbird",
        "Brown Bear",
        "Bush Dog",
        "Bushshrike",
        "Bustard",
        "Butterfly",
        "Buzzard",
        "Caracal",
        "Caracara",
        "Cardinal",
        "Caterpillar",
        "Cheetah",
        "Chipmunk",
        "Civet",
        "Climbing Mouse",
        "Clouded Leopard",
        "Coati",
        "Cobra",
        "Cockatoo",
        "Cockroach",
        "Common Genet",
        "Cotton Rat",
        "Cougar",
        "Courser",
        "Coyote",
        "Crane",
        "Crane Fly",
        "Cricket",
        "Crow",
        "Culpeo",
        "Death Adder",
        "Deer",
        "Deer Mouse",
        "Dingo",
        "Dinosaur",
        "Dove",
        "Drongo",
        "Duck",
        "Duiker",
        "Dunnart",
        "Eagle",
        "Echidna",
        "Elephant",
        "Elk",
        "Emu",
        "Falcon",
        "Finch",
        "Flea",
        "Fly",
        "Flying Frog",
        "Fox",
        "Frog",
        "Frogmouth",
        "Garter Snake",
        "Gazelle",
        "Gecko",
        "Geoffroy's Cat",
        "Gerbil",
        "Giant Tortoise",
        "Giraffe",
        "Grasshopper",
        "Grison",
        "Groundhog",
        "Grouse",
        "Guanaco",
        "Guinea Pig",
        "Hamster",
        "Harrier",
        "Hartebeest",
        "Hawk",
        "Hedgehog",
        "Helmetshrike",
        "Hippopotamus",
        "Hornbill",
        "Hyena",
        "Hyrax",
        "Impala",
        "Jackal",
        "Jaguar",
        "Jaguarundi",
        "Kangaroo",
        "Kangaroo Rat",
        "Kestrel",
        "Kultarr",
        "Ladybug",
        "Leopard",
        "Lion",
        "Macaw",
        "Meerkat",
        "Mouse",
        "Newt",
        "Oryx",
        "Ostrich",
        "Owl",
        "Pangolin",
        "Pheasant",
        "Prairie Dog",
        "Pronghorn",
        "Przewalski's Horse",
        "Python",
        "Quoll",
        "Rabbit",
        "Raven",
        "Rhinoceros",
        "Shelduck",
        "Sloth Bear",
        "Spectacled Bear",
        "Squirrel",
        "Starling",
        "Stick Bug",
        "Tamandua",
        "Tasmanian Devil",
        "Thornbill",
        "Thrush",
        "Toad",
        "Tortoise"
      ],
      forest: [
        "Agouti",
        "Anaconda",
        "Anoa",
        "Ant",
        "Anteater",
        "Antelope",
        "Armadillo",
        "Asian Black Bear",
        "Aye-aye",
        "Babirusa",
        "Baboon",
        "Badger",
        "Bandicoot",
        "Banteng",
        "Barbet",
        "Basilisk",
        "Bat",
        "Bearded Dragon",
        "Bee",
        "Bee-eater",
        "Beetle",
        "Bettong",
        "Binturong",
        "Bird-of-paradise",
        "Bongo",
        "Bowerbird",
        "Bulbul",
        "Bush Dog",
        "Bushbaby",
        "Bushshrike",
        "Butterfly",
        "Buzzard",
        "Caecilian",
        "Cardinal",
        "Cassowary",
        "Caterpillar",
        "Centipede",
        "Chameleon",
        "Chimpanzee",
        "Cicada",
        "Civet",
        "Clouded Leopard",
        "Coati",
        "Cobra",
        "Cockatoo",
        "Cockroach",
        "Colugo",
        "Cotinga",
        "Cotton Rat",
        "Cougar",
        "Crane Fly",
        "Cricket",
        "Crocodile",
        "Crow",
        "Cuckoo",
        "Cuscus",
        "Death Adder",
        "Deer",
        "Dhole",
        "Dingo",
        "Dinosaur",
        "Drongo",
        "Duck",
        "Duiker",
        "Eagle",
        "Echidna",
        "Elephant",
        "Finch",
        "Flat-headed Cat",
        "Flea",
        "Flowerpecker",
        "Fly",
        "Flying Frog",
        "Fossa",
        "Frog",
        "Frogmouth",
        "Gaur",
        "Gecko",
        "Gorilla",
        "Grison",
        "Hawaiian Honeycreeper",
        "Hawk",
        "Hedgehog",
        "Helmetshrike",
        "Hornbill",
        "Hyrax",
        "Iguana",
        "Jackal",
        "Jaguar",
        "Jaguarundi",
        "Kestrel",
        "Ladybug",
        "Lemur",
        "Leopard",
        "Lion",
        "Macaw",
        "Mandrill",
        "Margay",
        "Monkey",
        "Mouse",
        "Mouse Deer",
        "Newt",
        "Okapi",
        "Old World Flycatcher",
        "Orangutan",
        "Owl",
        "Pangolin",
        "Peafowl",
        "Pheasant",
        "Possum",
        "Python",
        "Quokka",
        "Rabbit",
        "Raccoon",
        "Red Panda",
        "Red River Hog",
        "Rhinoceros",
        "Sloth Bear",
        "Spectacled Bear",
        "Squirrel",
        "Starling",
        "Stick Bug",
        "Sun Bear",
        "Tamandua",
        "Tamarin",
        "Tapir",
        "Tarantula",
        "Thrush",
        "Tiger",
        "Tit",
        "Toad",
        "Tortoise",
        "Toucan",
        "Trogon",
        "Trumpeter",
        "Turaco",
        "Turtle",
        "Tyrant Flycatcher",
        "Viper",
        "Vulture",
        "Wallaby",
        "Warbler",
        "Wasp",
        "Waxwing",
        "Weaver",
        "Weaver-finch",
        "Whistler",
        "White-eye",
        "Whydah",
        "Woodswallow",
        "Worm",
        "Wren",
        "Xenops",
        "Yellowjacket",
        "Accentor",
        "African Buffalo",
        "American Black Bear",
        "Anole",
        "Bird",
        "Bison",
        "Boa",
        "Brown Bear",
        "Chipmunk",
        "Common Genet",
        "Copperhead",
        "Coyote",
        "Deer Mouse",
        "Dormouse",
        "Elk",
        "Emu",
        "Fisher",
        "Fox",
        "Garter Snake",
        "Giant Panda",
        "Giant Tortoise",
        "Groundhog",
        "Grouse",
        "Guanaco",
        "Himalayan Tahr",
        "Kangaroo",
        "Koala",
        "Numbat",
        "Quoll",
        "Raccoon dog",
        "Tasmanian Devil",
        "Thornbill",
        "Turkey",
        "Vole",
        "Weasel",
        "Wildcat",
        "Wolf",
        "Wombat",
        "Woodchuck",
        "Woodpecker"
      ],
      // list of farm animals comes from https://www.buzzle.com/articles/farm-animals-list.html
      farm: [
        "Alpaca",
        "Buffalo",
        "Banteng",
        "Cow",
        "Cat",
        "Chicken",
        "Carp",
        "Camel",
        "Donkey",
        "Dog",
        "Duck",
        "Emu",
        "Goat",
        "Gayal",
        "Guinea",
        "Goose",
        "Horse",
        "Honey",
        "Llama",
        "Pig",
        "Pigeon",
        "Rhea",
        "Rabbit",
        "Sheep",
        "Silkworm",
        "Turkey",
        "Yak",
        "Zebu"
      ],
      // list of pet animals comes from https://www.dogbreedinfo.com/pets/pet.htm
      pet: [
        "Bearded Dragon",
        "Birds",
        "Burro",
        "Cats",
        "Chameleons",
        "Chickens",
        "Chinchillas",
        "Chinese Water Dragon",
        "Cows",
        "Dogs",
        "Donkey",
        "Ducks",
        "Ferrets",
        "Fish",
        "Geckos",
        "Geese",
        "Gerbils",
        "Goats",
        "Guinea Fowl",
        "Guinea Pigs",
        "Hamsters",
        "Hedgehogs",
        "Horses",
        "Iguanas",
        "Llamas",
        "Lizards",
        "Mice",
        "Mule",
        "Peafowl",
        "Pigs and Hogs",
        "Pigeons",
        "Ponies",
        "Pot Bellied Pig",
        "Rabbits",
        "Rats",
        "Sheep",
        "Skinks",
        "Snakes",
        "Stick Insects",
        "Sugar Gliders",
        "Tarantula",
        "Turkeys",
        "Turtles"
      ],
      // list of zoo animals comes from https://bronxzoo.com/animals
      zoo: [
        "Aardvark",
        "African Wild Dog",
        "Aldabra Tortoise",
        "American Alligator",
        "American Bison",
        "Amur Tiger",
        "Anaconda",
        "Andean Condor",
        "Asian Elephant",
        "Baby Doll Sheep",
        "Bald Eagle",
        "Barred Owl",
        "Blue Iguana",
        "Boer Goat",
        "California Sea Lion",
        "Caribbean Flamingo",
        "Chinchilla",
        "Collared Lemur",
        "Coquerel's Sifaka",
        "Cuban Amazon Parrot",
        "Ebony Langur",
        "Fennec Fox",
        "Fossa",
        "Gelada",
        "Giant Anteater",
        "Giraffe",
        "Gorilla",
        "Grizzly Bear",
        "Henkel's Leaf-tailed Gecko",
        "Indian Gharial",
        "Indian Rhinoceros",
        "King Cobra",
        "King Vulture",
        "Komodo Dragon",
        "Linne's Two-toed Sloth",
        "Lion",
        "Little Penguin",
        "Madagascar Tree Boa",
        "Magellanic Penguin",
        "Malayan Tapir",
        "Malayan Tiger",
        "Matschies Tree Kangaroo",
        "Mini Donkey",
        "Monarch Butterfly",
        "Nile crocodile",
        "North American Porcupine",
        "Nubian Ibex",
        "Okapi",
        "Poison Dart Frog",
        "Polar Bear",
        "Pygmy Marmoset",
        "Radiated Tortoise",
        "Red Panda",
        "Red Ruffed Lemur",
        "Ring-tailed Lemur",
        "Ring-tailed Mongoose",
        "Rock Hyrax",
        "Small Clawed Asian Otter",
        "Snow Leopard",
        "Snowy Owl",
        "Southern White-faced Owl",
        "Southern White Rhinocerous",
        "Squirrel Monkey",
        "Tufted Puffin",
        "White Cheeked Gibbon",
        "White-throated Bee Eater",
        "Zebra"
      ]
    };
    var cities = [
      "Alert",
      "Nord",
      "Eureka",
      "Ny-Ãlesund",
      "Longyearbyen",
      "Qaanaaq",
      "Grise Fiord",
      "Dikson",
      "Upernavik",
      "Tiksi",
      "Belushya Guba",
      "Barrow",
      "HonningsvÃ¥g",
      "Hammerfest",
      "Deadhorse",
      "Nuorgam",
      "VadsÃ¸",
      "Alta",
      "Utsjoki",
      "Kirkenes",
      "TromsÃ¸",
      "Tuktoyaktuk",
      "Norilsk",
      "Murmansk",
      "Harstad",
      "Narvik",
      "Inuvik",
      "Kiruna",
      "Verkhoyansk",
      "BodÃ¸",
      "GÃ¤llivare",
      "KemijÃ¤rvi",
      "Rovaniemi",
      "ÃsafjÃ¶rÃ°ur",
      "Kuusamo",
      "Tornio",
      "Boden",
      "Haparanda",
      "Kemi",
      "Akureyri",
      "LuleÃ¥",
      "PudasjÃ¤rvi",
      "PiteÃ¥",
      "Oulu",
      "Fairbanks",
      "SkellefteÃ¥",
      "Anadyr",
      "Arkhangelsk",
      "Nome",
      "Nuuk (GodthÃ¥b)",
      "ReykjavÃ­k",
      "UmeÃ¥",
      "Iqaluit",
      "StjÃ¸rdal",
      "Trondheim",
      "ÃrnskÃ¶ldsvik",
      "Ãstersund",
      "Vaasa",
      "Kuopio",
      "Yellowknife",
      "Sundsvall",
      "JyvÃ¤skylÃ¤",
      "Yakutsk",
      "TÃ³rshavn",
      "Petrozavodsk",
      "Tampere",
      "Anchorage",
      "Lillehammer",
      "Lahti",
      "Qaqortoq",
      "Whitehorse",
      "Turku",
      "Bergen",
      "Vantaa",
      "Lerwick",
      "Espoo",
      "Helsinki",
      "Oslo",
      "Saint Petersburg",
      "Uppsala",
      "Fritz Creek",
      "Magadan",
      "Tallinn",
      "Stockholm",
      "Sarpsborg",
      "Ãrebro",
      "Vologda",
      "NorrkÃ¶ping",
      "LinkÃ¶ping",
      "Tartu",
      "Juneau",
      "Arendal",
      "Kristiansand",
      "Perm",
      "Valga",
      "Gothenburg",
      "Visby",
      "Yaroslavl",
      "Inverness",
      "Aberdeen",
      "Sitka",
      "Riga",
      "Izhevsk",
      "Yekaterinburg",
      "Fort McMurray",
      "Dundee",
      "Nizhny Novgorod",
      "Stirling",
      "Bratsk",
      "Aarhus",
      "Krasnoyarsk",
      "Edinburgh",
      "Glasgow",
      "Kazan",
      "Moscow",
      "Copenhagen",
      "MalmÃ¶",
      "Esbjerg",
      "Odense",
      "Grande Prairie",
      "Chelyabinsk",
      "Novosibirsk",
      "Derry",
      "Omsk",
      "Newcastle upon Tyne",
      "Sunderland",
      "Petropavl",
      "Flensburg",
      "Ufa",
      "Kaliningrad",
      "Vilnius",
      "Belfast",
      "Middlesbrough",
      "Gdynia",
      "GdaÅsk",
      "Kiel",
      "Douglas",
      "Rostock",
      "Lancaster",
      "York",
      "Prince George",
      "Minsk",
      "Bradford",
      "Leeds",
      "Hamburg",
      "Edmonton",
      "Tolyatti",
      "Manchester",
      "Liverpool",
      "Sheffield",
      "Dublin",
      "Groningen",
      "Samara",
      "Bremen",
      "Petropavlovsk-Kamchatsky",
      "Nottingham",
      "Derby",
      "Leicester",
      "Norwich",
      "Peterborough",
      "Berlin",
      "Birmingham",
      "Gomel",
      "Coventry",
      "PoznaÅ",
      "Haarlem",
      "Amsterdam",
      "Hannover",
      "Irkutsk",
      "Warsaw",
      "Enschede",
      "Cambridge",
      "Leiden",
      "Saskatoon",
      "Utrecht",
      "The Hague",
      "MÃ¼nster",
      "Rotterdam",
      "Cork",
      "Adak",
      "Gloucester",
      "Oxford",
      "Voronezh",
      "Swansea",
      "Saratov",
      "Dortmund",
      "London",
      "Cardiff",
      "Greenwich",
      "Bristol",
      "Bath",
      "Leipzig",
      "DÃ¼sseldorf",
      "Antwerp",
      "Astana",
      "Winchester",
      "Calgary",
      "Ghent",
      "Dresden",
      "Erfurt",
      "Calais",
      "Cologne",
      "Southampton",
      "Maastricht",
      "Brussels",
      "Brighton and Hove",
      "Portsmouth",
      "Exeter",
      "Kamloops",
      "Lille",
      "Regina",
      "Kiev",
      "Charleroi",
      "Plymouth",
      "Frankfurt am Main",
      "Prague",
      "KrakÃ³w",
      "Kharkiv",
      "Winnipeg",
      "Kelowna",
      "Lviv",
      "Luxembourg",
      "Le Havre",
      "Nuremberg",
      "Rouen",
      "Vancouver",
      "Paris",
      "Stuttgart",
      "Bellingham",
      "Volgograd",
      "Strasbourg",
      "Dnipro",
      "Victoria",
      "Saguenay",
      "Brest",
      "Thunder Bay",
      "Linz",
      "Vienna",
      "Bratislava",
      "Munich",
      "Donetsk",
      "Ulaanbaatar",
      "OrlÃ©ans",
      "Salzburg",
      "Seattle",
      "St. John's",
      "Basel",
      "Budapest",
      "Qiqihar",
      "ZÃ¼rich",
      "Innsbruck",
      "Rostov-on-Don",
      "Nantes",
      "Vaduz",
      "Atyrau",
      "Graz",
      "ChiÅinÄu",
      "Bern",
      "Tiraspol",
      "Quebec City",
      "Bismarck",
      "Duluth",
      "Saint-Pierre",
      "Cluj-Napoca",
      "Moscow",
      "Helena",
      "Sault Ste. Marie",
      "Lausanne",
      "Sudbury",
      "Odessa",
      "North Bay",
      "Charlottetown",
      "Geneva",
      "Moncton",
      "Ljubljana",
      "Fredericton",
      "Zagreb",
      "Lyon",
      "Harbin",
      "New Glasgow",
      "Portland",
      "Montreal",
      "Milan",
      "Venice",
      "Ottawa",
      "Wakkanai",
      "Saint John",
      "Novi Sad",
      "Turin",
      "Krasnodar",
      "Minneapolis",
      "Simferopol",
      "Halifax",
      "Bordeaux",
      "Belgrade",
      "Å abac",
      "Drobeta Turnu Severin",
      "Bologna",
      "Bucharest",
      "Ravenna",
      "Genoa",
      "Pierre",
      "Craiova",
      "Augusta",
      "Montpelier",
      "Bath",
      "San Marino",
      "Changchun",
      "Sarajevo",
      "Yarmouth",
      "ÃrÃ¼mqi",
      "Florence",
      "Asahikawa",
      "Monaco",
      "Nice",
      "Toronto",
      "Boise",
      "Toulouse",
      "Sochi",
      "Cannes",
      "GijÃ³n",
      "Sioux Falls",
      "Split",
      "Oviedo",
      "Nemuro",
      "San SebastiÃ¡n",
      "Marseille",
      "Almaty",
      "Bilbao",
      "Concord",
      "Rochester",
      "Vladivostok",
      "Sapporo",
      "Milwaukee",
      "Sukhumi",
      "Kushiro",
      "London",
      "Follonica",
      "Obihiro",
      "Buffalo",
      "Santiago de Compostela",
      "Bishkek",
      "Vitoria-Gasteiz",
      "Sofia",
      "Pristina",
      "Andorra la Vella",
      "Nukus",
      "Podgorica",
      "Boston",
      "Detroit",
      "Windsor",
      "Vigo",
      "Tskhinvali",
      "Avezzano",
      "Skopje",
      "Colchester",
      "Rome",
      "Vatican City",
      "Chicago",
      "Providence",
      "Shenyang",
      "Chongjin",
      "Hartford",
      "Hakodate",
      "Tbilisi",
      "Valladolid",
      "Zaragoza",
      "Des Moines",
      "Braga",
      "Cleveland",
      "Barcelona",
      "Tirana",
      "Tashkent",
      "Porto",
      "Cheyenne",
      "Bari",
      "Fort Wayne",
      "Istanbul",
      "Trabzon",
      "Namangan",
      "Naples",
      "Aomori",
      "Lincoln",
      "Eureka",
      "Salt Lake City",
      "Jersey City",
      "New York City",
      "Thessaloniki",
      "Lleida",
      "Pittsburgh",
      "Baku",
      "Madrid",
      "Trenton",
      "Bursa",
      "Yerevan",
      "Boulder",
      "Columbus",
      "Ankara",
      "Philadelphia",
      "Beijing",
      "Stepanakert",
      "Forked River",
      "Eskisehir",
      "Indianapolis",
      "Denver",
      "Akita",
      "Morioka",
      "Palma",
      "Reno",
      "Flores Island",
      "Valencia",
      "Baltimore",
      "Cagliari",
      "Dover",
      "Wonsan",
      "Tianjin",
      "Cincinnati",
      "Kansas City",
      "Pyongyang",
      "Ibiza",
      "Dalian",
      "Washington",
      "Lisbon",
      "St. Louis",
      "Horta",
      "Sacramento",
      "Dushanbe",
      "Angra do HeroÃ­smo",
      "Halkida",
      "Ä°zmir",
      "Charleston",
      "Alicante",
      "Sendai",
      "Louisville",
      "Yamagata",
      "Messina",
      "Palermo",
      "Tabriz",
      "Shijiazhuang",
      "Trapani",
      "Athena",
      "Kaesong",
      "Ashgabat",
      "Niigata",
      "Taiyuan",
      "Konya",
      "Ponta Delgada",
      "Oakland",
      "San Francisco",
      "Fukushima",
      "Wichita",
      "Seoul",
      "San Jose",
      "Catania",
      "Incheon",
      "Sevilla",
      "Mugla",
      "Springfield",
      "Gaziantep",
      "Adana",
      "Virginia Beach",
      "AlmerÃ­a",
      "Tunis",
      "Mersin",
      "Algiers",
      "MÃ¡laga",
      "Toyama",
      "Jinan",
      "Nagano",
      "Xining",
      "Handan",
      "Kanazawa",
      "Utsunomiya",
      "Maebashi",
      "Mito",
      "Mosul",
      "Mashhad",
      "Arbil",
      "Las Vegas",
      "Nashville",
      "Gibraltar",
      "Tulsa",
      "Fukui",
      "Qingdao",
      "Lanzhou",
      "Knoxville",
      "Valletta",
      "Birkirkara",
      "Los Alamos",
      "Daegu",
      "Raleigh",
      "Tangier",
      "Tehran",
      "Tokyo",
      "Santa Fe",
      "KÅfu",
      "Chiba",
      "Latakia",
      "Kawasaki",
      "Tottori",
      "Oklahoma City",
      "Matsue",
      "Kirkuk",
      "Yokohama",
      "Gifu",
      "Tiaret",
      "Heraklion",
      "Melilla",
      "Charlotte",
      "Nagoya",
      "Busan",
      "Nicosia",
      "Memphis",
      "Albuquerque",
      "Åtsu",
      "Kyoto",
      "Shizuoka",
      "Zhengzhou",
      "Little Rock",
      "Sfax",
      "Tsu",
      "Osaka",
      "KÅbe",
      "Nara",
      "Okayama",
      "Kabul",
      "Santa Barbara",
      "Hiroshima",
      "Takamatsu",
      "Xi'an",
      "Wakayama",
      "Wilmington",
      "Yamaguchi",
      "Arak",
      "Srinagar",
      "Tokushima",
      "Los Angeles",
      "Rabat",
      "Peshawar",
      "Columbia",
      "Riverside",
      "Beirut",
      "Matsuyama",
      "Atlanta",
      "Islamabad",
      "Birmingham",
      "Rawalpindi",
      "Fukuoka",
      "KÅchi",
      "Casablanca",
      "Damascus",
      "Phoenix",
      "Lubbock",
      "Baghdad",
      "Saga",
      "Åita",
      "Tripoli",
      "Charleston",
      "Dallas",
      "Nagasaki",
      "Kumamoto",
      "San Diego",
      "Mexicali",
      "Funchal",
      "El Centro",
      "Isfahan",
      "Karbala",
      "Tijuana",
      "Shreveport",
      "Jackson",
      "Hamilton",
      "Tucson",
      "Benghazi",
      "Tel Aviv",
      "Nanjing",
      "Najaf",
      "Amman",
      "Miyazaki",
      "Ramallah",
      "Ensenada",
      "El Paso",
      "Jerusalem",
      "Ciudad JuÃ¡rez",
      "Amritsar",
      "Marrakech",
      "Kandahar",
      "Kagoshima",
      "Lahore",
      "Gaza",
      "Faisalabad",
      "Port Said",
      "Alexandria",
      "Shanghai",
      "Shimla",
      "Ludhiana",
      "Chandigarh",
      "Mobile",
      "Chengdu",
      "Wuhan",
      "Basra",
      "Agadir",
      "Jacksonville",
      "Austin",
      "Hangzhou",
      "Multan",
      "Cairo",
      "New Orleans",
      "Suez",
      "Houston",
      "Lhasa",
      "Chongqing",
      "Eilat",
      "San Antonio",
      "Kuwait City",
      "Shigatse",
      "Hermosillo",
      "Chihuahua",
      "New Delhi",
      "Santa Cruz de Tenerife",
      "Orlando",
      "Las Palmas de Gran Canaria",
      "Tampa",
      "Corpus Christi",
      "Maspalomas",
      "Kathmandu",
      "Dibrugarh",
      "Thimphu",
      "Gangtok",
      "Agra",
      "El AaiÃºn",
      "Sabha",
      "Jaipur",
      "Lucknow",
      "Siliguri",
      "Tezpur",
      "Kanpur",
      "Dammam",
      "Naha",
      "Manama",
      "Guwahati",
      "Brownsville",
      "Miami",
      "Luxor",
      "Monterrey",
      "Patna",
      "Shillong",
      "TorreÃ³n",
      "Kulpahar",
      "Doha",
      "Dubai",
      "Hyderabad",
      "Nassau",
      "Kunming",
      "Taipei",
      "Karachi",
      "CuliacÃ¡n",
      "Riyadh",
      "Key West",
      "Medina",
      "Abu Dhabi",
      "Al Ain",
      "Taichung",
      "Durango",
      "Agartala",
      "Dhaka",
      "Muscat",
      "Havana",
      "Guangzhou",
      "Ahmedabad",
      "Dongguan",
      "Tainan",
      "Cabo San Lucas",
      "Nanning",
      "Kaohsiung",
      "Kolkata (Calcutta)",
      "Shenzhen",
      "Chittagong",
      "Hong Kong",
      "Tampico",
      "San Luis PotosÃ­",
      "Aguascalientes",
      "Jeddah",
      "Cockburn Town",
      "Mecca",
      "Honolulu",
      "Chhattisgarh",
      "CancÃºn",
      "Surat",
      "Nagpur",
      "LeÃ³n",
      "Hanoi",
      "MÃ©rida",
      "Hai Phong",
      "Zapopan",
      "Puerto Vallarta",
      "Guadalajara",
      "QuerÃ©taro",
      "Haikou",
      "Santiago de Cuba",
      "Chiang Rai",
      "Naypyidaw",
      "Hilo",
      "George Town",
      "Veracruz",
      "Puebla",
      "Mumbai",
      "Chiang Mai",
      "Port-au-Prince",
      "Pune",
      "Santo Domingo",
      "San Juan",
      "Road Town",
      "Charlotte Amalie",
      "The Valley",
      "Nouakchott",
      "Kingston",
      "Vientiane",
      "Visakhapatnam",
      "Belize City",
      "Udon Thani",
      "Hyderabad",
      "Basseterre",
      "Belmopan",
      "St. John's",
      "Salalah",
      "Acapulco",
      "Yangon",
      "Timbuktu",
      "Huáº¿",
      "Khon Kaen",
      "Da Nang",
      "Basse-Terre",
      "Omdurman",
      "Khartoum",
      "Sana'a",
      "Asmara",
      "Roseau",
      "Saipan",
      "Son My",
      "Nakhon Ratchasima",
      "Praia",
      "Tapachula",
      "Quetzaltenango",
      "ThiÃ¨s",
      "Dakar",
      "Quezon City",
      "Guatemala City",
      "Fort-de-France",
      "Manila",
      "Makati",
      "Ayutthaya",
      "Tegucigalpa",
      "Castries",
      "Bangkok",
      "San Salvador",
      "Niamey",
      "Dededo",
      "HagÃ¥tÃ±a",
      "Banjul",
      "Serekunda",
      "Siem Reap",
      "Brikama",
      "Kingstown",
      "Bridgetown",
      "Chennai (Madras)",
      "Bangalore",
      "Pattaya",
      "Koulikoro",
      "Bamako",
      "Chinandega",
      "Oranjestad",
      "Ouagadougou",
      "Managua",
      "Willemstad",
      "N'Djamena",
      "St. George's",
      "Kano",
      "Bissau",
      "Port Blair",
      "Djibouti",
      "Phnom Penh",
      "Bobo-Dioulasso",
      "Barranquilla",
      "Ho Chi Minh City",
      "Iloilo City",
      "Port of Spain",
      "Maracaibo",
      "Liberia",
      "Caracas",
      "Chaguanas",
      "Cartagena",
      "San Fernando",
      "Cebu City",
      "Maracay",
      "Valencia",
      "Alajuela",
      "LimÃ³n",
      "Jaffna",
      "Hargeisa",
      "Puntarenas",
      "Kochi",
      "San JosÃ©",
      "Tagbilaran",
      "Conakry",
      "Tamale",
      "Surat Thani",
      "Abuja",
      "Addis Ababa",
      "Panama City",
      "MÃ©rida",
      "Moundou",
      "Trivandrum",
      "Freetown",
      "Ciudad BolÃ­var",
      "CÃºcuta",
      "Phuket",
      "San CristÃ³bal",
      "NzÃ©rÃ©korÃ©",
      "Batticaloa",
      "Melekeok",
      "Weno",
      "Ibadan",
      "Koror",
      "Kandy",
      "Majuro",
      "Davao City",
      "Hat Yai",
      "Colombo",
      "Palikir",
      "Sri Jayawardenapura-Kotte",
      "Zamboanga City",
      "Yamoussoukro",
      "Georgetown",
      "Kumasi",
      "Porto-Novo",
      "Lagos",
      "Enugu",
      "Cotonou",
      "Benin City",
      "Monrovia",
      "MedellÃ­n",
      "LomÃ©",
      "Kota Bharu",
      "Alor Setar",
      "Kota Kinabalu",
      "Paramaribo",
      "Puerto Ayacucho",
      "Accra",
      "Banda Aceh",
      "George Town",
      "Abidjan",
      "Cayenne",
      "Sekondi-Takoradi",
      "Bandar Seri Begawan",
      "Juba",
      "Port Harcourt",
      "Ipoh",
      "BogotÃ¡",
      "Miri",
      "Bangui",
      "MalÃ©",
      "Douala",
      "YaoundÃ©",
      "Malabo",
      "Medan",
      "Santiago de Cali",
      "Kuala Lumpur",
      "Boa Vista",
      "Malacca Town",
      "Mogadishu",
      "Kuching",
      "Johor Bahru",
      "South Tarawa",
      "Singapore",
      "Pekanbaru",
      "Libreville",
      "SÃ£o TomÃ©",
      "Kampala",
      "Entebbe",
      "Mbandaka",
      "MacapÃ¡",
      "Pontianak",
      "Quito",
      "Kismayo",
      "Yaren District",
      "Padang",
      "Balikpapan",
      "Nairobi",
      "BelÃ©m",
      "Kigali",
      "Guayaquil",
      "Mwanza",
      "SÃ£o LuÃ­s",
      "Jayapura",
      "Palembang",
      "Manaus",
      "Bujumbura",
      "Sobral",
      "Ambon",
      "Fortaleza",
      "Iquitos",
      "Fernando de Noronha",
      "Mombasa",
      "Brazzaville",
      "Kinshasa",
      "Victoria",
      "Teresina",
      "Makassar",
      "Imperatriz",
      "Natal",
      "Zanzibar City",
      "Dodoma",
      "Jakarta",
      "Bogor",
      "Dar es Salaam",
      "Bandung",
      "Semarang",
      "JoÃ£o Pessoa",
      "Juazeiro do Norte",
      "Campina Grande",
      "Surabaya",
      "Yogyakarta",
      "Malang",
      "Recife",
      "Trujillo",
      "Caruaru",
      "Funafuti",
      "Dili",
      "Denpasar",
      "Porto Velho",
      "Luanda",
      "Garanhuns",
      "Nukulaelae",
      "Petrolina",
      "Honiara",
      "Port Moresby",
      "MaceiÃ³",
      "Rio Branco",
      "Aracaju",
      "Palmas",
      "Lubumbashi",
      "Moroni",
      "Sinop",
      "Lima",
      "Darwin",
      "Huambo",
      "Mamoudzou",
      "Ndola",
      "Salvador",
      "Ayacucho",
      "Mata-Utu",
      "Cusco",
      "Apia",
      "Lilongwe",
      "Pago Pago",
      "IlhÃ©us",
      "Lusaka",
      "CuiabÃ¡",
      "Blantyre",
      "BrasÃ­lia",
      "Jamestown",
      "Arequipa",
      "Labasa",
      "Rabi Island",
      "La Paz",
      "GoiÃ¢nia",
      "Cairns",
      "Papeete",
      "Port Vila",
      "Santa Cruz de la Sierra",
      "Livingstone",
      "Harare",
      "Suva",
      "Arica",
      "Governador Valadares",
      "UberlÃ¢ndia",
      "Antananarivo",
      "Mutare",
      "Sucre",
      "Alofi",
      "Townsville",
      "Gweru",
      "Belo Horizonte",
      "Port Louis",
      "Bulawayo",
      "Iquique",
      "Port Hedland",
      "VitÃ³ria",
      "Campo Grande",
      "SÃ£o JosÃ© do Rio Preto",
      "Saint-Denis",
      "NukuÊ»alofa",
      "Francistown",
      "RibeirÃ£o Preto",
      "Avarua",
      "Juiz de Fora",
      "PoÃ§os de Caldas",
      "Araraquara",
      "NoumÃ©a",
      "Bauru",
      "Calama",
      "Windhoek",
      "Assis",
      "Campinas",
      "Rio de Janeiro",
      "SÃ£o JosÃ© dos Campos",
      "Rockhampton",
      "SÃ£o Paulo",
      "Antofagasta",
      "Polokwane",
      "Gaborone",
      "Salta",
      "Adamstown",
      "AsunciÃ³n",
      "Curitiba",
      "Nelspruit",
      "Ciudad del Este",
      "Pretoria",
      "Mafikeng",
      "Maputo",
      "Johannesburg",
      "Mbabane",
      "Lobamba",
      "Manzini",
      "San Miguel de TucumÃ¡n",
      "Hanga Roa",
      "CopiapÃ³",
      "Brisbane",
      "Corrientes",
      "FlorianÃ³polis",
      "Gold Coast",
      "Kimberley",
      "Kingston",
      "Bloemfontein",
      "Maseru",
      "Pietermaritzburg",
      "Durban",
      "La Serena",
      "CÃ³rdoba",
      "Santa Fe",
      "Pelotas",
      "Perth",
      "San Juan",
      "Mandurah",
      "Bhisho",
      "Mendoza",
      "Newcastle",
      "Rosario",
      "ViÃ±a del Mar",
      "ValparaÃ­so",
      "Santiago",
      "ChuÃ­",
      "Sydney",
      "Cape Town",
      "Port Elizabeth",
      "Wollongong",
      "Buenos Aires",
      "Montevideo",
      "Adelaide",
      "Canberra",
      "ConcepciÃ³n",
      "Auckland",
      "Edinburgh of the Seven Seas",
      "Hamilton",
      "Melbourne",
      "Mar del Plata",
      "Geelong",
      "BahÃ­a Blanca",
      "Temuco",
      "NeuquÃ©n",
      "Hastings",
      "Valdivia",
      "San Carlos de Bariloche",
      "Nelson",
      "Wellington",
      "Puerto Montt",
      "Launceston, Tasmania",
      "Hobart",
      "Trelew",
      "Christchurch",
      "Waitangi",
      "Puerto AisÃ©n",
      "Coihaique",
      "Comodoro Rivadavia",
      "Dunedin",
      "Invercargill",
      "RÃ­o Gallegos",
      "Stanley",
      "Punta Arenas",
      "Grytviken",
      "Ushuaia",
      "Puerto Williams",
      "Puerto Toro",
      "Villa Las Estrellas",
      "Esperanza",
      "Rothera",
      "Concordia"
    ];
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "node_modules/tiny-inflate/index.js"(exports, module) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i, sum;
      for (i = 0; i < delta; ++i)
        bits[i] = 0;
      for (i = 0; i < 30 - delta; ++i)
        bits[i + delta] = i / delta | 0;
      for (sum = first, i = 0; i < 30; ++i) {
        base[i] = sum;
        sum += 1 << bits[i];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i;
      for (i = 0; i < 7; ++i)
        lt.table[i] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i = 0; i < 24; ++i)
        lt.trans[i] = 256 + i;
      for (i = 0; i < 144; ++i)
        lt.trans[24 + i] = i;
      for (i = 0; i < 8; ++i)
        lt.trans[24 + 144 + i] = 280 + i;
      for (i = 0; i < 112; ++i)
        lt.trans[24 + 144 + 8 + i] = 144 + i;
      for (i = 0; i < 5; ++i)
        dt.table[i] = 0;
      dt.table[5] = 32;
      for (i = 0; i < 32; ++i)
        dt.trans[i] = i;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t, lengths2, off, num) {
      var i, sum;
      for (i = 0; i < 16; ++i)
        t.table[i] = 0;
      for (i = 0; i < num; ++i)
        t.table[lengths2[off + i]]++;
      t.table[0] = 0;
      for (sum = 0, i = 0; i < 16; ++i) {
        offs[i] = sum;
        sum += t.table[i];
      }
      for (i = 0; i < num; ++i) {
        if (lengths2[off + i])
          t.trans[offs[lengths2[off + i]]++] = i;
      }
    }
    function tinf_getbit(d) {
      if (!d.bitcount--) {
        d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
      }
      var bit = d.tag & 1;
      d.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d, num, base) {
      if (!num)
        return base;
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var val = d.tag & 65535 >>> 16 - num;
      d.tag >>>= num;
      d.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d, t) {
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t.table[len];
        cur -= t.table[len];
      } while (cur >= 0);
      d.tag = tag;
      d.bitcount -= len;
      return t.trans[sum + cur];
    }
    function tinf_decode_trees(d, lt, dt) {
      var hlit, hdist, hclen;
      var i, num, length;
      hlit = tinf_read_bits(d, 5, 257);
      hdist = tinf_read_bits(d, 5, 1);
      hclen = tinf_read_bits(d, 4, 4);
      for (i = 0; i < 19; ++i)
        lengths[i] = 0;
      for (i = 0; i < hclen; ++i) {
        var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length = tinf_read_bits(d, 2, 3); length; --length) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length = tinf_read_bits(d, 3, 3); length; --length) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length = tinf_read_bits(d, 7, 11); length; --length) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d.dest[d.destLen++] = sym;
        } else {
          var length, dist, offs2;
          var i;
          sym -= 257;
          length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d, dt);
          offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
          for (i = offs2; i < offs2 + length; ++i) {
            d.dest[d.destLen++] = d.dest[i];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d) {
      var length, invlength;
      var i;
      while (d.bitcount > 8) {
        d.sourceIndex--;
        d.bitcount -= 8;
      }
      length = d.source[d.sourceIndex + 1];
      length = 256 * length + d.source[d.sourceIndex];
      invlength = d.source[d.sourceIndex + 3];
      invlength = 256 * invlength + d.source[d.sourceIndex + 2];
      if (length !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d.sourceIndex += 4;
      for (i = length; i; --i)
        d.dest[d.destLen++] = d.source[d.sourceIndex++];
      d.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d);
        btype = tinf_read_bits(d, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d);
            break;
          case 1:
            res = tinf_inflate_block_data(d, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d, d.ltree, d.dtree);
            res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === "function")
          return d.dest.slice(0, d.destLen);
        else
          return d.dest.subarray(0, d.destLen);
      }
      return d.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module.exports = tinf_uncompress;
  }
});

// node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "node_modules/unicode-trie/swap.js"(exports, module) {
    var isBigEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap = (b, n, m) => {
      let i = b[n];
      b[n] = b[m];
      b[m] = i;
    };
    var swap32 = (array) => {
      const len = array.length;
      for (let i = 0; i < len; i += 4) {
        swap(array, i, i + 3);
        swap(array, i + 1, i + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian) {
        swap32(array);
      }
    };
    module.exports = {
      swap32LE
    };
  }
});

// node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "node_modules/unicode-trie/index.js"(exports, module) {
    var inflate = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data) {
        const isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
        if (isBuffer || data instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer) {
            this.highStart = data.readUInt32LE(0);
            this.errorValue = data.readUInt32LE(4);
            uncompressedLength = data.readUInt32LE(8);
            data = data.slice(12);
          } else {
            const view = new DataView(data.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data = data.subarray(12);
          }
          data = inflate(data, new Uint8Array(uncompressedLength));
          data = inflate(data, new Uint8Array(uncompressedLength));
          swap32LE(data);
          this.data = new Uint32Array(data.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);
        }
      }
      get(codePoint) {
        let index;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        if (codePoint <= 65535) {
          index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        if (codePoint < this.highStart) {
          index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module.exports = UnicodeTrie;
  }
});

// node_modules/unicode-properties/dist/main.cjs
var require_main = __commonJS({
  "node_modules/unicode-properties/dist/main.cjs"(exports, module) {
    var $c5L0i$base64js = require_base64_js();
    var $c5L0i$unicodetrie = require_unicode_trie();
    function $parcel$interopDefault(a) {
      return a && a.__esModule ? a.default : a;
    }
    function $parcel$defineInteropFlag(a) {
      Object.defineProperty(a, "__esModule", { value: true, configurable: true });
    }
    function $parcel$export(e, n, v, s) {
      Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
    }
    $parcel$defineInteropFlag(module.exports);
    $parcel$export(module.exports, "getCategory", () => $43d7963e56408b24$export$410364bbb673ddbc);
    $parcel$export(module.exports, "getCombiningClass", () => $43d7963e56408b24$export$c03b919c6651ed55);
    $parcel$export(module.exports, "getScript", () => $43d7963e56408b24$export$941569448d136665);
    $parcel$export(module.exports, "getEastAsianWidth", () => $43d7963e56408b24$export$92f6187db8ca6d26);
    $parcel$export(module.exports, "getNumericValue", () => $43d7963e56408b24$export$7d1258ebb7625a0d);
    $parcel$export(module.exports, "isAlphabetic", () => $43d7963e56408b24$export$52c8ea63abd07594);
    $parcel$export(module.exports, "isDigit", () => $43d7963e56408b24$export$727d9dbc4fbb948f);
    $parcel$export(module.exports, "isPunctuation", () => $43d7963e56408b24$export$a5b49f4dc6a07d2c);
    $parcel$export(module.exports, "isLowerCase", () => $43d7963e56408b24$export$7b6804e8df61fcf5);
    $parcel$export(module.exports, "isUpperCase", () => $43d7963e56408b24$export$aebd617640818cda);
    $parcel$export(module.exports, "isTitleCase", () => $43d7963e56408b24$export$de8b4ee23b2cf823);
    $parcel$export(module.exports, "isWhiteSpace", () => $43d7963e56408b24$export$3c52dd84024ae72c);
    $parcel$export(module.exports, "isBaseForm", () => $43d7963e56408b24$export$a11bdcffe109e74b);
    $parcel$export(module.exports, "isMark", () => $43d7963e56408b24$export$e33ad6871e762338);
    $parcel$export(module.exports, "default", () => $43d7963e56408b24$export$2e2bcd8739ae039);
    var $29668e65f2091c2c$exports = {};
    $29668e65f2091c2c$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
    var $43d7963e56408b24$var$trie = new (0, $parcel$interopDefault($c5L0i$unicodetrie))((0, $parcel$interopDefault($c5L0i$base64js)).toByteArray("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"));
    var $43d7963e56408b24$var$log2 = Math.log2 || ((n) => Math.log(n) / Math.LN2);
    var $43d7963e56408b24$var$bits = (n) => $43d7963e56408b24$var$log2(n) + 1 | 0;
    var $43d7963e56408b24$var$CATEGORY_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).categories.length - 1);
    var $43d7963e56408b24$var$COMBINING_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses.length - 1);
    var $43d7963e56408b24$var$SCRIPT_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).scripts.length - 1);
    var $43d7963e56408b24$var$EAW_BITS = $43d7963e56408b24$var$bits((0, $parcel$interopDefault($29668e65f2091c2c$exports)).eaw.length - 1);
    var $43d7963e56408b24$var$NUMBER_BITS = 10;
    var $43d7963e56408b24$var$CATEGORY_SHIFT = $43d7963e56408b24$var$COMBINING_BITS + $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$COMBINING_SHIFT = $43d7963e56408b24$var$SCRIPT_BITS + $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$SCRIPT_SHIFT = $43d7963e56408b24$var$EAW_BITS + $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$EAW_SHIFT = $43d7963e56408b24$var$NUMBER_BITS;
    var $43d7963e56408b24$var$CATEGORY_MASK = (1 << $43d7963e56408b24$var$CATEGORY_BITS) - 1;
    var $43d7963e56408b24$var$COMBINING_MASK = (1 << $43d7963e56408b24$var$COMBINING_BITS) - 1;
    var $43d7963e56408b24$var$SCRIPT_MASK = (1 << $43d7963e56408b24$var$SCRIPT_BITS) - 1;
    var $43d7963e56408b24$var$EAW_MASK = (1 << $43d7963e56408b24$var$EAW_BITS) - 1;
    var $43d7963e56408b24$var$NUMBER_MASK = (1 << $43d7963e56408b24$var$NUMBER_BITS) - 1;
    function $43d7963e56408b24$export$410364bbb673ddbc(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).categories[val >> $43d7963e56408b24$var$CATEGORY_SHIFT & $43d7963e56408b24$var$CATEGORY_MASK];
    }
    function $43d7963e56408b24$export$c03b919c6651ed55(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).combiningClasses[val >> $43d7963e56408b24$var$COMBINING_SHIFT & $43d7963e56408b24$var$COMBINING_MASK];
    }
    function $43d7963e56408b24$export$941569448d136665(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).scripts[val >> $43d7963e56408b24$var$SCRIPT_SHIFT & $43d7963e56408b24$var$SCRIPT_MASK];
    }
    function $43d7963e56408b24$export$92f6187db8ca6d26(codePoint) {
      const val = $43d7963e56408b24$var$trie.get(codePoint);
      return (0, $parcel$interopDefault($29668e65f2091c2c$exports)).eaw[val >> $43d7963e56408b24$var$EAW_SHIFT & $43d7963e56408b24$var$EAW_MASK];
    }
    function $43d7963e56408b24$export$7d1258ebb7625a0d(codePoint) {
      let val = $43d7963e56408b24$var$trie.get(codePoint);
      let num = val & $43d7963e56408b24$var$NUMBER_MASK;
      if (num === 0)
        return null;
      else if (num <= 50)
        return num - 1;
      else if (num < 480) {
        const numerator = (num >> 4) - 12;
        const denominator = (num & 15) + 1;
        return numerator / denominator;
      } else if (num < 768) {
        val = (num >> 5) - 14;
        let exp = (num & 31) + 2;
        while (exp > 0) {
          val *= 10;
          exp--;
        }
        return val;
      } else {
        val = (num >> 2) - 191;
        let exp = (num & 3) + 1;
        while (exp > 0) {
          val *= 60;
          exp--;
        }
        return val;
      }
    }
    function $43d7963e56408b24$export$52c8ea63abd07594(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
    }
    function $43d7963e56408b24$export$727d9dbc4fbb948f(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Nd";
    }
    function $43d7963e56408b24$export$a5b49f4dc6a07d2c(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
    }
    function $43d7963e56408b24$export$7b6804e8df61fcf5(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Ll";
    }
    function $43d7963e56408b24$export$aebd617640818cda(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lu";
    }
    function $43d7963e56408b24$export$de8b4ee23b2cf823(codePoint) {
      return $43d7963e56408b24$export$410364bbb673ddbc(codePoint) === "Lt";
    }
    function $43d7963e56408b24$export$3c52dd84024ae72c(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Zs" || category === "Zl" || category === "Zp";
    }
    function $43d7963e56408b24$export$a11bdcffe109e74b(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
    }
    function $43d7963e56408b24$export$e33ad6871e762338(codePoint) {
      const category = $43d7963e56408b24$export$410364bbb673ddbc(codePoint);
      return category === "Mn" || category === "Me" || category === "Mc";
    }
    var $43d7963e56408b24$export$2e2bcd8739ae039 = {
      getCategory: $43d7963e56408b24$export$410364bbb673ddbc,
      getCombiningClass: $43d7963e56408b24$export$c03b919c6651ed55,
      getScript: $43d7963e56408b24$export$941569448d136665,
      getEastAsianWidth: $43d7963e56408b24$export$92f6187db8ca6d26,
      getNumericValue: $43d7963e56408b24$export$7d1258ebb7625a0d,
      isAlphabetic: $43d7963e56408b24$export$52c8ea63abd07594,
      isDigit: $43d7963e56408b24$export$727d9dbc4fbb948f,
      isPunctuation: $43d7963e56408b24$export$a5b49f4dc6a07d2c,
      isLowerCase: $43d7963e56408b24$export$7b6804e8df61fcf5,
      isUpperCase: $43d7963e56408b24$export$aebd617640818cda,
      isTitleCase: $43d7963e56408b24$export$de8b4ee23b2cf823,
      isWhiteSpace: $43d7963e56408b24$export$3c52dd84024ae72c,
      isBaseForm: $43d7963e56408b24$export$a11bdcffe109e74b,
      isMark: $43d7963e56408b24$export$e33ad6871e762338
    };
  }
});

// node_modules/quicktype-core/dist/Messages.js
var require_Messages = __commonJS({
  "node_modules/quicktype-core/dist/Messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.messageAssert = exports.messageError = exports.QuickTypeError = void 0;
    var errorMessages = {
      InternalError: "Internal error: ${message}",
      // Misc
      MiscJSONParseError: "Syntax error in ${description} JSON ${address}: ${message}",
      MiscReadError: "Cannot read from file or URL ${fileOrURL}: ${message}",
      MiscUnicodeHighSurrogateWithoutLowSurrogate: "Malformed unicode: High surrogate not followed by low surrogate",
      MiscInvalidMinMaxConstraint: "Invalid min-max constraint: ${min}-${max}",
      // Inference
      InferenceJSONReferenceNotRooted: "JSON reference doesn't start with '#/': ${reference}",
      InferenceJSONReferenceToUnion: "JSON reference points to a union type: ${reference}",
      InferenceJSONReferenceWrongProperty: "JSON reference points to a non-existant property: ${reference}",
      InferenceJSONReferenceInvalidArrayIndex: "JSON reference uses invalid array index: ${reference}",
      // JSON Schema input
      SchemaArrayIsInvalidSchema: "An array is not a valid JSON Schema at ${ref}",
      SchemaNullIsInvalidSchema: "null is not a valid JSON Schema at ${ref}",
      SchemaRefMustBeString: "$ref must be a string, but is an ${actual} at ${ref}",
      SchemaAdditionalTypesForbidRequired: "Can't have non-specified required properties but forbidden additionalTypes at ${ref}",
      SchemaNoTypeSpecified: "JSON Schema must specify at least one type at ${ref}",
      SchemaInvalidType: "Invalid type ${type} in JSON Schema at ${ref}",
      SchemaFalseNotSupported: 'Schema "false" is not supported at ${ref}',
      SchemaInvalidJSONSchemaType: "Value of type ${type} is not valid JSON Schema at ${ref}",
      SchemaRequiredMustBeStringOrStringArray: "`required` must be string or array of strings, but is ${actual} at ${ref}",
      SchemaRequiredElementMustBeString: "`required` must contain only strings, but it has ${element}, at ${ref}",
      SchemaTypeMustBeStringOrStringArray: "`type` must be string or array of strings, but is ${actual}",
      SchemaTypeElementMustBeString: "`type` must contain only strings, but it has ${element}",
      SchemaArrayItemsMustBeStringOrArray: "Array items must be an array or an object, but is ${actual}",
      SchemaIDMustHaveAddress: "$id ${id} doesn't have an address at ${ref}",
      SchemaWrongAccessorEntryArrayLength: "Accessor entry array must have the same number of entries as the ${operation} at ${ref}",
      SchemaSetOperationCasesIsNotArray: "${operation} cases must be an array, but is ${cases}, at ${ref}",
      SchemaMoreThanOneUnionMemberName: "More than one name given for union member: ${names}",
      SchemaCannotGetTypesFromBoolean: "Schema value to get top-level types from must be an object, but is boolean, at ${ref}",
      SchemaCannotIndexArrayWithNonNumber: "Trying to index array in schema with key that is not a number, but is ${actual} at ${ref}",
      SchemaIndexNotInArray: "Index ${index} out of range of schema array at ${ref}",
      SchemaKeyNotInObject: "Key ${key} not in schema object at ${ref}",
      SchemaFetchError: "Could not fetch schema ${address}, referred to from ${base}",
      SchemaFetchErrorTopLevel: "Could not fetch top-level schema ${address}",
      SchemaFetchErrorAdditional: "Could not fetch additional schema ${address}",
      // GraphQL input
      GraphQLNoQueriesDefined: "GraphQL file doesn't have any queries defined.",
      // Driver
      DriverUnknownSourceLanguage: "Unknown source language ${lang}",
      DriverUnknownOutputLanguage: "Unknown output language ${lang}",
      DriverMoreThanOneInputGiven: "More than one input given for top-level ${topLevel}",
      DriverCannotInferNameForSchema: "Cannot infer name for schema ${uri}",
      DriverNoGraphQLQueryGiven: "Please specify at least one GraphQL query as input",
      DriverNoGraphQLSchemaInDir: "No GraphQL schema in ${dir}",
      DriverMoreThanOneGraphQLSchemaInDir: "More than one GraphQL schema in ${dir}",
      DriverSourceLangMustBeGraphQL: "If a GraphQL schema is specified, the source language must be GraphQL",
      DriverGraphQLSchemaNeeded: "Please specify a GraphQL schema with --graphql-schema or --graphql-introspect",
      DriverInputFileDoesNotExist: "Input file ${filename} does not exist",
      DriverCannotMixJSONWithOtherSamples: "Cannot mix JSON samples with JSON Schems, GraphQL, or TypeScript in input subdirectory ${dir}",
      DriverCannotMixNonJSONInputs: "Cannot mix JSON Schema, GraphQL, and TypeScript in an input subdirectory ${dir}",
      DriverUnknownDebugOption: "Unknown debug option ${option}",
      DriverNoLanguageOrExtension: "Please specify a language (--lang) or an output file extension",
      DriverCLIOptionParsingFailed: "Option parsing failed: ${message}",
      // IR
      IRNoForwardDeclarableTypeInCycle: "Cannot resolve cycle because it doesn't contain types that can be forward declared",
      IRTypeAttributesNotPropagated: "Type attributes for ${count} types were not carried over to the new graph: ${indexes}",
      IRNoEmptyUnions: "Trying to make an empty union - do you have an impossible type in your schema?",
      // Rendering
      RendererUnknownOptionValue: "Unknown value ${value} for option ${name}",
      // TypeScript input
      TypeScriptCompilerError: "TypeScript error: ${message}"
    };
    var QuickTypeError = class extends Error {
      constructor(errorMessage, messageName, userMessage, properties) {
        super(userMessage);
        this.errorMessage = errorMessage;
        this.messageName = messageName;
        this.userMessage = userMessage;
        this.properties = properties;
      }
    };
    exports.QuickTypeError = QuickTypeError;
    function messageError(kind, properties) {
      const message = errorMessages[kind];
      let userMessage = message;
      const propertiesMap = properties;
      for (const name of Object.getOwnPropertyNames(propertiesMap)) {
        let value = propertiesMap[name];
        if (typeof value === "object" && typeof value.toString === "function") {
          value = value.toString();
        } else if (typeof value.message === "string") {
          value = value.message;
        } else if (typeof value !== "string") {
          value = JSON.stringify(value);
        }
        userMessage = userMessage.replace("${" + name + "}", value);
      }
      throw new QuickTypeError(message, kind, userMessage, propertiesMap);
    }
    exports.messageError = messageError;
    function messageAssert(assertion, kind, properties) {
      if (assertion)
        return;
      return messageError(kind, properties);
    }
    exports.messageAssert = messageAssert;
  }
});

// node_modules/js-base64/base64.js
var require_base64 = __commonJS({
  "node_modules/js-base64/base64.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (
        // cf. https://github.com/dankogai/js-base64/issues/119
        function() {
          var _Base64 = global2.Base64;
          var gBase64 = factory();
          gBase64.noConflict = function() {
            global2.Base64 = _Base64;
            return gBase64;
          };
          if (global2.Meteor) {
            Base64 = gBase64;
          }
          global2.Base64 = gBase64;
        }()
      );
    })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports, function() {
      "use strict";
      var version = "3.7.7";
      var VERSION = version;
      var _hasBuffer = typeof Buffer === "function";
      var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var b64chs = Array.prototype.slice.call(b64ch);
      var b64tab = function(a) {
        var tab = {};
        a.forEach(function(c, i) {
          return tab[c] = i;
        });
        return tab;
      }(b64chs);
      var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      var _fromCC = String.fromCharCode.bind(String);
      var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
        return new Uint8Array(Array.prototype.slice.call(it, 0));
      };
      var _mkUriSafe = function(src) {
        return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
          return m0 == "+" ? "-" : "_";
        });
      };
      var _tidyB64 = function(s) {
        return s.replace(/[^A-Za-z0-9\+\/]/g, "");
      };
      var btoaPolyfill = function(bin) {
        var u32, c0, c1, c2, asc = "";
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length; ) {
          if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      var _btoa = typeof btoa === "function" ? function(bin) {
        return btoa(bin);
      } : _hasBuffer ? function(bin) {
        return Buffer.from(bin, "binary").toString("base64");
      } : btoaPolyfill;
      var _fromUint8Array = _hasBuffer ? function(u8a) {
        return Buffer.from(u8a).toString("base64");
      } : function(u8a) {
        var maxargs = 4096;
        var strs = [];
        for (var i = 0, l = u8a.length; i < l; i += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      var fromUint8Array = function(u8a, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      };
      var cb_utob = function(c) {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      var utob = function(u) {
        return u.replace(re_utob, cb_utob);
      };
      var _encode = _hasBuffer ? function(s) {
        return Buffer.from(s, "utf8").toString("base64");
      } : _TE ? function(s) {
        return _fromUint8Array(_TE.encode(s));
      } : function(s) {
        return _btoa(utob(s));
      };
      var encode = function(src, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      };
      var encodeURI = function(src) {
        return encode(src, true);
      };
      var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      var cb_btou = function(cccc) {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      var btou = function(b) {
        return b.replace(re_btou, cb_btou);
      };
      var atobPolyfill = function(asc) {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        var u24, bin = "", r1, r2;
        for (var i = 0; i < asc.length; ) {
          u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
          bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
      };
      var _atob = typeof atob === "function" ? function(asc) {
        return atob(_tidyB64(asc));
      } : _hasBuffer ? function(asc) {
        return Buffer.from(asc, "base64").toString("binary");
      } : atobPolyfill;
      var _toUint8Array = _hasBuffer ? function(a) {
        return _U8Afrom(Buffer.from(a, "base64"));
      } : function(a) {
        return _U8Afrom(_atob(a).split("").map(function(c) {
          return c.charCodeAt(0);
        }));
      };
      var toUint8Array = function(a) {
        return _toUint8Array(_unURI(a));
      };
      var _decode = _hasBuffer ? function(a) {
        return Buffer.from(a, "base64").toString("utf8");
      } : _TD ? function(a) {
        return _TD.decode(_toUint8Array(a));
      } : function(a) {
        return btou(_atob(a));
      };
      var _unURI = function(a) {
        return _tidyB64(a.replace(/[-_]/g, function(m0) {
          return m0 == "-" ? "+" : "/";
        }));
      };
      var decode = function(src) {
        return _decode(_unURI(src));
      };
      var isValid = function(src) {
        if (typeof src !== "string")
          return false;
        var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      };
      var _noEnum = function(v) {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      var extendString = function() {
        var _add = function(name, body) {
          return Object.defineProperty(String.prototype, name, _noEnum(body));
        };
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode(this, true);
        });
        _add("toBase64URL", function() {
          return encode(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      var extendUint8Array = function() {
        var _add = function(name, body) {
          return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        };
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      var extendBuiltins = function() {
        extendString();
        extendUint8Array();
      };
      var gBase64 = {
        version,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode,
        encodeURI,
        encodeURL: encodeURI,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      gBase64.Base64 = {};
      Object.keys(gBase64).forEach(function(k) {
        return gBase64.Base64[k] = gBase64[k];
      });
      return gBase64;
    });
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module.exports = pako;
  }
});

// node_modules/yaml/browser/dist/nodes/identity.js
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var ALIAS, DOC, MAP, PAIR, SCALAR, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar, isSeq, hasAnchor;
var init_identity = __esm({
  "node_modules/yaml/browser/dist/nodes/identity.js"() {
    ALIAS = Symbol.for("yaml.alias");
    DOC = Symbol.for("yaml.document");
    MAP = Symbol.for("yaml.map");
    PAIR = Symbol.for("yaml.pair");
    SCALAR = Symbol.for("yaml.scalar");
    SEQ = Symbol.for("yaml.seq");
    NODE_TYPE = Symbol.for("yaml.node.type");
    isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  }
});

// node_modules/yaml/browser/dist/visit.js
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
var BREAK, SKIP, REMOVE;
var init_visit = __esm({
  "node_modules/yaml/browser/dist/visit.js"() {
    init_identity();
    BREAK = Symbol("break visit");
    SKIP = Symbol("skip children");
    REMOVE = Symbol("remove node");
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
  }
});

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars, escapeTagName, Directives;
var init_directives = __esm({
  "node_modules/yaml/browser/dist/doc/directives.js"() {
    init_identity();
    init_visit();
    escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
          const tags = {};
          visit(doc.contents, (_key, node) => {
            if (isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  }
});

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
var init_anchors = __esm({
  "node_modules/yaml/browser/dist/doc/anchors.js"() {
    init_identity();
    init_visit();
  }
});

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
var init_applyReviver = __esm({
  "node_modules/yaml/browser/dist/doc/applyReviver.js"() {
  }
});

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}
var init_toJS = __esm({
  "node_modules/yaml/browser/dist/nodes/toJS.js"() {
    init_identity();
  }
});

// node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase;
var init_Node = __esm({
  "node_modules/yaml/browser/dist/nodes/Node.js"() {
    init_applyReviver();
    init_identity();
    init_toJS();
    NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
  }
});

// node_modules/yaml/browser/dist/nodes/Alias.js
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
var Alias;
var init_Alias = __esm({
  "node_modules/yaml/browser/dist/nodes/Alias.js"() {
    init_anchors();
    init_visit();
    init_identity();
    init_Node();
    init_toJS();
    Alias = class extends NodeBase {
      constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          toJS(source, null, ctx);
          data = anchors.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
  }
});

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue, Scalar;
var init_Scalar = __esm({
  "node_modules/yaml/browser/dist/nodes/Scalar.js"() {
    init_identity();
    init_Node();
    init_toJS();
    isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    Scalar = class extends NodeBase {
      constructor(value) {
        super(SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  }
});

// node_modules/yaml/browser/dist/doc/createNode.js
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => {
    var _a;
    return ((_a = t.identify) == null ? void 0 : _a.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b, _c;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_c = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _c.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}
var defaultTagPrefix;
var init_createNode = __esm({
  "node_modules/yaml/browser/dist/doc/createNode.js"() {
    init_Alias();
    init_identity();
    init_Scalar();
    defaultTagPrefix = "tag:yaml.org,2002:";
  }
});

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath, Collection;
var init_Collection = __esm({
  "node_modules/yaml/browser/dist/nodes/Collection.js"() {
    init_createNode();
    init_identity();
    init_Node();
    isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    Collection = class extends NodeBase {
      constructor(type, schema4) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema4,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema4) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema4)
          copy.schema = schema4;
        copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar(node) ? node.value : node;
        else
          return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var stringifyComment, lineComment;
var init_stringifyComment = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyComment.js"() {
    stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  }
});

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}
var FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED;
var init_foldFlowLines = __esm({
  "node_modules/yaml/browser/dist/stringify/foldFlowLines.js"() {
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyString.js
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
var getFoldOptions, containsDocumentMarker, blockEndNewlines;
var init_stringifyString = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyString.js"() {
    init_Scalar();
    init_foldFlowLines();
    getFoldOptions = (ctx, isBlock2) => ({
      indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
  }
});

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a;
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t) => {
      var _a2;
      return (_a2 = t.identify) == null ? void 0 : _a2.call(t, obj);
    });
    tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = ((_a = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a.name) ?? typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
var init_stringify = __esm({
  "node_modules/yaml/browser/dist/stringify/stringify.js"() {
    init_anchors();
    init_identity();
    init_stringifyComment();
    init_stringifyString();
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
var init_stringifyPair = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyPair.js"() {
    init_identity();
    init_Scalar();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
var init_log = __esm({
  "node_modules/yaml/browser/dist/log.js"() {
  }
});

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if ((ctx == null ? void 0 : ctx.doc.schema.merge) && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
var MERGE_KEY, isMergeKey;
var init_addPairToJSMap = __esm({
  "node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"() {
    init_log();
    init_stringify();
    init_identity();
    init_Scalar();
    init_toJS();
    MERGE_KEY = "<<";
    isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
  }
});

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair;
var init_Pair = __esm({
  "node_modules/yaml/browser/dist/nodes/Pair.js"() {
    init_createNode();
    init_stringifyPair();
    init_addPairToJSMap();
    init_identity();
    Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema4) {
        let { key, value } = this;
        if (isNode(key))
          key = key.clone(schema4);
        if (isNode(value))
          value = value.clone(schema4);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
var init_stringifyCollection = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyCollection.js"() {
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap;
var init_YAMLMap = __esm({
  "node_modules/yaml/browser/dist/nodes/YAMLMap.js"() {
    init_stringifyCollection();
    init_addPairToJSMap();
    init_Collection();
    init_identity();
    init_Pair();
    init_Scalar();
    YAMLMap = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema4) {
        super(MAP, schema4);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema4, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map2 = new this(schema4);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map2.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema4.sortMapEntries === "function") {
          map2.items.sort(schema4.sortMapEntries);
        }
        return map2;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        var _a;
        let _pair;
        if (isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair(pair, pair == null ? void 0 : pair.value);
        } else
          _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar(prev.value) && isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it == null ? void 0 : it.value;
        return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map2 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
        if (ctx == null ? void 0 : ctx.onCreate)
          ctx.onCreate(map2);
        for (const item of this.items)
          addPairToJSMap(ctx, map2, item);
        return map2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/map.js
var map;
var init_map = __esm({
  "node_modules/yaml/browser/dist/schema/common/map.js"() {
    init_identity();
    init_YAMLMap();
    map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
var YAMLSeq;
var init_YAMLSeq = __esm({
  "node_modules/yaml/browser/dist/nodes/YAMLSeq.js"() {
    init_createNode();
    init_stringifyCollection();
    init_Collection();
    init_identity();
    init_Scalar();
    init_toJS();
    YAMLSeq = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema4) {
        super(SEQ, schema4);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx == null ? void 0 : ctx.onCreate)
          ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items)
          seq2.push(toJS(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema4, obj, ctx) {
        const { replacer } = ctx;
        const seq2 = new this(schema4);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq2.items.push(createNode(it, void 0, ctx));
          }
        }
        return seq2;
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/seq.js
var seq;
var init_seq = __esm({
  "node_modules/yaml/browser/dist/schema/common/seq.js"() {
    init_identity();
    init_YAMLSeq();
    seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/string.js
var string;
var init_string = __esm({
  "node_modules/yaml/browser/dist/schema/common/string.js"() {
    init_stringifyString();
    string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag;
var init_null = __esm({
  "node_modules/yaml/browser/dist/schema/common/null.js"() {
    init_Scalar();
    nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag;
var init_bool = __esm({
  "node_modules/yaml/browser/dist/schema/core/bool.js"() {
    init_Scalar();
    boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
var init_stringifyNumber = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyNumber.js"() {
  }
});

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN, floatExp, float;
var init_float = __esm({
  "node_modules/yaml/browser/dist/schema/core/float.js"() {
    init_Scalar();
    init_stringifyNumber();
    floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/int.js
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intIdentify, intResolve, intOct, int, intHex;
var init_int = __esm({
  "node_modules/yaml/browser/dist/schema/core/int.js"() {
    init_stringifyNumber();
    intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
  }
});

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema;
var init_schema = __esm({
  "node_modules/yaml/browser/dist/schema/core/schema.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    schema = [
      map,
      seq,
      string,
      nullTag,
      boolTag,
      intOct,
      int,
      intHex,
      floatNaN,
      floatExp,
      float
    ];
  }
});

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON, jsonScalars, jsonError, schema2;
var init_schema2 = __esm({
  "node_modules/yaml/browser/dist/schema/json/schema.js"() {
    init_Scalar();
    init_map();
    init_seq();
    stringifyJSON = ({ value }) => JSON.stringify(value);
    jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify2,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    schema2 = [map, seq].concat(jsonScalars, jsonError);
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary;
var init_binary = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"() {
    init_Scalar();
    init_stringifyString();
    binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs;
var init_pairs = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js"() {
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLSeq();
    pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap, omap;
var init_omap = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"() {
    init_identity();
    init_toJS();
    init_YAMLMap();
    init_YAMLSeq();
    init_pairs();
    YAMLOMap = class _YAMLOMap extends YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map2 = /* @__PURE__ */ new Map();
        if (ctx == null ? void 0 : ctx.onCreate)
          ctx.onCreate(map2);
        for (const pair of this.items) {
          let key, value;
          if (isPair(pair)) {
            key = toJS(pair.key, "", ctx);
            value = toJS(pair.value, key, ctx);
          } else {
            key = toJS(pair, "", ctx);
          }
          if (map2.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map2.set(key, value);
        }
        return map2;
      }
      static from(schema4, iterable, ctx) {
        const pairs2 = createPairs(schema4, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs2.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq2, onError) {
        const pairs2 = resolvePairs(seq2, onError);
        const seenKeys = [];
        for (const { key } of pairs2.items) {
          if (isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs2);
      },
      createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag, falseTag;
var init_bool2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js"() {
    init_Scalar();
    trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar(true),
      stringify: boolStringify
    };
    falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar(false),
      stringify: boolStringify
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2, floatExp2, float2;
var init_float2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/float.js"() {
    init_Scalar();
    init_stringifyNumber();
    floatNaN2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intIdentify3, intBin, intOct2, int2, intHex2;
var init_int2 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/int.js"() {
    init_stringifyNumber();
    intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
    intBin = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
      stringify: (node) => intStringify2(node, 2, "0b")
    };
    intOct2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
      stringify: (node) => intStringify2(node, 8, "0")
    };
    int2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
      stringify: (node) => intStringify2(node, 16, "0x")
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet, set;
var init_set = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/set.js"() {
    init_identity();
    init_Pair();
    init_YAMLMap();
    YAMLSet = class _YAMLSet extends YAMLMap {
      constructor(schema4) {
        super(schema4);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair(key.key, null);
        else
          pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema4, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema4);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
      resolve(map2, onError) {
        if (isMap(map2)) {
          if (map2.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map2);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map2;
      }
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime, floatTime, timestamp;
var init_timestamp = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js"() {
    init_stringifyNumber();
    intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
  }
});

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3;
var init_schema3 = __esm({
  "node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_binary();
    init_bool2();
    init_float2();
    init_int2();
    init_omap();
    init_pairs();
    init_set();
    init_timestamp();
    schema3 = [
      map,
      seq,
      string,
      nullTag,
      trueTag,
      falseTag,
      intBin,
      intOct2,
      int2,
      intHex2,
      floatNaN2,
      floatExp2,
      float2,
      binary,
      omap,
      pairs,
      set,
      intTime,
      floatTime,
      timestamp
    ];
  }
});

// node_modules/yaml/browser/dist/schema/tags.js
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
var schemas, tagsByName, coreKnownTags;
var init_tags = __esm({
  "node_modules/yaml/browser/dist/schema/tags.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    init_schema();
    init_schema2();
    init_binary();
    init_omap();
    init_pairs();
    init_schema3();
    init_set();
    init_timestamp();
    schemas = /* @__PURE__ */ new Map([
      ["core", schema],
      ["failsafe", [map, seq, string]],
      ["json", schema2],
      ["yaml11", schema3],
      ["yaml-1.1", schema3]
    ]);
    tagsByName = {
      binary,
      bool: boolTag,
      float,
      floatExp,
      floatNaN,
      floatTime,
      int,
      intHex,
      intOct,
      intTime,
      map,
      null: nullTag,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    coreKnownTags = {
      "tag:yaml.org,2002:binary": binary,
      "tag:yaml.org,2002:omap": omap,
      "tag:yaml.org,2002:pairs": pairs,
      "tag:yaml.org,2002:set": set,
      "tag:yaml.org,2002:timestamp": timestamp
    };
  }
});

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey, Schema;
var init_Schema = __esm({
  "node_modules/yaml/browser/dist/schema/Schema.js"() {
    init_identity();
    init_map();
    init_seq();
    init_string();
    init_tags();
    sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    Schema = class _Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
        this.merge = !!merge;
        this.name = typeof schema4 === "string" && schema4 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR, { value: string });
        Object.defineProperty(this, SEQ, { value: seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
  }
});

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
var init_stringifyDocument = __esm({
  "node_modules/yaml/browser/dist/stringify/stringifyDocument.js"() {
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/yaml/browser/dist/doc/Document.js
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var Document;
var init_Document = __esm({
  "node_modules/yaml/browser/dist/doc/Document.js"() {
    init_Alias();
    init_Collection();
    init_identity();
    init_Pair();
    init_toJS();
    init_Schema();
    init_stringifyDocument();
    init_anchors();
    init_applyReviver();
    init_createNode();
    init_directives();
    Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options == null ? void 0 : options._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new Directives({ version });
        this.setSchema(version, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
        }
        return new Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (isEmptyPath(path))
          return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
        return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (isEmptyPath(path))
          return this.contents !== void 0;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new Directives({ version });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options);
      }
    };
  }
});

// node_modules/yaml/browser/dist/errors.js
var YAMLError, YAMLParseError, YAMLWarning, prettifyError;
var init_errors = __esm({
  "node_modules/yaml/browser/dist/errors.js"() {
    YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    prettifyError = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "â¦" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "â¦";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "â¦\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
  }
});

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
var init_resolve_props = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-props.js"() {
  }
});

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
var init_util_contains_newline = __esm({
  "node_modules/yaml/browser/dist/compose/util-contains-newline.js"() {
  }
});

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
var init_util_flow_indent_check = __esm({
  "node_modules/yaml/browser/dist/compose/util-flow-indent-check.js"() {
    init_util_contains_newline();
  }
});

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
var init_util_map_includes = __esm({
  "node_modules/yaml/browser/dist/compose/util-map-includes.js"() {
    init_identity();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  var _a;
  const NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? (sep == null ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a = keyProps.found) == null ? void 0 : _a.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}
var startColMsg;
var init_resolve_block_map = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-map.js"() {
    init_Pair();
    init_YAMLMap();
    init_resolve_props();
    init_util_contains_newline();
    init_util_flow_indent_check();
    init_util_map_includes();
    startColMsg = "All mapping items must start at the same column";
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  const NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}
var init_resolve_block_seq = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-seq.js"() {
    init_YAMLSeq();
    init_resolve_props();
    init_util_flow_indent_check();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}
var init_resolve_end = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-end.js"() {
  }
});

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = (tag == null ? void 0 : tag.nodeClass) ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? (sep == null ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
var blockMsg, isBlock;
var init_resolve_flow_collection = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-flow-collection.js"() {
    init_identity();
    init_Pair();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_end();
    init_resolve_props();
    init_util_contains_newline();
    init_util_map_includes();
    blockMsg = "Block collections are not allowed within flow collections";
    isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  }
});

// node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, tagToken, onError) {
  var _a;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq" || !expType) {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt == null ? void 0 : kt.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = ((_a = tag.resolve) == null ? void 0 : _a.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}
var init_compose_collection = __esm({
  "node_modules/yaml/browser/dist/compose/compose-collection.js"() {
    init_identity();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_block_map();
    init_resolve_block_seq();
    init_resolve_flow_collection();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
var init_resolve_block_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-block-scalar.js"() {
    init_Scalar();
  }
});

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + ((match == null ? void 0 : match[1]) ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
var escapeCodes;
var init_resolve_flow_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"() {
    init_Scalar();
    init_resolve_end();
    escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "Â",
      // Unicode next line
      _: "Â ",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
  }
});

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  const tag = schema4.tags.find((tag2) => {
    var _a;
    return tag2.default && ((_a = tag2.test) == null ? void 0 : _a.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag2) => {
      var _a;
      return tag2.default && ((_a = tag2.test) == null ? void 0 : _a.test(value));
    }) ?? schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
var init_compose_scalar = __esm({
  "node_modules/yaml/browser/dist/compose/compose-scalar.js"() {
    init_identity();
    init_Scalar();
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
  }
});

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}
var init_util_empty_scalar_position = __esm({
  "node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js"() {
  }
});

// node_modules/yaml/browser/dist/compose/compose-node.js
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
var CN;
var init_compose_node = __esm({
  "node_modules/yaml/browser/dist/compose/compose-node.js"() {
    init_Alias();
    init_compose_collection();
    init_compose_scalar();
    init_resolve_end();
    init_util_empty_scalar_position();
    CN = { composeNode, composeEmptyNode };
  }
});

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? (end == null ? void 0 : end[0]),
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}
var init_compose_doc = __esm({
  "node_modules/yaml/browser/dist/compose/compose-doc.js"() {
    init_Document();
    init_compose_node();
    init_resolve_end();
    init_resolve_props();
  }
});

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) == null ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer;
var init_composer = __esm({
  "node_modules/yaml/browser/dist/compose/composer.js"() {
    init_directives();
    init_Document();
    init_errors();
    init_identity();
    init_compose_doc();
    init_resolve_end();
    Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new YAMLWarning(pos, code, message));
          else
            this.errors.push(new YAMLParseError(pos, code, message));
        };
        this.directives = new Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
var init_cst_scalar = __esm({
  "node_modules/yaml/browser/dist/parse/cst-scalar.js"() {
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
    init_errors();
    init_stringifyString();
  }
});

// node_modules/yaml/browser/dist/parse/cst-stringify.js
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}
var stringify2;
var init_cst_stringify = __esm({
  "node_modules/yaml/browser/dist/parse/cst-stringify.js"() {
    stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
  }
});

// node_modules/yaml/browser/dist/parse/cst-visit.js
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}
var BREAK2, SKIP2, REMOVE2;
var init_cst_visit = __esm({
  "node_modules/yaml/browser/dist/parse/cst-visit.js"() {
    BREAK2 = Symbol("break visit");
    SKIP2 = Symbol("skip children");
    REMOVE2 = Symbol("remove item");
    visit2.BREAK = BREAK2;
    visit2.SKIP = SKIP2;
    visit2.REMOVE = REMOVE2;
    visit2.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item == null ? void 0 : item[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit2.parentCollection = (cst, path) => {
      const parent = visit2.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent == null ? void 0 : parent[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
  }
});

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var BOM, DOCUMENT, FLOW_END, SCALAR2, isCollection2, isScalar2;
var init_cst = __esm({
  "node_modules/yaml/browser/dist/parse/cst.js"() {
    init_cst_scalar();
    init_cst_stringify();
    init_cst_visit();
    BOM = "\uFEFF";
    DOCUMENT = "";
    FLOW_END = "";
    SCALAR2 = "";
    isCollection2 = (token) => !!token && "items" in token;
    isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  }
});

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits, tagChars, invalidFlowScalarChars, invalidAnchorChars, isNotAnchorChar, Lexer;
var init_lexer = __esm({
  "node_modules/yaml/browser/dist/parse/lexer.js"() {
    init_cst();
    hexDigits = "0123456789ABCDEFabcdef".split("");
    tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
    invalidFlowScalarChars = ",[]{}".split("");
    invalidAnchorChars = " ,[]{}\n\r	".split("");
    isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
    Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if (s === "---" && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s === "..." && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i = this.pos; ch = this.buffer[i]; ++i) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i = nl - 1;
            let ch2 = this.buffer[i];
            if (ch2 === "\r")
              ch2 = this.buffer[--i];
            const lastChar = i;
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i];
            if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
              nl = i;
            else
              break;
          } while (true);
        }
        yield SCALAR2;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && next === ",")
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR2;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.includes(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter;
var init_line_counter = __esm({
  "node_modules/yaml/browser/dist/parse/line-counter.js"() {
    LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
  }
});

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser;
var init_parser = __esm({
  "node_modules/yaml/browser/dist/parse/parser.js"() {
    init_cst();
    init_lexer();
    Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map2 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map2;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map2) {
        var _a;
        const it = map2.items[map2.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last == null ? void 0 : last.type) === "comment")
                end == null ? void 0 : end.push(this.sourceToken);
              else
                map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map2.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map2.indent)) {
                const prev = map2.items[map2.items.length - 2];
                const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map2.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map2.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
                it.start.push(this.sourceToken);
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map2.items.push({ start });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (includesToken(it.start, "explicit-key-ind")) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map2.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map2.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map2);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
                  map2.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq2) {
        var _a;
        const it = seq2.items[seq2.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last == null ? void 0 : last.type) === "comment")
                end == null ? void 0 : end.push(this.sourceToken);
              else
                seq2.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq2.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq2.indent)) {
                const prev = seq2.items[seq2.items.length - 2];
                const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq2.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq2.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq2.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq2.indent) {
          const bv = this.startBlockValue(seq2);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep)
                this.stack.push(fs);
              else
                Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map2 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map2;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
  }
});

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  const docs = Array.from(composer.compose(parser.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify3(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value, _replacer, options).toString(options);
}
var init_public_api = __esm({
  "node_modules/yaml/browser/dist/public-api.js"() {
    init_composer();
    init_Document();
    init_errors();
    init_log();
    init_line_counter();
    init_parser();
  }
});

// node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});
var init_dist = __esm({
  "node_modules/yaml/browser/dist/index.js"() {
    init_composer();
    init_Document();
    init_Schema();
    init_errors();
    init_Alias();
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_cst();
    init_lexer();
    init_line_counter();
    init_parser();
    init_public_api();
    init_visit();
  }
});

// node_modules/yaml/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  default: () => browser_default,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});
var browser_default;
var init_browser = __esm({
  "node_modules/yaml/browser/index.js"() {
    init_dist();
    init_dist();
    browser_default = dist_exports;
  }
});

// node_modules/quicktype-core/dist/support/Support.js
var require_Support = __commonJS({
  "node_modules/quicktype-core/dist/support/Support.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberEnumValues = exports.indentationString = exports.parseJSON = exports.inflateBase64 = exports.errorMessage = exports.repeatedCall = exports.repeated = exports.mustNotHappen = exports.panic = exports.assert = exports.assertNever = exports.nonNull = exports.defined = exports.checkArray = exports.checkStringMap = exports.checkString = exports.isStringMap = void 0;
    var js_base64_1 = require_base64();
    var pako = __importStar(require_pako());
    var YAML = __importStar((init_browser(), __toCommonJS(browser_exports)));
    var Messages_1 = require_Messages();
    function isStringMap(x, checkValue) {
      if (typeof x !== "object" || Array.isArray(x) || x === null) {
        return false;
      }
      if (checkValue !== void 0) {
        for (const k of Object.getOwnPropertyNames(x)) {
          const v = x[k];
          if (!checkValue(v)) {
            return false;
          }
        }
      }
      return true;
    }
    exports.isStringMap = isStringMap;
    function checkString(x) {
      return typeof x === "string";
    }
    exports.checkString = checkString;
    function checkStringMap(x, checkValue) {
      if (checkValue && isStringMap(x, checkValue)) {
        return x;
      }
      if (isStringMap(x)) {
        return x;
      }
      return panic(`Value must be an object, but is ${x}`);
    }
    exports.checkStringMap = checkStringMap;
    function checkArray(x, checkItem) {
      if (!Array.isArray(x)) {
        return panic(`Value must be an array, but is ${x}`);
      }
      if (checkItem !== void 0) {
        for (const v of x) {
          if (!checkItem(v)) {
            return panic(`Array item does not satisfy constraint: ${v}`);
          }
        }
      }
      return x;
    }
    exports.checkArray = checkArray;
    function defined(x) {
      if (x !== void 0)
        return x;
      return panic("Defined value expected, but got undefined");
    }
    exports.defined = defined;
    function nonNull(x) {
      if (x !== null)
        return x;
      return panic("Non-null value expected, but got null");
    }
    exports.nonNull = nonNull;
    function assertNever(x) {
      return (0, Messages_1.messageError)("InternalError", { message: `Unexpected object ${x}` });
    }
    exports.assertNever = assertNever;
    function assert(condition, message = "Assertion failed") {
      if (!condition) {
        return (0, Messages_1.messageError)("InternalError", { message });
      }
    }
    exports.assert = assert;
    function panic(message) {
      return (0, Messages_1.messageError)("InternalError", { message });
    }
    exports.panic = panic;
    function mustNotHappen() {
      return panic("This must not happen");
    }
    exports.mustNotHappen = mustNotHappen;
    function repeated(n, value) {
      const arr = [];
      for (let i = 0; i < n; i++) {
        arr.push(value);
      }
      return arr;
    }
    exports.repeated = repeated;
    function repeatedCall(n, producer) {
      const arr = [];
      for (let i = 0; i < n; i++) {
        arr.push(producer());
      }
      return arr;
    }
    exports.repeatedCall = repeatedCall;
    function errorMessage(e) {
      if (e instanceof Error) {
        return e.message;
      }
      return e.toString();
    }
    exports.errorMessage = errorMessage;
    function inflateBase64(encoded) {
      const bytes = js_base64_1.Base64.atob(encoded);
      return pako.inflate(bytes, { to: "string" });
    }
    exports.inflateBase64 = inflateBase64;
    function parseJSON(text, description, address = "<unknown>") {
      try {
        if (text.charCodeAt(0) === 65279) {
          text = text.slice(1);
        }
        return YAML.parse(text);
      } catch (e) {
        let message;
        if (e instanceof SyntaxError) {
          message = e.message;
        } else {
          message = `Unknown exception ${e}`;
        }
        return (0, Messages_1.messageError)("MiscJSONParseError", { description, address, message });
      }
    }
    exports.parseJSON = parseJSON;
    function indentationString(level) {
      return "  ".repeat(level);
    }
    exports.indentationString = indentationString;
    function numberEnumValues(e) {
      const result = [];
      for (const k of Object.keys(e)) {
        const v = e[k];
        if (typeof v === "number") {
          result.push(v);
        }
      }
      return result;
    }
    exports.numberEnumValues = numberEnumValues;
  }
});

// node_modules/quicktype-core/dist/RendererOptions.js
var require_RendererOptions = __commonJS({
  "node_modules/quicktype-core/dist/RendererOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnumOption = exports.StringOption = exports.BooleanOption = exports.getOptionValues = exports.Option = void 0;
    var collection_utils_1 = require_dist();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Option = class {
      constructor(definition) {
        definition.renderer = true;
        this.definition = definition;
        (0, Support_1.assert)(definition.kind !== void 0, "Renderer option kind must be defined");
      }
      getValue(values) {
        const value = values[this.definition.name];
        if (value === void 0) {
          return this.definition.defaultValue;
        }
        return value;
      }
      get cliDefinitions() {
        return { actual: [this.definition], display: [this.definition] };
      }
    };
    exports.Option = Option;
    function getOptionValues(options, untypedOptionValues) {
      const optionValues = {};
      for (const name of Object.getOwnPropertyNames(options)) {
        optionValues[name] = options[name].getValue(untypedOptionValues);
      }
      return optionValues;
    }
    exports.getOptionValues = getOptionValues;
    var BooleanOption = class extends Option {
      /**
       * @param name The shorthand name.
       * @param description Short-ish description of the option.
       * @param defaultValue The default value.
       * @param kind Whether it's a primary or secondary option.
       */
      constructor(name, description, defaultValue, kind = "primary") {
        super({
          name,
          kind,
          type: Boolean,
          description,
          defaultValue
        });
      }
      get cliDefinitions() {
        const negated = Object.assign({}, this.definition, {
          name: `no-${this.definition.name}`,
          defaultValue: !this.definition.defaultValue
        });
        const display = Object.assign({}, this.definition, {
          name: `[no-]${this.definition.name}`,
          description: `${this.definition.description} (${this.definition.defaultValue ? "on" : "off"} by default)`
        });
        return {
          display: [display],
          actual: [this.definition, negated]
        };
      }
      getValue(values) {
        let value = values[this.definition.name];
        if (value === void 0) {
          value = this.definition.defaultValue;
        }
        let negated = values[`no-${this.definition.name}`];
        if (negated === void 0) {
          negated = !this.definition.defaultValue;
        }
        if (value === "true") {
          value = true;
        } else if (value === "false") {
          value = false;
        }
        if (this.definition.defaultValue) {
          return value && !negated;
        } else {
          return value || !negated;
        }
      }
    };
    exports.BooleanOption = BooleanOption;
    var StringOption = class extends Option {
      constructor(name, description, typeLabel, defaultValue, kind = "primary") {
        const definition = {
          name,
          kind,
          type: String,
          description,
          typeLabel,
          defaultValue
        };
        super(definition);
      }
    };
    exports.StringOption = StringOption;
    var EnumOption = class extends Option {
      constructor(name, description, values, defaultValue = void 0, kind = "primary") {
        if (defaultValue === void 0) {
          defaultValue = values[0][0];
        }
        const definition = {
          name,
          kind,
          type: String,
          description,
          typeLabel: values.map(([n, _]) => n).join("|"),
          legalValues: values.map(([n, _]) => n),
          defaultValue
        };
        super(definition);
        this._values = {};
        for (const [n, v] of values) {
          this._values[n] = v;
        }
      }
      getValue(values) {
        let name = values[this.definition.name];
        if (name === void 0) {
          name = this.definition.defaultValue;
        }
        if (!(0, collection_utils_1.hasOwnProperty)(this._values, name)) {
          return (0, Messages_1.messageError)("RendererUnknownOptionValue", { value: name, name: this.definition.name });
        }
        return this._values[name];
      }
    };
    exports.EnumOption = EnumOption;
  }
});

// node_modules/quicktype-core/dist/support/Acronyms.js
var require_Acronyms = __commonJS({
  "node_modules/quicktype-core/dist/support/Acronyms.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.acronymStyle = exports.acronymOption = exports.AcronymStyleOptions = exports.acronyms = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var Strings_1 = require_Strings();
    exports.acronyms = [
      "aaa",
      "aabb",
      "aac",
      "aal",
      "aalc",
      "aarp",
      "abac",
      "abcl",
      "abi",
      "abm",
      "abr",
      "ac",
      "acd",
      "ack",
      "acl",
      "acm",
      "acme",
      "acp",
      "acpi",
      "acr",
      "adb",
      "adc",
      "adccp",
      "ado",
      "adsl",
      "adt",
      "ae",
      "aes",
      "af",
      "afp",
      "agp",
      "ai",
      "aix",
      "alac",
      "algol",
      "alsa",
      "alu",
      "amd",
      "amoled",
      "amqp",
      "amr",
      "ann",
      "ansi",
      "aop",
      "apci",
      "api",
      "apic",
      "apipa",
      "apl",
      "apr",
      "arin",
      "aros",
      "arp",
      "arpa",
      "arpanet",
      "ascii",
      "aset",
      "asg",
      "asic",
      "asimo",
      "aslr",
      "asm",
      "asmp",
      "asp",
      "asr",
      "assp",
      "ast",
      "ata",
      "atag",
      "atapi",
      "atm",
      "av",
      "avc",
      "avi",
      "awfl",
      "awk",
      "awt",
      "bal",
      "bam",
      "bbp",
      "bbs",
      "bcd",
      "bcnf",
      "beep",
      "ber",
      "bfd",
      "bfs",
      "bft",
      "bgp",
      "bi",
      "binac",
      "bios",
      "bjt",
      "bmp",
      "bnc",
      "boinc",
      "bom",
      "bootp",
      "bpdu",
      "bpel",
      "bpl",
      "bpm",
      "brm",
      "brms",
      "brr",
      "brs",
      "bsa",
      "bsb",
      "bsd",
      "bss",
      "bt",
      "bw",
      "byod",
      "ca",
      "cad",
      "cae",
      "cai",
      "caid",
      "captcha",
      "caq",
      "cd",
      "cde",
      "cdfs",
      "cdma",
      "cdn",
      "cdp",
      "cdsa",
      "cert",
      "ces",
      "cf",
      "cfd",
      "cfg",
      "cg",
      "cga",
      "cgi",
      "cgt",
      "chs",
      "cidr",
      "cifs",
      "cim",
      "cio",
      "cir",
      "cisc",
      "cjk",
      "cjkv",
      "cli",
      "clr",
      "cm",
      "cmdb",
      "cmmi",
      "cmo",
      "cmos",
      "cms",
      "cn",
      "cnc",
      "cng",
      "cnr",
      "cobol",
      "com",
      "corba",
      "cots",
      "cpa",
      "cpan",
      "cpri",
      "cps",
      "cpu",
      "cr",
      "cran",
      "crc",
      "crlf",
      "crm",
      "crs",
      "crt",
      "crud",
      "cs",
      "cse",
      "csi",
      "csm",
      "csp",
      "csrf",
      "css",
      "csv",
      "ct",
      "ctan",
      "ctcp",
      "ctfe",
      "cti",
      "ctl",
      "ctm",
      "cts",
      "ctss",
      "cua",
      "cvs",
      "dac",
      "dal",
      "dao",
      "dap",
      "darpa",
      "dat",
      "db",
      "dba",
      "dbcs",
      "dbms",
      "dcc",
      "dcca",
      "dccp",
      "dcl",
      "dcmi",
      "dcom",
      "dcs",
      "dd",
      "dde",
      "ddi",
      "ddl",
      "ddr",
      "dec",
      "des",
      "dfa",
      "dfd",
      "dfs",
      "dgd",
      "dhcp",
      "dhtml",
      "dif",
      "dimm",
      "din",
      "dip",
      "dism",
      "divx",
      "dkim",
      "dl",
      "dll",
      "dlna",
      "dlp",
      "dma",
      "dmca",
      "dmi",
      "dml",
      "dmr",
      "dmz",
      "dn",
      "dnd",
      "dns",
      "doa",
      "docsis",
      "dom",
      "dos",
      "dp",
      "dpc",
      "dpi",
      "dpmi",
      "dpms",
      "dr",
      "dram",
      "dri",
      "drm",
      "dsa",
      "dsdl",
      "dsdm",
      "dsl",
      "dslam",
      "dsn",
      "dsp",
      "dsssl",
      "dtd",
      "dte",
      "dtp",
      "dtr",
      "dvd",
      "dvi",
      "dvr",
      "dw",
      "eai",
      "eap",
      "eas",
      "ebcdic",
      "ebml",
      "ecc",
      "ecma",
      "ecn",
      "ecos",
      "ecrs",
      "eda",
      "edi",
      "edo",
      "edsac",
      "edvac",
      "eeprom",
      "eff",
      "efi",
      "efm",
      "efs",
      "ega",
      "egp",
      "eide",
      "eigrp",
      "eisa",
      "elf",
      "emacs",
      "ems",
      "eniac",
      "eod",
      "eof",
      "eol",
      "eom",
      "eos",
      "eprom",
      "erd",
      "erm",
      "erp",
      "esb",
      "escon",
      "esd",
      "esr",
      "etl",
      "etw",
      "euc",
      "eula",
      "ewmh",
      "ext",
      "fap",
      "faq",
      "fasm",
      "fbdimm",
      "fcb",
      "fcs",
      "fdc",
      "fdd",
      "fddi",
      "fdm",
      "fdma",
      "fds",
      "fec",
      "femb",
      "fet",
      "fhs",
      "ficon",
      "fifo",
      "fips",
      "fl",
      "flac",
      "flops",
      "fmc",
      "fmo",
      "foldoc",
      "fosdem",
      "fosi",
      "foss",
      "fp",
      "fpga",
      "fps",
      "fpu",
      "fqdn",
      "fru",
      "fs",
      "fsb",
      "fsf",
      "fsm",
      "ftp",
      "ftta",
      "fttc",
      "ftth",
      "fttp",
      "fud",
      "fvek",
      "fws",
      "fxp",
      "fyi",
      "gb",
      "gcc",
      "gcj",
      "gcr",
      "gdb",
      "gdi",
      "geran",
      "gfdl",
      "gif",
      "gigo",
      "gimps",
      "gis",
      "gml",
      "gnu",
      "goms",
      "gpasm",
      "gpfs",
      "gpg",
      "gpgpu",
      "gpib",
      "gpl",
      "gprs",
      "gpt",
      "gpu",
      "gsm",
      "gui",
      "guid",
      "gwt",
      "gyr",
      "hal",
      "hasp",
      "hba",
      "hci",
      "hcl",
      "hd",
      "hdd",
      "hdl",
      "hdmi",
      "hf",
      "hfs",
      "hhd",
      "hid",
      "hig",
      "hird",
      "hlasm",
      "hls",
      "hma",
      "hp",
      "hpc",
      "hpfs",
      "hsdpa",
      "hsm",
      "ht",
      "htc",
      "htm",
      "html",
      "http",
      "https",
      "htx",
      "hurd",
      "hvd",
      "iana",
      "ibm",
      "ic",
      "icann",
      "ich",
      "icmp",
      "icp",
      "ics",
      "ict",
      "id",
      "ide",
      "idf",
      "idl",
      "ids",
      "iec",
      "ieee",
      "ietf",
      "ifl",
      "igmp",
      "igrp",
      "ihv",
      "iiop",
      "iis",
      "ike",
      "il",
      "im",
      "imap",
      "ime",
      "infosec",
      "ip",
      "ipam",
      "ipc",
      "ipl",
      "ipmi",
      "ipo",
      "ipp",
      "ips",
      "iptv",
      "ipx",
      "ir",
      "irc",
      "iri",
      "irp",
      "irq",
      "isa",
      "isam",
      "isatap",
      "isc",
      "isdn",
      "iso",
      "isp",
      "ispf",
      "isr",
      "isv",
      "itil",
      "itl",
      "itu",
      "ivcr",
      "ivrs",
      "jaxb",
      "jaxp",
      "jbod",
      "jce",
      "jcl",
      "jcp",
      "jdbc",
      "jdk",
      "jds",
      "jee",
      "jes",
      "jfc",
      "jfet",
      "jfs",
      "jini",
      "jit",
      "jme",
      "jms",
      "jmx",
      "jndi",
      "jni",
      "jnz",
      "jpeg",
      "jre",
      "js",
      "jse",
      "json",
      "jsp",
      "jtag",
      "jvm",
      "kb",
      "kde",
      "km",
      "krl",
      "kvm",
      "lacp",
      "lan",
      "lb",
      "lba",
      "lcd",
      "lcos",
      "lcr",
      "ldap",
      "le",
      "led",
      "lf",
      "lfs",
      "lga",
      "lgpl",
      "lib",
      "lif",
      "lifo",
      "lilo",
      "lisp",
      "lkml",
      "lm",
      "loc",
      "lpc",
      "lpi",
      "lpt",
      "lru",
      "lsb",
      "lsi",
      "lte",
      "ltl",
      "ltr",
      "lun",
      "lv",
      "lvd",
      "lvm",
      "lzw",
      "mac",
      "manet",
      "mapi",
      "mb",
      "mbcs",
      "mbd",
      "mbr",
      "mca",
      "mcad",
      "mcas",
      "mcdba",
      "mcdst",
      "mcitp",
      "mcm",
      "mcp",
      "mcpc",
      "mcpd",
      "mcsa",
      "mcsd",
      "mcse",
      "mct",
      "mcts",
      "mda",
      "mdf",
      "mdi",
      "mf",
      "mfc",
      "mfm",
      "mgcp",
      "mib",
      "micr",
      "midi",
      "mimd",
      "mime",
      "mimo",
      "minix",
      "mips",
      "mis",
      "misd",
      "mit",
      "mmc",
      "mmds",
      "mmf",
      "mmi",
      "mmio",
      "mmorpg",
      "mmu",
      "mmx",
      "mng",
      "mom",
      "mos",
      "mosfet",
      "motd",
      "mous",
      "mov",
      "mpaa",
      "mpeg",
      "mpl",
      "mpls",
      "mpu",
      "ms",
      "msa",
      "msb",
      "msdn",
      "msi",
      "msn",
      "mt",
      "mta",
      "mtbf",
      "mtu",
      "mua",
      "mvc",
      "mvp",
      "mvs",
      "mwc",
      "mx",
      "mxf",
      "nack",
      "nak",
      "nas",
      "nasm",
      "ncp",
      "ncq",
      "ncsa",
      "ndis",
      "ndps",
      "nds",
      "nep",
      "nfa",
      "nfc",
      "nfs",
      "ngl",
      "ngscb",
      "ni",
      "nic",
      "nim",
      "nio",
      "nist",
      "nlp",
      "nls",
      "nmi",
      "nntp",
      "noc",
      "nop",
      "nos",
      "np",
      "npl",
      "nptl",
      "npu",
      "ns",
      "nsa",
      "nsi",
      "nspr",
      "nss",
      "nt",
      "ntfs",
      "ntlm",
      "ntp",
      "numa",
      "nurbs",
      "nvr",
      "nvram",
      "oat",
      "obsai",
      "odbc",
      "oem",
      "oes",
      "ofdm",
      "oftc",
      "oid",
      "olap",
      "ole",
      "oled",
      "olpc",
      "oltp",
      "omf",
      "omg",
      "omr",
      "oo",
      "ooe",
      "oom",
      "oop",
      "ootb",
      "opml",
      "orb",
      "orm",
      "os",
      "oscon",
      "osdn",
      "osi",
      "ospf",
      "oss",
      "ostg",
      "oui",
      "pap",
      "parc",
      "pata",
      "pbs",
      "pc",
      "pcb",
      "pci",
      "pcl",
      "pcm",
      "pcmcia",
      "pcre",
      "pd",
      "pda",
      "pdf",
      "pdh",
      "pdp",
      "pe",
      "perl",
      "pfa",
      "pg",
      "pga",
      "pgo",
      "pgp",
      "php",
      "pid",
      "pim",
      "pio",
      "pkcs",
      "pki",
      "plc",
      "pld",
      "plt",
      "pmm",
      "png",
      "pnrp",
      "poid",
      "pojo",
      "posix",
      "ppc",
      "ppi",
      "ppp",
      "pptp",
      "pr",
      "ps",
      "psa",
      "psm",
      "psu",
      "psvi",
      "pv",
      "pvg",
      "pvr",
      "pxe",
      "pxi",
      "qa",
      "qdr",
      "qfp",
      "qotd",
      "qsop",
      "qtam",
      "racf",
      "rad",
      "raid",
      "raii",
      "rait",
      "ram",
      "rarp",
      "ras",
      "rc",
      "rcs",
      "rd",
      "rdbms",
      "rdc",
      "rdf",
      "rdm",
      "rdos",
      "rdp",
      "rds",
      "refal",
      "rest",
      "rf",
      "rfc",
      "rfi",
      "rfid",
      "rgb",
      "rgba",
      "rhel",
      "rhl",
      "ria",
      "riaa",
      "rip",
      "rir",
      "risc",
      "rje",
      "rle",
      "rll",
      "rmi",
      "rms",
      "rom",
      "romb",
      "rpc",
      "rpg",
      "rpm",
      "rras",
      "rsa",
      "rsi",
      "rss",
      "rtai",
      "rtc",
      "rte",
      "rtems",
      "rtl",
      "rtos",
      "rtp",
      "rts",
      "rtsp",
      "rtti",
      "rwd",
      "san",
      "sas",
      "sata",
      "sax",
      "sbod",
      "sbu",
      "scada",
      "scid",
      "scm",
      "scp",
      "scpc",
      "scpi",
      "scsa",
      "scsi",
      "sctp",
      "sd",
      "sddl",
      "sdh",
      "sdi",
      "sdio",
      "sdk",
      "sdl",
      "sdn",
      "sdp",
      "sdr",
      "sdram",
      "sdsl",
      "se",
      "sec",
      "sei",
      "seo",
      "sftp",
      "sgi",
      "sgml",
      "sgr",
      "sha",
      "shdsl",
      "sigcat",
      "siggraph",
      "simd",
      "simm",
      "sip",
      "sisd",
      "siso",
      "sles",
      "sli",
      "slm",
      "sloc",
      "sma",
      "smb",
      "smbios",
      "sme",
      "smf",
      "smil",
      "smp",
      "smps",
      "sms",
      "smt",
      "smtp",
      "sna",
      "snmp",
      "sntp",
      "soa",
      "soe",
      "soho",
      "soi",
      "sopa",
      "sp",
      "spa",
      "sparc",
      "spf",
      "spi",
      "spm",
      "spmd",
      "sql",
      "sram",
      "ssa",
      "ssd",
      "ssdp",
      "sse",
      "ssh",
      "ssi",
      "ssid",
      "ssl",
      "ssp",
      "ssse",
      "sssp",
      "sstp",
      "sus",
      "suse",
      "svc",
      "svd",
      "svg",
      "svga",
      "swf",
      "swt",
      "tao",
      "tapi",
      "tasm",
      "tb",
      "tcp",
      "tcu",
      "tdma",
      "tft",
      "tftp",
      "ti",
      "tla",
      "tld",
      "tls",
      "tlv",
      "tnc",
      "tpf",
      "tpm",
      "troff",
      "tron",
      "trsdos",
      "tso",
      "tsp",
      "tsr",
      "tta",
      "ttf",
      "ttl",
      "tts",
      "tty",
      "tucows",
      "twain",
      "uaag",
      "uac",
      "uart",
      "uat",
      "ucs",
      "uddi",
      "udma",
      "udp",
      "uefi",
      "uhf",
      "ui",
      "ul",
      "ula",
      "uma",
      "umb",
      "uml",
      "umpc",
      "umts",
      "unc",
      "univac",
      "ups",
      "uri",
      "url",
      "usb",
      "usr",
      "utc",
      "utf",
      "utp",
      "utran",
      "uucp",
      "uuid",
      "uun",
      "uvc",
      "uwp",
      "ux",
      "vax",
      "vb",
      "vba",
      "vbs",
      "vcpi",
      "vdm",
      "vdsl",
      "vesa",
      "vfat",
      "vfs",
      "vg",
      "vga",
      "vhf",
      "vlan",
      "vlb",
      "vlf",
      "vliw",
      "vlsi",
      "vlsm",
      "vm",
      "vmm",
      "vnc",
      "vod",
      "vpn",
      "vpu",
      "vr",
      "vram",
      "vrml",
      "vsam",
      "vsat",
      "vt",
      "vtam",
      "vtl",
      "wafs",
      "wai",
      "wais",
      "wan",
      "wap",
      "wasm",
      "wbem",
      "wcag",
      "wcf",
      "wdm",
      "wep",
      "wfi",
      "wins",
      "wlan",
      "wma",
      "wmi",
      "wmv",
      "wns",
      "wol",
      "wor",
      "wora",
      "wpa",
      "wpad",
      "wpan",
      "wpf",
      "wsdl",
      "wsfl",
      "wusb",
      "wwan",
      "wwdc",
      "wwid",
      "wwn",
      "www",
      "wysiwyg",
      "wzc",
      "xag",
      "xaml",
      "xcbl",
      "xdm",
      "xdmcp",
      "xhtml",
      "xilp",
      "xml",
      "xmms",
      "xmpp",
      "xms",
      "xns",
      "xp",
      "xpcom",
      "xpi",
      "xpidl",
      "xps",
      "xsd",
      "xsl",
      "xslt",
      "xss",
      "xtf",
      "xul",
      "xvga",
      "yaaf",
      "yacc",
      "yaml",
      "zcav",
      "zcs",
      "zif",
      "zifs",
      "zisc",
      "zma",
      "zoi",
      "zope",
      "zpl"
    ];
    var AcronymStyleOptions;
    (function(AcronymStyleOptions2) {
      AcronymStyleOptions2["Camel"] = "camel";
      AcronymStyleOptions2["Lower"] = "lowerCase";
      AcronymStyleOptions2["Original"] = "original";
      AcronymStyleOptions2["Pascal"] = "pascal";
    })(AcronymStyleOptions = exports.AcronymStyleOptions || (exports.AcronymStyleOptions = {}));
    var acronymOption = function(defaultOption) {
      return new RendererOptions_1.EnumOption("acronym-style", "Acronym naming style", [
        [AcronymStyleOptions.Original, AcronymStyleOptions.Original],
        [AcronymStyleOptions.Pascal, AcronymStyleOptions.Pascal],
        [AcronymStyleOptions.Camel, AcronymStyleOptions.Camel],
        [AcronymStyleOptions.Lower, AcronymStyleOptions.Lower]
      ], defaultOption, "secondary");
    };
    exports.acronymOption = acronymOption;
    function acronymStyle(style) {
      const options = {
        [AcronymStyleOptions.Pascal]: Strings_1.allUpperWordStyle,
        [AcronymStyleOptions.Camel]: Strings_1.firstUpperWordStyle,
        [AcronymStyleOptions.Original]: Strings_1.originalWord,
        [AcronymStyleOptions.Lower]: Strings_1.allLowerWordStyle
      };
      return options[style];
    }
    exports.acronymStyle = acronymStyle;
  }
});

// node_modules/quicktype-core/dist/support/Strings.js
var require_Strings = __commonJS({
  "node_modules/quicktype-core/dist/support/Strings.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeNameStyle = exports.addPrefixIfNecessary = exports.combineWords = exports.allLowerWordStyle = exports.originalWord = exports.allUpperWordStyle = exports.firstUpperWordStyle = exports.splitIntoWords = exports.fastIsUpperCase = exports.startWithLetter = exports.snakeCase = exports.camelCase = exports.pascalCase = exports.decapitalize = exports.capitalize = exports.trimEnd = exports.isWordCharacter = exports.isLetterOrUnderscoreOrDigit = exports.isLetterOrUnderscore = exports.isLetterOrDigit = exports.isNumeric = exports.isDigit = exports.isLetter = exports.isAscii = exports.isPrintable = exports.stringEscape = exports.utf16StringEscape = exports.escapeNonPrintableMapper = exports.standardUnicodeHexEscape = exports.intToHex = exports.repeatString = exports.legalizeCharacters = exports.utf16LegalizeCharacters = exports.utf32ConcatMap = exports.utf16ConcatMap = void 0;
    var unicode_properties_1 = __importDefault(require_main());
    var Messages_1 = require_Messages();
    var Acronyms_1 = require_Acronyms();
    var Support_1 = require_Support();
    function computeAsciiMap(mapper) {
      const charStringMap = [];
      const charNoEscapeMap = [];
      for (let i = 0; i < 128; i++) {
        let noEscape = 0;
        const result = mapper(i);
        if (result === String.fromCharCode(i)) {
          noEscape = 1;
        }
        charStringMap.push(result);
        charNoEscapeMap.push(noEscape);
      }
      return { charStringMap, charNoEscapeMap };
    }
    function precomputedCodePointPredicate(p) {
      const asciiResults = [];
      for (let cp = 0; cp < 128; cp++) {
        asciiResults.push(p(cp));
      }
      return function(cp) {
        return cp < 128 ? asciiResults[cp] : p(cp);
      };
    }
    function utf16ConcatMap(mapper) {
      const { charStringMap, charNoEscapeMap } = computeAsciiMap(mapper);
      return function stringConcatMap_inner(s) {
        let cs = null;
        let start = 0;
        let i = 0;
        while (i < s.length) {
          const cc = s.charCodeAt(i);
          if (charNoEscapeMap[cc] !== 1) {
            if (cs === null)
              cs = [];
            cs.push(s.substring(start, i));
            const str = charStringMap[cc];
            if (str === void 0) {
              cs.push(mapper(s.charCodeAt(i)));
            } else {
              cs.push(str);
            }
            start = i + 1;
          }
          i++;
        }
        if (cs === null)
          return s;
        cs.push(s.substring(start, i));
        return cs.join("");
      };
    }
    exports.utf16ConcatMap = utf16ConcatMap;
    function isHighSurrogate(cc) {
      return cc >= 55296 && cc <= 56319;
    }
    function isLowSurrogate(cc) {
      return cc >= 56320 && cc <= 57343;
    }
    function utf32ConcatMap(mapper) {
      const { charStringMap, charNoEscapeMap } = computeAsciiMap(mapper);
      return function stringConcatMap_inner(s) {
        let cs = null;
        let start = 0;
        let i = 0;
        while (i < s.length) {
          let cc = s.charCodeAt(i);
          if (charNoEscapeMap[cc] !== 1) {
            if (cs === null)
              cs = [];
            cs.push(s.substring(start, i));
            if (isHighSurrogate(cc)) {
              const highSurrogate = cc;
              i++;
              const lowSurrogate = s.charCodeAt(i);
              (0, Messages_1.messageAssert)(isLowSurrogate(lowSurrogate), "MiscUnicodeHighSurrogateWithoutLowSurrogate", {});
              const highBits = highSurrogate - 55296;
              const lowBits = lowSurrogate - 56320;
              cc = 65536 + lowBits + (highBits << 10);
            }
            const str = charStringMap[cc];
            if (str === void 0) {
              cs.push(mapper(cc));
            } else {
              cs.push(str);
            }
            start = i + 1;
          }
          i++;
        }
        if (cs === null)
          return s;
        cs.push(s.substring(start, i));
        return cs.join("");
      };
    }
    exports.utf32ConcatMap = utf32ConcatMap;
    function utf16LegalizeCharacters(isLegal) {
      return utf16ConcatMap((u) => isLegal(u) ? String.fromCharCode(u) : "");
    }
    exports.utf16LegalizeCharacters = utf16LegalizeCharacters;
    function legalizeCharacters(isLegal) {
      return utf32ConcatMap((u) => u <= 65535 && isLegal(u) ? String.fromCharCode(u) : "");
    }
    exports.legalizeCharacters = legalizeCharacters;
    function repeatString(s, n) {
      (0, Support_1.assert)(n >= 0, "Cannot repeat a string a negative number of times");
      if (n === 0)
        return "";
      let result = "";
      do {
        if (n % 2 !== 0) {
          result += s;
        }
        n = Math.floor(n / 2);
        if (n > 0) {
          s += s;
        }
      } while (n > 0);
      return result;
    }
    exports.repeatString = repeatString;
    function intToHex(i, width) {
      let str = i.toString(16);
      if (str.length >= width)
        return str;
      return repeatString("0", width - str.length) + str;
    }
    exports.intToHex = intToHex;
    function standardUnicodeHexEscape(codePoint) {
      if (codePoint <= 65535) {
        return "\\u" + intToHex(codePoint, 4);
      } else {
        return "\\U" + intToHex(codePoint, 8);
      }
    }
    exports.standardUnicodeHexEscape = standardUnicodeHexEscape;
    function escapeNonPrintableMapper(printablePredicate, escaper) {
      function mapper(u) {
        switch (u) {
          case 92:
            return "\\\\";
          case 34:
            return '\\"';
          case 10:
            return "\\n";
          case 9:
            return "\\t";
          default:
            if (printablePredicate(u)) {
              return String.fromCharCode(u);
            }
            return escaper(u);
        }
      }
      return mapper;
    }
    exports.escapeNonPrintableMapper = escapeNonPrintableMapper;
    exports.utf16StringEscape = utf16ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
    exports.stringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
    function isPrintable(codePoint) {
      if (codePoint > 65535)
        return false;
      const category = unicode_properties_1.default.getCategory(codePoint);
      return [
        "Mc",
        "No",
        "Sk",
        "Me",
        "Nd",
        "Po",
        "Lt",
        "Pc",
        "Sm",
        "Zs",
        "Lu",
        "Pd",
        "So",
        "Pe",
        "Pf",
        "Ps",
        "Sc",
        "Ll",
        "Lm",
        "Pi",
        "Nl",
        "Mn",
        "Lo"
      ].includes(category);
    }
    exports.isPrintable = isPrintable;
    function isAscii(codePoint) {
      return codePoint < 128;
    }
    exports.isAscii = isAscii;
    function isLetter(codePoint) {
      const category = unicode_properties_1.default.getCategory(codePoint);
      return ["Lu", "Ll", "Lt", "Lo"].includes(category);
    }
    exports.isLetter = isLetter;
    function isDigit(codePoint) {
      const category = unicode_properties_1.default.getCategory(codePoint);
      return ["Nd"].includes(category);
    }
    exports.isDigit = isDigit;
    function isNumeric(codePoint) {
      const category = unicode_properties_1.default.getCategory(codePoint);
      return ["No", "Nd", "Nl"].includes(category);
    }
    exports.isNumeric = isNumeric;
    function isLetterOrDigit(codePoint) {
      return isLetter(codePoint) || isDigit(codePoint);
    }
    exports.isLetterOrDigit = isLetterOrDigit;
    function isLetterOrUnderscore(codePoint) {
      return isLetter(codePoint) || codePoint === 95;
    }
    exports.isLetterOrUnderscore = isLetterOrUnderscore;
    function isLetterOrUnderscoreOrDigit(codePoint) {
      return isLetterOrUnderscore(codePoint) || isDigit(codePoint);
    }
    exports.isLetterOrUnderscoreOrDigit = isLetterOrUnderscoreOrDigit;
    function isWordCharacter(codePoint) {
      return isLetter(codePoint) || isDigit(codePoint);
    }
    exports.isWordCharacter = isWordCharacter;
    function trimEnd(str) {
      const l = str.length;
      let firstWS = l;
      for (let i = l - 1; i >= 0; i--) {
        if (!unicode_properties_1.default.isWhiteSpace(str.charCodeAt(i)))
          break;
        firstWS = i;
      }
      if (firstWS === l)
        return str;
      return str.slice(0, firstWS);
    }
    exports.trimEnd = trimEnd;
    function modifyFirstChar(f, s) {
      if (s === "")
        return s;
      return f(s[0]) + s.slice(1);
    }
    function capitalize(str) {
      return modifyFirstChar((c) => c.toUpperCase(), str);
    }
    exports.capitalize = capitalize;
    function decapitalize(str) {
      return modifyFirstChar((c) => c.toLowerCase(), str);
    }
    exports.decapitalize = decapitalize;
    var wordSeparatorRegex = /[-_. ]+/;
    function pascalCase(str) {
      const words = str.split(wordSeparatorRegex).map(capitalize);
      return words.join("");
    }
    exports.pascalCase = pascalCase;
    function camelCase(str) {
      return decapitalize(pascalCase(str));
    }
    exports.camelCase = camelCase;
    function snakeCase(str) {
      const words = splitIntoWords(str).map(({ word }) => word.toLowerCase());
      return words.join("_");
    }
    exports.snakeCase = snakeCase;
    function startWithLetter(isAllowedStart, upper, str) {
      const modify = upper ? capitalize : decapitalize;
      if (str === "")
        return modify("empty");
      if (isAllowedStart(str.charCodeAt(0)))
        return modify(str);
      return modify("the" + str);
    }
    exports.startWithLetter = startWithLetter;
    var knownAcronyms = new Set(Acronyms_1.acronyms);
    var fastIsWordCharacter = precomputedCodePointPredicate(isWordCharacter);
    var fastIsNonWordCharacter = precomputedCodePointPredicate((cp) => !isWordCharacter(cp));
    var fastIsLowerCase = precomputedCodePointPredicate((cp) => unicode_properties_1.default.isLowerCase(cp));
    exports.fastIsUpperCase = precomputedCodePointPredicate((cp) => unicode_properties_1.default.isUpperCase(cp));
    var fastNonLetter = precomputedCodePointPredicate((cp) => !unicode_properties_1.default.isLowerCase(cp) && !unicode_properties_1.default.isUpperCase(cp));
    var fastIsDigit = precomputedCodePointPredicate(isDigit);
    function splitIntoWords(s) {
      const intervals = [];
      let intervalStart = void 0;
      const len = s.length;
      let i = 0;
      let lastLowerCaseIndex = void 0;
      function atEnd() {
        return i >= len;
      }
      function currentCodePoint() {
        return (0, Support_1.defined)(s.codePointAt(i));
      }
      function skipWhile(p) {
        while (!atEnd()) {
          const cp = currentCodePoint();
          if (!p(cp))
            break;
          if (fastIsLowerCase(cp))
            lastLowerCaseIndex = i;
          i++;
        }
      }
      function skipNonWord() {
        skipWhile(fastIsNonWordCharacter);
      }
      function skipLowerCase() {
        skipWhile(fastIsLowerCase);
      }
      function skipUpperCase() {
        skipWhile(exports.fastIsUpperCase);
      }
      function skipNonLetter() {
        skipWhile(fastNonLetter);
      }
      function skipDigits() {
        skipWhile(fastIsDigit);
      }
      function startInterval() {
        (0, Support_1.assert)(intervalStart === void 0, "Interval started before last one was committed");
        intervalStart = i;
      }
      function commitInterval() {
        if (intervalStart === void 0) {
          return (0, Support_1.panic)("Tried to commit interval without starting one");
        }
        (0, Support_1.assert)(i > intervalStart, "Interval must be non-empty");
        if (!atEnd() && isLowSurrogate(currentCodePoint())) {
          i += 1;
        }
        const allUpper = lastLowerCaseIndex === void 0 || lastLowerCaseIndex < intervalStart;
        intervals.push([intervalStart, i, allUpper]);
        intervalStart = void 0;
      }
      function intervalLength() {
        if (intervalStart === void 0) {
          return (0, Support_1.panic)("Tried to get interval length without starting one");
        }
        return i - intervalStart;
      }
      for (; ; ) {
        skipNonWord();
        if (atEnd())
          break;
        startInterval();
        if (fastIsLowerCase(currentCodePoint())) {
          skipLowerCase();
          skipDigits();
          commitInterval();
        } else if ((0, exports.fastIsUpperCase)(currentCodePoint())) {
          skipUpperCase();
          if (atEnd()) {
            commitInterval();
          } else if (intervalLength() === 1) {
            skipLowerCase();
            skipDigits();
            commitInterval();
          } else if (isDigit(currentCodePoint())) {
            skipDigits();
            commitInterval();
          } else {
            if (fastIsWordCharacter(currentCodePoint())) {
              i -= 1;
            }
            commitInterval();
          }
        } else {
          skipNonLetter();
          commitInterval();
        }
      }
      const words = [];
      for (const [start, end, allUpper] of intervals) {
        const word = s.slice(start, end);
        const isAcronym = lastLowerCaseIndex !== void 0 && allUpper || knownAcronyms.has(word.toLowerCase());
        words.push({ word, isAcronym });
      }
      return words;
    }
    exports.splitIntoWords = splitIntoWords;
    function firstUpperWordStyle(s) {
      (0, Support_1.assert)(s.length > 0, "Cannot style an empty string");
      return s[0].toUpperCase() + s.slice(1).toLowerCase();
    }
    exports.firstUpperWordStyle = firstUpperWordStyle;
    function allUpperWordStyle(s) {
      return s.toUpperCase();
    }
    exports.allUpperWordStyle = allUpperWordStyle;
    function originalWord(s) {
      return s;
    }
    exports.originalWord = originalWord;
    function allLowerWordStyle(s) {
      return s.toLowerCase();
    }
    exports.allLowerWordStyle = allLowerWordStyle;
    function styleWord(style, word) {
      (0, Support_1.assert)(word.length > 0, "Tried to style an empty word");
      const result = style(word);
      (0, Support_1.assert)(result.length > 0, "Word style must not make word empty");
      return result;
    }
    function combineWords(words, removeInvalidCharacters, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, isStartCharacter) {
      const legalizedWords = [];
      for (const w of words) {
        const word = removeInvalidCharacters(w.word);
        if (word.length === 0)
          continue;
        legalizedWords.push({ word, isAcronym: w.isAcronym });
      }
      if (legalizedWords.length === 0) {
        const validEmpty = removeInvalidCharacters("empty");
        (0, Support_1.assert)(validEmpty.length > 0, 'Word "empty" is invalid in target language');
        legalizedWords.push({ word: validEmpty, isAcronym: false });
      }
      const styledWords = [];
      const first = legalizedWords[0];
      const firstStyle = first.isAcronym ? firstWordAcronymStyle : firstWordStyle;
      const styledFirstWord = styleWord(firstStyle, first.word);
      let restWords;
      if (!isStartCharacter((0, Support_1.defined)(styledFirstWord.codePointAt(0)))) {
        const validThe = removeInvalidCharacters("the");
        (0, Support_1.assert)(validThe.length > 0, 'Word "the" is invalid in the target language');
        const styledThe = styleWord(firstWordStyle, validThe);
        (0, Support_1.assert)(isStartCharacter((0, Support_1.defined)(styledThe.codePointAt(0))), 'The first character of styling "the" is not a start character');
        styledWords.push(styledThe);
        restWords = legalizedWords;
      } else {
        styledWords.push(styledFirstWord);
        restWords = legalizedWords.slice(1);
      }
      for (const w of restWords) {
        const style = w.isAcronym ? restAcronymStyle : restWordStyle;
        styledWords.push(styleWord(style, w.word));
      }
      return styledWords.join(separator);
    }
    exports.combineWords = combineWords;
    function addPrefixIfNecessary(prefix, name) {
      return name.startsWith(prefix) ? name : prefix + name;
    }
    exports.addPrefixIfNecessary = addPrefixIfNecessary;
    function makeNameStyle(namingStyle, legalizeName, prefix) {
      let separator;
      let firstWordStyle;
      let restWordStyle;
      let firstWordAcronymStyle;
      let restAcronymStyle;
      if (namingStyle === "pascal" || namingStyle === "camel" || namingStyle === "pascal-upper-acronyms" || namingStyle === "camel-upper-acronyms") {
        separator = "";
        if (namingStyle === "pascal-upper-acronyms" || namingStyle === "camel-upper-acronyms") {
          restWordStyle = firstUpperWordStyle;
          restAcronymStyle = allUpperWordStyle;
        } else {
          restWordStyle = restAcronymStyle = firstUpperWordStyle;
        }
      } else {
        separator = "_";
      }
      switch (namingStyle) {
        case "pascal":
        case "pascal-upper-acronyms":
          firstWordStyle = firstWordAcronymStyle = firstUpperWordStyle;
          break;
        case "camel":
        case "camel-upper-acronyms":
          firstWordStyle = firstWordAcronymStyle = allLowerWordStyle;
          break;
        case "underscore":
          firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = allLowerWordStyle;
          break;
        case "upper-underscore":
          firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = allUpperWordStyle;
          break;
        default:
          return (0, Support_1.assertNever)(namingStyle);
      }
      return (original) => {
        const words = splitIntoWords(original);
        const styledName = combineWords(words, legalizeName, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, isLetterOrUnderscore);
        if (prefix !== void 0) {
          return addPrefixIfNecessary(prefix, styledName);
        } else {
          return styledName;
        }
      };
    }
    exports.makeNameStyle = makeNameStyle;
  }
});

// node_modules/quicktype-core/dist/attributes/TypeAttributes.js
var require_TypeAttributes = __commonJS({
  "node_modules/quicktype-core/dist/attributes/TypeAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.increaseTypeAttributesDistance = exports.makeTypeAttributesInferred = exports.combineTypeAttributes = exports.emptyTypeAttributes = exports.TypeAttributeKind = void 0;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    var TypeAttributeKind = class _TypeAttributeKind {
      constructor(name) {
        this.name = name;
      }
      appliesToTypeKind(kind) {
        return kind !== "any";
      }
      combine(_attrs) {
        return (0, Support_1.panic)(`Cannot combine type attribute ${this.name}`);
      }
      intersect(attrs) {
        return this.combine(attrs);
      }
      makeInferred(_) {
        return (0, Support_1.panic)(`Cannot make type attribute ${this.name} inferred`);
      }
      increaseDistance(attrs) {
        return attrs;
      }
      addToSchema(_schema, _t, _attrs) {
        return;
      }
      children(_) {
        return /* @__PURE__ */ new Set();
      }
      stringify(_) {
        return void 0;
      }
      get inIdentity() {
        return false;
      }
      requiresUniqueIdentity(_) {
        return false;
      }
      reconstitute(_builder, a) {
        return a;
      }
      makeAttributes(value) {
        const kvps = [[this, value]];
        return new Map(kvps);
      }
      tryGetInAttributes(a) {
        return a.get(this);
      }
      setInAttributes(a, value) {
        return new Map(a).set(this, value);
      }
      modifyInAttributes(a, modify) {
        const modified = modify(this.tryGetInAttributes(a));
        if (modified === void 0) {
          const result = new Map(a);
          result.delete(this);
          return result;
        }
        return this.setInAttributes(a, modified);
      }
      setDefaultInAttributes(a, makeDefault) {
        if (this.tryGetInAttributes(a) !== void 0)
          return a;
        return this.modifyInAttributes(a, makeDefault);
      }
      removeInAttributes(a) {
        return (0, collection_utils_1.mapFilter)(a, (_, k) => k !== this);
      }
      equals(other) {
        if (!(other instanceof _TypeAttributeKind)) {
          return false;
        }
        return this.name === other.name;
      }
      hashCode() {
        return (0, collection_utils_1.hashString)(this.name);
      }
    };
    exports.TypeAttributeKind = TypeAttributeKind;
    exports.emptyTypeAttributes = /* @__PURE__ */ new Map();
    function combineTypeAttributes(combinationKind, firstOrArray, second) {
      const union = combinationKind === "union";
      let attributeArray;
      if (Array.isArray(firstOrArray)) {
        attributeArray = firstOrArray;
      } else {
        if (second === void 0) {
          return (0, Support_1.panic)("Must have on array or two attributes");
        }
        attributeArray = [firstOrArray, second];
      }
      const attributesByKind = (0, collection_utils_1.mapTranspose)(attributeArray);
      function combine(attrs, kind) {
        (0, Support_1.assert)(attrs.length > 0, "Cannot combine zero type attributes");
        if (attrs.length === 1)
          return attrs[0];
        if (union) {
          return kind.combine(attrs);
        } else {
          return kind.intersect(attrs);
        }
      }
      return (0, collection_utils_1.mapFilterMap)(attributesByKind, combine);
    }
    exports.combineTypeAttributes = combineTypeAttributes;
    function makeTypeAttributesInferred(attr) {
      return (0, collection_utils_1.mapFilterMap)(attr, (value, kind) => kind.makeInferred(value));
    }
    exports.makeTypeAttributesInferred = makeTypeAttributesInferred;
    function increaseTypeAttributesDistance(attr) {
      return (0, collection_utils_1.mapFilterMap)(attr, (value, kind) => kind.increaseDistance(value));
    }
    exports.increaseTypeAttributesDistance = increaseTypeAttributesDistance;
  }
});

// node_modules/quicktype-core/dist/attributes/TypeNames.js
var require_TypeNames = __commonJS({
  "node_modules/quicktype-core/dist/attributes/TypeNames.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeNamesTypeAttributes = exports.singularizeTypeNames = exports.modifyTypeNames = exports.namesTypeAttributeKind = exports.TooManyTypeNames = exports.RegularTypeNames = exports.TypeNames = exports.tooManyNamesThreshold = exports.initTypeNames = void 0;
    var collection_utils_1 = require_dist();
    var pluralize = __importStar(require_pluralize());
    var Chance_1 = require_Chance();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    var chance;
    var usedRandomNames;
    function initTypeNames() {
      chance = new Chance_1.Chance(31415);
      usedRandomNames = /* @__PURE__ */ new Set();
    }
    exports.initTypeNames = initTypeNames;
    initTypeNames();
    function makeRandomName() {
      for (; ; ) {
        const name = `${chance.city()} ${chance.animal()}`;
        if (usedRandomNames.has(name))
          continue;
        usedRandomNames.add(name);
        return name;
      }
    }
    function combineNames(names) {
      let originalFirst = (0, collection_utils_1.iterableFirst)(names);
      if (originalFirst === void 0) {
        return (0, Support_1.panic)("Named type has no names");
      }
      if (names.size === 1) {
        return originalFirst;
      }
      const namesSet = (0, collection_utils_1.setMap)(names, (s) => (0, Strings_1.splitIntoWords)(s).map((w) => w.word.toLowerCase()).join("_"));
      const first = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(namesSet));
      if (namesSet.size === 1) {
        return first;
      }
      let prefixLength = first.length;
      let suffixLength = first.length;
      for (const n of (0, collection_utils_1.iterableSkip)(namesSet, 1)) {
        prefixLength = Math.min(prefixLength, n.length);
        for (let i = 0; i < prefixLength; i++) {
          if (first[i] !== n[i]) {
            prefixLength = i;
            break;
          }
        }
        suffixLength = Math.min(suffixLength, n.length);
        for (let i = 0; i < suffixLength; i++) {
          if (first[first.length - i - 1] !== n[n.length - i - 1]) {
            suffixLength = i;
            break;
          }
        }
      }
      const prefix = prefixLength > 2 ? first.slice(0, prefixLength) : "";
      const suffix = suffixLength > 2 ? first.slice(first.length - suffixLength) : "";
      const combined = prefix + suffix;
      if (combined.length > 2) {
        return combined;
      }
      return first;
    }
    exports.tooManyNamesThreshold = 1e3;
    var TypeNames = class _TypeNames {
      static makeWithDistance(names, alternativeNames, distance) {
        if (names.size >= exports.tooManyNamesThreshold) {
          return new TooManyTypeNames(distance);
        }
        if (alternativeNames === void 0 || alternativeNames.size > exports.tooManyNamesThreshold) {
          alternativeNames = void 0;
        }
        return new RegularTypeNames(names, alternativeNames, distance);
      }
      static make(names, alternativeNames, areInferred) {
        return _TypeNames.makeWithDistance(names, alternativeNames, areInferred ? 1 : 0);
      }
      constructor(distance) {
        this.distance = distance;
      }
      get areInferred() {
        return this.distance > 0;
      }
    };
    exports.TypeNames = TypeNames;
    var RegularTypeNames = class _RegularTypeNames extends TypeNames {
      constructor(names, _alternativeNames, distance) {
        super(distance);
        this.names = names;
        this._alternativeNames = _alternativeNames;
      }
      add(namesArray, startIndex = 0) {
        let newNames = new Set(this.names);
        let newDistance = this.distance;
        let newAlternativeNames = (0, collection_utils_1.definedMap)(this._alternativeNames, (s) => new Set(s));
        for (let i = startIndex; i < namesArray.length; i++) {
          const other = namesArray[i];
          if (other instanceof _RegularTypeNames && other._alternativeNames !== void 0) {
            if (newAlternativeNames === void 0) {
              newAlternativeNames = /* @__PURE__ */ new Set();
            }
            (0, collection_utils_1.setUnionInto)(newAlternativeNames, other._alternativeNames);
          }
          if (other.distance > newDistance)
            continue;
          if (!(other instanceof _RegularTypeNames)) {
            (0, Support_1.assert)(other instanceof TooManyTypeNames, "Unknown TypeNames instance");
            return other.add(namesArray, i + 1);
          }
          if (other.distance < newDistance) {
            newNames = new Set(other.names);
            newDistance = other.distance;
            newAlternativeNames = (0, collection_utils_1.definedMap)(other._alternativeNames, (s) => new Set(s));
          } else {
            (0, Support_1.assert)(other.distance === newDistance, "This should be the only case left");
            (0, collection_utils_1.setUnionInto)(newNames, other.names);
          }
        }
        return TypeNames.makeWithDistance(newNames, newAlternativeNames, newDistance);
      }
      clearInferred() {
        const newNames = this.areInferred ? /* @__PURE__ */ new Set() : this.names;
        return TypeNames.makeWithDistance(newNames, /* @__PURE__ */ new Set(), this.distance);
      }
      get combinedName() {
        return combineNames(this.names);
      }
      get proposedNames() {
        const set2 = /* @__PURE__ */ new Set([this.combinedName]);
        if (this._alternativeNames === void 0) {
          return set2;
        }
        (0, collection_utils_1.setUnionInto)(set2, this._alternativeNames);
        return set2;
      }
      makeInferred() {
        return TypeNames.makeWithDistance(this.names, this._alternativeNames, this.distance + 1);
      }
      singularize() {
        return TypeNames.makeWithDistance((0, collection_utils_1.setMap)(this.names, pluralize.singular), (0, collection_utils_1.definedMap)(this._alternativeNames, (an) => (0, collection_utils_1.setMap)(an, pluralize.singular)), this.distance + 1);
      }
      toString() {
        const inferred = this.areInferred ? `distance ${this.distance}` : "given";
        const names = `${inferred} ${Array.from(this.names).join(",")}`;
        if (this._alternativeNames === void 0) {
          return names;
        }
        return `${names} (${Array.from(this._alternativeNames).join(",")})`;
      }
    };
    exports.RegularTypeNames = RegularTypeNames;
    var TooManyTypeNames = class _TooManyTypeNames extends TypeNames {
      constructor(distance, name) {
        super(distance);
        if (name === void 0) {
          name = makeRandomName();
        }
        this.names = /* @__PURE__ */ new Set([name]);
      }
      get combinedName() {
        return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(this.names));
      }
      get proposedNames() {
        return this.names;
      }
      add(namesArray, startIndex = 0) {
        if (!this.areInferred)
          return this;
        for (let i = startIndex; i < namesArray.length; i++) {
          const other = namesArray[i];
          if (other.distance < this.distance) {
            return other.add(namesArray, i + 1);
          }
        }
        return this;
      }
      clearInferred() {
        if (!this.areInferred) {
          return this;
        }
        return TypeNames.makeWithDistance(/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), this.distance);
      }
      makeInferred() {
        return new _TooManyTypeNames(this.distance + 1, (0, collection_utils_1.iterableFirst)(this.names));
      }
      singularize() {
        return this;
      }
      toString() {
        return `too many ${this.combinedName}`;
      }
    };
    exports.TooManyTypeNames = TooManyTypeNames;
    var TypeNamesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("names");
      }
      combine(namesArray) {
        (0, Support_1.assert)(namesArray.length > 0, "Can't combine zero type names");
        return namesArray[0].add(namesArray, 1);
      }
      makeInferred(tn) {
        return tn.makeInferred();
      }
      increaseDistance(tn) {
        return tn.makeInferred();
      }
      stringify(tn) {
        return tn.toString();
      }
    };
    exports.namesTypeAttributeKind = new TypeNamesTypeAttributeKind();
    function modifyTypeNames(attributes, modifier) {
      return exports.namesTypeAttributeKind.modifyInAttributes(attributes, modifier);
    }
    exports.modifyTypeNames = modifyTypeNames;
    function singularizeTypeNames(attributes) {
      return modifyTypeNames(attributes, (maybeNames) => {
        if (maybeNames === void 0)
          return void 0;
        return maybeNames.singularize();
      });
    }
    exports.singularizeTypeNames = singularizeTypeNames;
    function makeNamesTypeAttributes(nameOrNames, areNamesInferred) {
      let typeNames;
      if (typeof nameOrNames === "string") {
        typeNames = TypeNames.make(/* @__PURE__ */ new Set([nameOrNames]), /* @__PURE__ */ new Set(), (0, Support_1.defined)(areNamesInferred));
      } else {
        typeNames = nameOrNames;
      }
      return exports.namesTypeAttributeKind.makeAttributes(typeNames);
    }
    exports.makeNamesTypeAttributes = makeNamesTypeAttributes;
  }
});

// node_modules/urijs/src/punycode.js
var require_punycode = __commonJS({
  "node_modules/urijs/src/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map2(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string2, fn) {
        var parts = string2.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string2 = parts[1];
        }
        string2 = string2.replace(regexSeparators, ".");
        var labels = string2.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string2) {
        var output = [], counter = 0, length = string2.length, value, extra;
        while (counter < length) {
          value = string2.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map2(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string2) {
          return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/urijs/src/IPv6.js
var require_IPv6 = __commonJS({
  "node_modules/urijs/src/IPv6.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.IPv6 = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _IPv6 = root && root.IPv6;
      function bestPresentation(address) {
        var _address = address.toLowerCase();
        var segments = _address.split(":");
        var length = segments.length;
        var total = 8;
        if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
          segments.shift();
          segments.shift();
        } else if (segments[0] === "" && segments[1] === "") {
          segments.shift();
        } else if (segments[length - 1] === "" && segments[length - 2] === "") {
          segments.pop();
        }
        length = segments.length;
        if (segments[length - 1].indexOf(".") !== -1) {
          total = 7;
        }
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (segments[pos] === "") {
            break;
          }
        }
        if (pos < total) {
          segments.splice(pos, 1, "0000");
          while (segments.length < total) {
            segments.splice(pos, 0, "0000");
          }
        }
        var _segments;
        for (var i = 0; i < total; i++) {
          _segments = segments[i].split("");
          for (var j = 0; j < 3; j++) {
            if (_segments[0] === "0" && _segments.length > 1) {
              _segments.splice(0, 1);
            } else {
              break;
            }
          }
          segments[i] = _segments.join("");
        }
        var best = -1;
        var _best = 0;
        var _current = 0;
        var current = -1;
        var inzeroes = false;
        for (i = 0; i < total; i++) {
          if (inzeroes) {
            if (segments[i] === "0") {
              _current += 1;
            } else {
              inzeroes = false;
              if (_current > _best) {
                best = current;
                _best = _current;
              }
            }
          } else {
            if (segments[i] === "0") {
              inzeroes = true;
              current = i;
              _current = 1;
            }
          }
        }
        if (_current > _best) {
          best = current;
          _best = _current;
        }
        if (_best > 1) {
          segments.splice(best, _best, "");
        }
        length = segments.length;
        var result = "";
        if (segments[0] === "") {
          result = ":";
        }
        for (i = 0; i < length; i++) {
          result += segments[i];
          if (i === length - 1) {
            break;
          }
          result += ":";
        }
        if (segments[length - 1] === "") {
          result += ":";
        }
        return result;
      }
      function noConflict() {
        if (root.IPv6 === this) {
          root.IPv6 = _IPv6;
        }
        return this;
      }
      return {
        best: bestPresentation,
        noConflict
      };
    });
  }
});

// node_modules/urijs/src/SecondLevelDomains.js
var require_SecondLevelDomains = __commonJS({
  "node_modules/urijs/src/SecondLevelDomains.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.SecondLevelDomains = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _SecondLevelDomains = root && root.SecondLevelDomains;
      var SLD = {
        // list of known Second Level Domains
        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
        // ----
        // publicsuffix.org is more current and actually used by a couple of browsers internally.
        // downside is it also contains domains like "dyndns.org" - which is fine for the security
        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
        // ----
        list: {
          "ac": " com gov mil net org ",
          "ae": " ac co gov mil name net org pro sch ",
          "af": " com edu gov net org ",
          "al": " com edu gov mil net org ",
          "ao": " co ed gv it og pb ",
          "ar": " com edu gob gov int mil net org tur ",
          "at": " ac co gv or ",
          "au": " asn com csiro edu gov id net org ",
          "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          "bb": " biz co com edu gov info net org store tv ",
          "bh": " biz cc com edu gov info net org ",
          "bn": " com edu gov net org ",
          "bo": " com edu gob gov int mil net org tv ",
          "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          "bs": " com edu gov net org ",
          "bz": " du et om ov rg ",
          "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          "ck": " biz co edu gen gov info net org ",
          "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          "co": " com edu gov mil net nom org ",
          "cr": " ac c co ed fi go or sa ",
          "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          "do": " art com edu gob gov mil net org sld web ",
          "dz": " art asso com edu gov net org pol ",
          "ec": " com edu fin gov info med mil net org pro ",
          "eg": " com edu eun gov mil name net org sci ",
          "er": " com edu gov ind mil net org rochest w ",
          "es": " com edu gob nom org ",
          "et": " biz com edu gov info name net org ",
          "fj": " ac biz com info mil name net org pro ",
          "fk": " ac co gov net nom org ",
          "fr": " asso com f gouv nom prd presse tm ",
          "gg": " co net org ",
          "gh": " com edu gov mil org ",
          "gn": " ac com gov net org ",
          "gr": " com edu gov mil net org ",
          "gt": " com edu gob ind mil net org ",
          "gu": " com edu gov net org ",
          "hk": " com edu gov idv net org ",
          "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          "id": " ac co go mil net or sch web ",
          "il": " ac co gov idf k12 muni net org ",
          "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
          "iq": " com edu gov i mil net org ",
          "ir": " ac co dnssec gov i id net org sch ",
          "it": " edu gov ",
          "je": " co net org ",
          "jo": " com edu gov mil name net org sch ",
          "jp": " ac ad co ed go gr lg ne or ",
          "ke": " ac co go info me mobi ne or sc ",
          "kh": " com edu gov mil net org per ",
          "ki": " biz com de edu gov info mob net org tel ",
          "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          "kn": " edu gov net org ",
          "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          "kw": " com edu gov net org ",
          "ky": " com edu gov net org ",
          "kz": " com edu gov mil net org ",
          "lb": " com edu gov net org ",
          "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          "lr": " com edu gov net org ",
          "lv": " asn com conf edu gov id mil net org ",
          "ly": " com edu gov id med net org plc sch ",
          "ma": " ac co gov m net org press ",
          "mc": " asso tm ",
          "me": " ac co edu gov its net org priv ",
          "mg": " com edu gov mil nom org prd tm ",
          "mk": " com edu gov inf name net org pro ",
          "ml": " com edu gov net org presse ",
          "mn": " edu gov org ",
          "mo": " com edu gov net org ",
          "mt": " com edu gov net org ",
          "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
          "mw": " ac co com coop edu gov int museum net org ",
          "mx": " com edu gob net org ",
          "my": " com edu gov mil name net org sch ",
          "nf": " arts com firm info net other per rec store web ",
          "ng": " biz com edu gov mil mobi name net org sch ",
          "ni": " ac co com edu gob mil net nom org ",
          "np": " com edu gov mil net org ",
          "nr": " biz com edu gov info net org ",
          "om": " ac biz co com edu gov med mil museum net org pro sch ",
          "pe": " com edu gob mil net nom org sld ",
          "ph": " com edu gov i mil net ngo org ",
          "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
          "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          "pr": " ac biz com edu est gov info isla name net org pro prof ",
          "ps": " com edu gov net org plo sec ",
          "pw": " belau co ed go ne or ",
          "ro": " arts com firm info nom nt org rec store tm www ",
          "rs": " ac co edu gov in org ",
          "sb": " com edu gov net org ",
          "sc": " com edu gov net org ",
          "sh": " co com edu gov net nom org ",
          "sl": " com edu gov net org ",
          "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
          "sv": " com edu gob org red ",
          "sz": " ac co org ",
          "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          "tw": " club com ebiz edu game gov idv mil net org ",
          "mu": " ac co com gov net or org ",
          "mz": " ac co edu gov org ",
          "na": " co com ",
          "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          "pa": " abo ac com edu gob ing med net nom org sld ",
          "pt": " com edu gov int net nome org publ ",
          "py": " com edu gov mil net org ",
          "qa": " com edu gov mil net org ",
          "re": " asso com nom ",
          "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          "rw": " ac co com edu gouv gov int mil net ",
          "sa": " com edu gov med net org pub sch ",
          "sd": " com edu gov info med net org tv ",
          "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          "sg": " com edu gov idn net org per ",
          "sn": " art com edu gouv org perso univ ",
          "sy": " com edu gov mil net news org ",
          "th": " ac co go in mi net or ",
          "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
          "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          "tz": " ac co go ne or ",
          "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          "ug": " ac co go ne or org sc ",
          "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          "us": " dni fed isa kids nsn ",
          "uy": " com edu gub mil net org ",
          "ve": " co com edu gob info mil net org web ",
          "vi": " co com k12 net org ",
          "vn": " ac biz com edu gov health info int name net org pro ",
          "ye": " co com gov ltd me net org plc ",
          "yu": " ac co edu gov org ",
          "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          "zm": " ac co com edu gov net org sch ",
          // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
          "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          "net": "gb jp se uk ",
          "org": "ae",
          "de": "com "
        },
        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
        // in both performance and memory footprint. No initialization required.
        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
        // Following methods use lastIndexOf() rather than array.split() in order
        // to avoid any memory allocations.
        has: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
        },
        is: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset >= 0) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
        },
        get: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return null;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return null;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return null;
          }
          if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
            return null;
          }
          return domain.slice(sldOffset + 1);
        },
        noConflict: function() {
          if (root.SecondLevelDomains === this) {
            root.SecondLevelDomains = _SecondLevelDomains;
          }
          return this;
        }
      };
      return SLD;
    });
  }
});

// node_modules/urijs/src/URI.js
var require_URI = __commonJS({
  "node_modules/urijs/src/URI.js"(exports, module) {
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory(require_punycode(), require_IPv6(), require_SecondLevelDomains());
      } else if (typeof define === "function" && define.amd) {
        define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory);
      } else {
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
      }
    })(exports, function(punycode, IPv6, SLD, root) {
      "use strict";
      var _URI = root && root.URI;
      function URI(url, base) {
        var _urlSupplied = arguments.length >= 1;
        var _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI)) {
          if (_urlSupplied) {
            if (_baseSupplied) {
              return new URI(url, base);
            }
            return new URI(url);
          }
          return new URI();
        }
        if (url === void 0) {
          if (_urlSupplied) {
            throw new TypeError("undefined is not a valid argument for URI");
          }
          if (typeof location !== "undefined") {
            url = location.href + "";
          } else {
            url = "";
          }
        }
        if (url === null) {
          if (_urlSupplied) {
            throw new TypeError("null is not a valid argument for URI");
          }
        }
        this.href(url);
        if (base !== void 0) {
          return this.absoluteTo(base);
        }
        return this;
      }
      function isInteger(value) {
        return /^[0-9]+$/.test(value);
      }
      URI.version = "1.19.11";
      var p = URI.prototype;
      var hasOwn = Object.prototype.hasOwnProperty;
      function escapeRegEx(string2) {
        return string2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function getType(value) {
        if (value === void 0) {
          return "Undefined";
        }
        return String(Object.prototype.toString.call(value)).slice(8, -1);
      }
      function isArray(obj) {
        return getType(obj) === "Array";
      }
      function filterArrayValues(data, value) {
        var lookup = {};
        var i, length;
        if (getType(value) === "RegExp") {
          lookup = null;
        } else if (isArray(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            lookup[value[i]] = true;
          }
        } else {
          lookup[value] = true;
        }
        for (i = 0, length = data.length; i < length; i++) {
          var _match = lookup && lookup[data[i]] !== void 0 || !lookup && value.test(data[i]);
          if (_match) {
            data.splice(i, 1);
            length--;
            i--;
          }
        }
        return data;
      }
      function arrayContains(list, value) {
        var i, length;
        if (isArray(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            if (!arrayContains(list, value[i])) {
              return false;
            }
          }
          return true;
        }
        var _type = getType(value);
        for (i = 0, length = list.length; i < length; i++) {
          if (_type === "RegExp") {
            if (typeof list[i] === "string" && list[i].match(value)) {
              return true;
            }
          } else if (list[i] === value) {
            return true;
          }
        }
        return false;
      }
      function arraysEqual(one, two) {
        if (!isArray(one) || !isArray(two)) {
          return false;
        }
        if (one.length !== two.length) {
          return false;
        }
        one.sort();
        two.sort();
        for (var i = 0, l = one.length; i < l; i++) {
          if (one[i] !== two[i]) {
            return false;
          }
        }
        return true;
      }
      function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
      }
      URI._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          // state
          preventInvalidHostname: URI.preventInvalidHostname,
          duplicateQueryParameters: URI.duplicateQueryParameters,
          escapeQuerySpace: URI.escapeQuerySpace
        };
      };
      URI.preventInvalidHostname = false;
      URI.duplicateQueryParameters = false;
      URI.escapeQuerySpace = true;
      URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
      URI.idn_expression = /[^a-z0-9\._-]/i;
      URI.punycode_expression = /(xn--)/i;
      URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
      URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?Â«Â»ââââ]))/ig;
      URI.findUri = {
        // valid "scheme://" or "www."
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        // everything up to the next whitespace
        end: /[\s\r\n]|$/,
        // trim trailing punctuation captured by end RegExp
        trim: /[`!()\[\]{};:'".,<>?Â«Â»âââââ]+$/,
        // balanced parens inclusion (), [], {}, <>
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      };
      URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
      URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      };
      URI.hostProtocols = [
        "http",
        "https"
      ];
      URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
      URI.domAttributes = {
        "a": "href",
        "blockquote": "cite",
        "link": "href",
        "base": "href",
        "script": "src",
        "form": "action",
        "img": "src",
        "area": "href",
        "iframe": "src",
        "embed": "src",
        "source": "src",
        "track": "src",
        "input": "src",
        // but only if type="image"
        "audio": "src",
        "video": "src"
      };
      URI.getDomAttribute = function(node) {
        if (!node || !node.nodeName) {
          return void 0;
        }
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "input" && node.type !== "image") {
          return void 0;
        }
        return URI.domAttributes[nodeName];
      };
      function escapeForDumbFirefox36(value) {
        return escape(value);
      }
      function strictEncodeURIComponent(string2) {
        return encodeURIComponent(string2).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
      }
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
      URI.iso8859 = function() {
        URI.encode = escape;
        URI.decode = unescape;
      };
      URI.unicode = function() {
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
      };
      URI.characters = {
        pathname: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              // -._~!'()*
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              // gen-delims
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              // sub-delims
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
          // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
          // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
          // note that the colon character is not featured in the encoding map; this is because URI.js
          // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
          // should not appear unencoded in a segment itself.
          // See also the note above about RFC3986 and capitalalized hex digits.
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          // These characters are the characters called out by RFC2141 as "reserved" characters that
          // should never appear in a URN, plus the colon character (see note above).
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      };
      URI.encodeQuery = function(string2, escapeQuerySpace) {
        var escaped = URI.encode(string2 + "");
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
      };
      URI.decodeQuery = function(string2, escapeQuerySpace) {
        string2 += "";
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        try {
          return URI.decode(escapeQuerySpace ? string2.replace(/\+/g, "%20") : string2);
        } catch (e) {
          return string2;
        }
      };
      var _parts = { "encode": "encode", "decode": "decode" };
      var _part;
      var generateAccessor = function(_group, _part2) {
        return function(string2) {
          try {
            return URI[_part2](string2 + "").replace(URI.characters[_group][_part2].expression, function(c) {
              return URI.characters[_group][_part2].map[c];
            });
          } catch (e) {
            return string2;
          }
        };
      };
      for (_part in _parts) {
        URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
        URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
      }
      var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string2) {
          var actualCodingFunc;
          if (!_innerCodingFuncName) {
            actualCodingFunc = URI[_codingFuncName];
          } else {
            actualCodingFunc = function(string3) {
              return URI[_codingFuncName](URI[_innerCodingFuncName](string3));
            };
          }
          var segments = (string2 + "").split(_sep);
          for (var i = 0, length = segments.length; i < length; i++) {
            segments[i] = actualCodingFunc(segments[i]);
          }
          return segments.join(_sep);
        };
      };
      URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
      URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
      URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
      URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
      URI.encodeReserved = generateAccessor("reserved", "encode");
      URI.parse = function(string2, parts) {
        var pos;
        if (!parts) {
          parts = {
            preventInvalidHostname: URI.preventInvalidHostname
          };
        }
        string2 = string2.replace(URI.leading_whitespace_expression, "");
        string2 = string2.replace(URI.ascii_tab_whitespace, "");
        pos = string2.indexOf("#");
        if (pos > -1) {
          parts.fragment = string2.substring(pos + 1) || null;
          string2 = string2.substring(0, pos);
        }
        pos = string2.indexOf("?");
        if (pos > -1) {
          parts.query = string2.substring(pos + 1) || null;
          string2 = string2.substring(0, pos);
        }
        string2 = string2.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
        string2 = string2.replace(/^[/\\]{2,}/i, "//");
        if (string2.substring(0, 2) === "//") {
          parts.protocol = null;
          string2 = string2.substring(2);
          string2 = URI.parseAuthority(string2, parts);
        } else {
          pos = string2.indexOf(":");
          if (pos > -1) {
            parts.protocol = string2.substring(0, pos) || null;
            if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
              parts.protocol = void 0;
            } else if (string2.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
              string2 = string2.substring(pos + 3);
              string2 = URI.parseAuthority(string2, parts);
            } else {
              string2 = string2.substring(pos + 1);
              parts.urn = true;
            }
          }
        }
        parts.path = string2;
        return parts;
      };
      URI.parseHost = function(string2, parts) {
        if (!string2) {
          string2 = "";
        }
        string2 = string2.replace(/\\/g, "/");
        var pos = string2.indexOf("/");
        var bracketPos;
        var t;
        if (pos === -1) {
          pos = string2.length;
        }
        if (string2.charAt(0) === "[") {
          bracketPos = string2.indexOf("]");
          parts.hostname = string2.substring(1, bracketPos) || null;
          parts.port = string2.substring(bracketPos + 2, pos) || null;
          if (parts.port === "/") {
            parts.port = null;
          }
        } else {
          var firstColon = string2.indexOf(":");
          var firstSlash = string2.indexOf("/");
          var nextColon = string2.indexOf(":", firstColon + 1);
          if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
            parts.hostname = string2.substring(0, pos) || null;
            parts.port = null;
          } else {
            t = string2.substring(0, pos).split(":");
            parts.hostname = t[0] || null;
            parts.port = t[1] || null;
          }
        }
        if (parts.hostname && string2.substring(pos).charAt(0) !== "/") {
          pos++;
          string2 = "/" + string2;
        }
        if (parts.preventInvalidHostname) {
          URI.ensureValidHostname(parts.hostname, parts.protocol);
        }
        if (parts.port) {
          URI.ensureValidPort(parts.port);
        }
        return string2.substring(pos) || "/";
      };
      URI.parseAuthority = function(string2, parts) {
        string2 = URI.parseUserinfo(string2, parts);
        return URI.parseHost(string2, parts);
      };
      URI.parseUserinfo = function(string2, parts) {
        var _string = string2;
        var firstBackSlash = string2.indexOf("\\");
        if (firstBackSlash !== -1) {
          string2 = string2.replace(/\\/g, "/");
        }
        var firstSlash = string2.indexOf("/");
        var pos = string2.lastIndexOf("@", firstSlash > -1 ? firstSlash : string2.length - 1);
        var t;
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
          t = string2.substring(0, pos).split(":");
          parts.username = t[0] ? URI.decode(t[0]) : null;
          t.shift();
          parts.password = t[0] ? URI.decode(t.join(":")) : null;
          string2 = _string.substring(pos + 1);
        } else {
          parts.username = null;
          parts.password = null;
        }
        return string2;
      };
      URI.parseQuery = function(string2, escapeQuerySpace) {
        if (!string2) {
          return {};
        }
        string2 = string2.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
        if (!string2) {
          return {};
        }
        var items = {};
        var splits = string2.split("&");
        var length = splits.length;
        var v, name, value;
        for (var i = 0; i < length; i++) {
          v = splits[i].split("=");
          name = URI.decodeQuery(v.shift(), escapeQuerySpace);
          value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null;
          if (name === "__proto__") {
            continue;
          } else if (hasOwn.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
              items[name] = [items[name]];
            }
            items[name].push(value);
          } else {
            items[name] = value;
          }
        }
        return items;
      };
      URI.build = function(parts) {
        var t = "";
        var requireAbsolutePath = false;
        if (parts.protocol) {
          t += parts.protocol + ":";
        }
        if (!parts.urn && (t || parts.hostname)) {
          t += "//";
          requireAbsolutePath = true;
        }
        t += URI.buildAuthority(parts) || "";
        if (typeof parts.path === "string") {
          if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
            t += "/";
          }
          t += parts.path;
        }
        if (typeof parts.query === "string" && parts.query) {
          t += "?" + parts.query;
        }
        if (typeof parts.fragment === "string" && parts.fragment) {
          t += "#" + parts.fragment;
        }
        return t;
      };
      URI.buildHost = function(parts) {
        var t = "";
        if (!parts.hostname) {
          return "";
        } else if (URI.ip6_expression.test(parts.hostname)) {
          t += "[" + parts.hostname + "]";
        } else {
          t += parts.hostname;
        }
        if (parts.port) {
          t += ":" + parts.port;
        }
        return t;
      };
      URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
      };
      URI.buildUserinfo = function(parts) {
        var t = "";
        if (parts.username) {
          t += URI.encode(parts.username);
        }
        if (parts.password) {
          t += ":" + URI.encode(parts.password);
        }
        if (t) {
          t += "@";
        }
        return t;
      };
      URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var t = "";
        var unique, key, i, length;
        for (key in data) {
          if (key === "__proto__") {
            continue;
          } else if (hasOwn.call(data, key)) {
            if (isArray(data[key])) {
              unique = {};
              for (i = 0, length = data[key].length; i < length; i++) {
                if (data[key][i] !== void 0 && unique[data[key][i] + ""] === void 0) {
                  t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                  if (duplicateQueryParameters !== true) {
                    unique[data[key][i] + ""] = true;
                  }
                }
              }
            } else if (data[key] !== void 0) {
              t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
            }
          }
        }
        return t.substring(1);
      };
      URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
      };
      URI.addQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.addQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (data[name] === void 0) {
            data[name] = value;
            return;
          } else if (typeof data[name] === "string") {
            data[name] = [data[name]];
          }
          if (!isArray(value)) {
            value = [value];
          }
          data[name] = (data[name] || []).concat(value);
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
      };
      URI.setQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.setQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          data[name] = value === void 0 ? null : value;
        } else {
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
        }
      };
      URI.removeQuery = function(data, name, value) {
        var i, length, key;
        if (isArray(name)) {
          for (i = 0, length = name.length; i < length; i++) {
            data[name[i]] = void 0;
          }
        } else if (getType(name) === "RegExp") {
          for (key in data) {
            if (name.test(key)) {
              data[key] = void 0;
            }
          }
        } else if (typeof name === "object") {
          for (key in name) {
            if (hasOwn.call(name, key)) {
              URI.removeQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (value !== void 0) {
            if (getType(value) === "RegExp") {
              if (!isArray(data[name]) && value.test(data[name])) {
                data[name] = void 0;
              } else {
                data[name] = filterArrayValues(data[name], value);
              }
            } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
              data[name] = void 0;
            } else if (isArray(data[name])) {
              data[name] = filterArrayValues(data[name], value);
            }
          } else {
            data[name] = void 0;
          }
        } else {
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        }
      };
      URI.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;
          case "RegExp":
            for (var key in data) {
              if (hasOwn.call(data, key)) {
                if (name.test(key) && (value === void 0 || URI.hasQuery(data, key, value))) {
                  return true;
                }
              }
            }
            return false;
          case "Object":
            for (var _key in name) {
              if (hasOwn.call(name, _key)) {
                if (!URI.hasQuery(data, _key, name[_key])) {
                  return false;
                }
              }
            }
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;
          case "Boolean":
            var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
            return value === _booly;
          case "Function":
            return !!value(data[name], name, data);
          case "Array":
            if (!isArray(data[name])) {
              return false;
            }
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);
          case "RegExp":
            if (!isArray(data[name])) {
              return Boolean(data[name] && data[name].match(value));
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          case "Number":
            value = String(value);
          case "String":
            if (!isArray(data[name])) {
              return data[name] === value;
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      };
      URI.joinPaths = function() {
        var input = [];
        var segments = [];
        var nonEmptySegments = 0;
        for (var i = 0; i < arguments.length; i++) {
          var url = new URI(arguments[i]);
          input.push(url);
          var _segments = url.segment();
          for (var s = 0; s < _segments.length; s++) {
            if (typeof _segments[s] === "string") {
              segments.push(_segments[s]);
            }
            if (_segments[s]) {
              nonEmptySegments++;
            }
          }
        }
        if (!segments.length || !nonEmptySegments) {
          return new URI("");
        }
        var uri = new URI("").segment(segments);
        if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
          uri.path("/" + uri.path());
        }
        return uri.normalize();
      };
      URI.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length);
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
          }
        }
        if (pos < 1) {
          return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
        }
        if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
          pos = one.substring(0, pos).lastIndexOf("/");
        }
        return one.substring(0, pos + 1);
      };
      URI.withinString = function(string2, callback, options) {
        options || (options = {});
        var _start = options.start || URI.findUri.start;
        var _end = options.end || URI.findUri.end;
        var _trim = options.trim || URI.findUri.trim;
        var _parens = options.parens || URI.findUri.parens;
        var _attributeOpen = /[a-z0-9-]=["']?$/i;
        _start.lastIndex = 0;
        while (true) {
          var match = _start.exec(string2);
          if (!match) {
            break;
          }
          var start = match.index;
          if (options.ignoreHtml) {
            var attributeOpen = string2.slice(Math.max(start - 3, 0), start);
            if (attributeOpen && _attributeOpen.test(attributeOpen)) {
              continue;
            }
          }
          var end = start + string2.slice(start).search(_end);
          var slice = string2.slice(start, end);
          var parensEnd = -1;
          while (true) {
            var parensMatch = _parens.exec(slice);
            if (!parensMatch) {
              break;
            }
            var parensMatchEnd = parensMatch.index + parensMatch[0].length;
            parensEnd = Math.max(parensEnd, parensMatchEnd);
          }
          if (parensEnd > -1) {
            slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
          } else {
            slice = slice.replace(_trim, "");
          }
          if (slice.length <= match[0].length) {
            continue;
          }
          if (options.ignore && options.ignore.test(slice)) {
            continue;
          }
          end = start + slice.length;
          var result = callback(slice, start, end, string2);
          if (result === void 0) {
            _start.lastIndex = end;
            continue;
          }
          result = String(result);
          string2 = string2.slice(0, start) + result + string2.slice(end);
          _start.lastIndex = start + result.length;
        }
        _start.lastIndex = 0;
        return string2;
      };
      URI.ensureValidHostname = function(v, protocol) {
        var hasHostname = !!v;
        var hasProtocol = !!protocol;
        var rejectEmptyHostname = false;
        if (hasProtocol) {
          rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
        }
        if (rejectEmptyHostname && !hasHostname) {
          throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
        } else if (v && v.match(URI.invalid_hostname_characters)) {
          if (!punycode) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          }
          if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
          }
        }
      };
      URI.ensureValidPort = function(v) {
        if (!v) {
          return;
        }
        var port = Number(v);
        if (isInteger(port) && port > 0 && port < 65536) {
          return;
        }
        throw new TypeError('Port "' + v + '" is not a valid port');
      };
      URI.noConflict = function(removeAll) {
        if (removeAll) {
          var unconflicted = {
            URI: this.noConflict()
          };
          if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
            unconflicted.URITemplate = root.URITemplate.noConflict();
          }
          if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
            unconflicted.IPv6 = root.IPv6.noConflict();
          }
          if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
            unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
          }
          return unconflicted;
        } else if (root.URI === this) {
          root.URI = _URI;
        }
        return this;
      };
      p.build = function(deferBuild) {
        if (deferBuild === true) {
          this._deferred_build = true;
        } else if (deferBuild === void 0 || this._deferred_build) {
          this._string = URI.build(this._parts);
          this._deferred_build = false;
        }
        return this;
      };
      p.clone = function() {
        return new URI(this);
      };
      p.valueOf = p.toString = function() {
        return this.build(false)._string;
      };
      function generateSimpleAccessor(_part2) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            this._parts[_part2] = v || null;
            this.build(!build);
            return this;
          }
        };
      }
      function generatePrefixAccessor(_part2, _key) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            if (v !== null) {
              v = v + "";
              if (v.charAt(0) === _key) {
                v = v.substring(1);
              }
            }
            this._parts[_part2] = v;
            this.build(!build);
            return this;
          }
        };
      }
      p.protocol = generateSimpleAccessor("protocol");
      p.username = generateSimpleAccessor("username");
      p.password = generateSimpleAccessor("password");
      p.hostname = generateSimpleAccessor("hostname");
      p.port = generateSimpleAccessor("port");
      p.query = generatePrefixAccessor("query", "?");
      p.fragment = generatePrefixAccessor("fragment", "#");
      p.search = function(v, build) {
        var t = this.query(v, build);
        return typeof t === "string" && t.length ? "?" + t : t;
      };
      p.hash = function(v, build) {
        var t = this.fragment(v, build);
        return typeof t === "string" && t.length ? "#" + t : t;
      };
      p.pathname = function(v, build) {
        if (v === void 0 || v === true) {
          var res = this._parts.path || (this._parts.hostname ? "/" : "");
          return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
        } else {
          if (this._parts.urn) {
            this._parts.path = v ? URI.recodeUrnPath(v) : "";
          } else {
            this._parts.path = v ? URI.recodePath(v) : "/";
          }
          this.build(!build);
          return this;
        }
      };
      p.path = p.pathname;
      p.href = function(href, build) {
        var key;
        if (href === void 0) {
          return this.toString();
        }
        this._string = "";
        this._parts = URI._parts();
        var _URI2 = href instanceof URI;
        var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
          var attribute = URI.getDomAttribute(href);
          href = href[attribute] || "";
          _object = false;
        }
        if (!_URI2 && _object && href.pathname !== void 0) {
          href = href.toString();
        }
        if (typeof href === "string" || href instanceof String) {
          this._parts = URI.parse(String(href), this._parts);
        } else if (_URI2 || _object) {
          var src = _URI2 ? href._parts : href;
          for (key in src) {
            if (key === "query") {
              continue;
            }
            if (hasOwn.call(this._parts, key)) {
              this._parts[key] = src[key];
            }
          }
          if (src.query) {
            this.query(src.query, false);
          }
        } else {
          throw new TypeError("invalid input");
        }
        this.build(!build);
        return this;
      };
      p.is = function(what) {
        var ip = false;
        var ip4 = false;
        var ip6 = false;
        var name = false;
        var sld = false;
        var idn = false;
        var punycode2 = false;
        var relative = !this._parts.urn;
        if (this._parts.hostname) {
          relative = false;
          ip4 = URI.ip4_expression.test(this._parts.hostname);
          ip6 = URI.ip6_expression.test(this._parts.hostname);
          ip = ip4 || ip6;
          name = !ip;
          sld = name && SLD && SLD.has(this._parts.hostname);
          idn = name && URI.idn_expression.test(this._parts.hostname);
          punycode2 = name && URI.punycode_expression.test(this._parts.hostname);
        }
        switch (what.toLowerCase()) {
          case "relative":
            return relative;
          case "absolute":
            return !relative;
          case "domain":
          case "name":
            return name;
          case "sld":
            return sld;
          case "ip":
            return ip;
          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;
          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;
          case "idn":
            return idn;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return punycode2;
        }
        return null;
      };
      var _protocol = p.protocol;
      var _port = p.port;
      var _hostname = p.hostname;
      p.protocol = function(v, build) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, "");
          if (!v.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
          }
        }
        return _protocol.call(this, v, build);
      };
      p.scheme = p.protocol;
      p.port = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          if (v === 0) {
            v = null;
          }
          if (v) {
            v += "";
            if (v.charAt(0) === ":") {
              v = v.substring(1);
            }
            URI.ensureValidPort(v);
          }
        }
        return _port.call(this, v, build);
      };
      p.hostname = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
          var res = URI.parseHost(v, x);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          v = x.hostname;
          if (this._parts.preventInvalidHostname) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
        }
        return _hostname.call(this, v, build);
      };
      p.origin = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var protocol = this.protocol();
          var authority = this.authority();
          if (!authority) {
            return "";
          }
          return (protocol ? protocol + "://" : "") + this.authority();
        } else {
          var origin = URI(v);
          this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
          return this;
        }
      };
      p.host = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildHost(this._parts) : "";
        } else {
          var res = URI.parseHost(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.authority = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        } else {
          var res = URI.parseAuthority(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.userinfo = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var t = URI.buildUserinfo(this._parts);
          return t ? t.substring(0, t.length - 1) : t;
        } else {
          if (v[v.length - 1] !== "@") {
            v += "@";
          }
          URI.parseUserinfo(v, this._parts);
          this.build(!build);
          return this;
        }
      };
      p.resource = function(v, build) {
        var parts;
        if (v === void 0) {
          return this.path() + this.search() + this.hash();
        }
        parts = URI.parse(v);
        this._parts.path = parts.path;
        this._parts.query = parts.query;
        this._parts.fragment = parts.fragment;
        this.build(!build);
        return this;
      };
      p.subdomain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var end = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, end) || "";
        } else {
          var e = this._parts.hostname.length - this.domain().length;
          var sub = this._parts.hostname.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(sub));
          if (v && v.charAt(v.length - 1) !== ".") {
            v += ".";
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          if (v) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
          this._parts.hostname = this._parts.hostname.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.domain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var t = this._parts.hostname.match(/\./g);
          if (t && t.length < 2) {
            return this._parts.hostname;
          }
          var end = this._parts.hostname.length - this.tld(build).length - 1;
          end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
          return this._parts.hostname.substring(end) || "";
        } else {
          if (!v) {
            throw new TypeError("cannot set domain empty");
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          URI.ensureValidHostname(v, this._parts.protocol);
          if (!this._parts.hostname || this.is("IP")) {
            this._parts.hostname = v;
          } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.tld = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var pos = this._parts.hostname.lastIndexOf(".");
          var tld = this._parts.hostname.substring(pos + 1);
          if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
          }
          return tld;
        } else {
          var replace;
          if (!v) {
            throw new TypeError("cannot set TLD empty");
          } else if (v.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v)) {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v);
            } else {
              throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
            }
          } else if (!this._parts.hostname || this.is("IP")) {
            throw new ReferenceError("cannot set TLD on non-domain host");
          } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.directory = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path && !this._parts.hostname) {
            return "";
          }
          if (this._parts.path === "/") {
            return "/";
          }
          var end = this._parts.path.length - this.filename().length - 1;
          var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
          return v ? URI.decodePath(res) : res;
        } else {
          var e = this._parts.path.length - this.filename().length;
          var directory = this._parts.path.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(directory));
          if (!this.is("relative")) {
            if (!v) {
              v = "/";
            }
            if (v.charAt(0) !== "/") {
              v = "/" + v;
            }
          }
          if (v && v.charAt(v.length - 1) !== "/") {
            v += "/";
          }
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.filename = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v !== "string") {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var pos = this._parts.path.lastIndexOf("/");
          var res = this._parts.path.substring(pos + 1);
          return v ? URI.decodePathSegment(res) : res;
        } else {
          var mutatedDirectory = false;
          if (v.charAt(0) === "/") {
            v = v.substring(1);
          }
          if (v.match(/\.?\//)) {
            mutatedDirectory = true;
          }
          var replace = new RegExp(escapeRegEx(this.filename()) + "$");
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          if (mutatedDirectory) {
            this.normalizePath(build);
          } else {
            this.build(!build);
          }
          return this;
        }
      };
      p.suffix = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var filename = this.filename();
          var pos = filename.lastIndexOf(".");
          var s, res;
          if (pos === -1) {
            return "";
          }
          s = filename.substring(pos + 1);
          res = /^[a-z0-9%]+$/i.test(s) ? s : "";
          return v ? URI.decodePathSegment(res) : res;
        } else {
          if (v.charAt(0) === ".") {
            v = v.substring(1);
          }
          var suffix = this.suffix();
          var replace;
          if (!suffix) {
            if (!v) {
              return this;
            }
            this._parts.path += "." + URI.recodePath(v);
          } else if (!v) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
          } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
          }
          if (replace) {
            v = URI.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.segment = function(segment, v, build) {
        var separator = this._parts.urn ? ":" : "/";
        var path = this.path();
        var absolute = path.substring(0, 1) === "/";
        var segments = path.split(separator);
        if (segment !== void 0 && typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (segment !== void 0 && typeof segment !== "number") {
          throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        }
        if (absolute) {
          segments.shift();
        }
        if (segment < 0) {
          segment = Math.max(segments.length + segment, 0);
        }
        if (v === void 0) {
          return segment === void 0 ? segments : segments[segment];
        } else if (segment === null || segments[segment] === void 0) {
          if (isArray(v)) {
            segments = [];
            for (var i = 0, l = v.length; i < l; i++) {
              if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
                continue;
              }
              if (segments.length && !segments[segments.length - 1].length) {
                segments.pop();
              }
              segments.push(trimSlashes(v[i]));
            }
          } else if (v || typeof v === "string") {
            v = trimSlashes(v);
            if (segments[segments.length - 1] === "") {
              segments[segments.length - 1] = v;
            } else {
              segments.push(v);
            }
          }
        } else {
          if (v) {
            segments[segment] = trimSlashes(v);
          } else {
            segments.splice(segment, 1);
          }
        }
        if (absolute) {
          segments.unshift("");
        }
        return this.path(segments.join(separator), build);
      };
      p.segmentCoded = function(segment, v, build) {
        var segments, i, l;
        if (typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (v === void 0) {
          segments = this.segment(segment, v, build);
          if (!isArray(segments)) {
            segments = segments !== void 0 ? URI.decode(segments) : void 0;
          } else {
            for (i = 0, l = segments.length; i < l; i++) {
              segments[i] = URI.decode(segments[i]);
            }
          }
          return segments;
        }
        if (!isArray(v)) {
          v = typeof v === "string" || v instanceof String ? URI.encode(v) : v;
        } else {
          for (i = 0, l = v.length; i < l; i++) {
            v[i] = URI.encode(v[i]);
          }
        }
        return this.segment(segment, v, build);
      };
      var q = p.query;
      p.query = function(v, build) {
        if (v === true) {
          return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        } else if (typeof v === "function") {
          var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          var result = v.call(this, data);
          this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else if (v !== void 0 && typeof v !== "string") {
          this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else {
          return q.call(this, v, build);
        }
      };
      p.setQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof name === "string" || name instanceof String) {
          data[name] = value !== void 0 ? value : null;
        } else if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              data[key] = name[key];
            }
          }
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.addQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.addQuery(data, name, value === void 0 ? null : value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.removeQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.removeQuery(data, name, value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.hasQuery = function(name, value, withinArray) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.hasQuery(data, name, value, withinArray);
      };
      p.setSearch = p.setQuery;
      p.addSearch = p.addQuery;
      p.removeSearch = p.removeQuery;
      p.hasSearch = p.hasQuery;
      p.normalize = function() {
        if (this._parts.urn) {
          return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        }
        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      };
      p.normalizeProtocol = function(build) {
        if (typeof this._parts.protocol === "string") {
          this._parts.protocol = this._parts.protocol.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizeHostname = function(build) {
        if (this._parts.hostname) {
          if (this.is("IDN") && punycode) {
            this._parts.hostname = punycode.toASCII(this._parts.hostname);
          } else if (this.is("IPv6") && IPv6) {
            this._parts.hostname = IPv6.best(this._parts.hostname);
          }
          this._parts.hostname = this._parts.hostname.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizePort = function(build) {
        if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
          this._parts.port = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizePath = function(build) {
        var _path = this._parts.path;
        if (!_path) {
          return this;
        }
        if (this._parts.urn) {
          this._parts.path = URI.recodeUrnPath(this._parts.path);
          this.build(!build);
          return this;
        }
        if (this._parts.path === "/") {
          return this;
        }
        _path = URI.recodePath(_path);
        var _was_relative;
        var _leadingParents = "";
        var _parent, _pos;
        if (_path.charAt(0) !== "/") {
          _was_relative = true;
          _path = "/" + _path;
        }
        if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
          _path += "/";
        }
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
        if (_was_relative) {
          _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
          if (_leadingParents) {
            _leadingParents = _leadingParents[0];
          }
        }
        while (true) {
          _parent = _path.search(/\/\.\.(\/|$)/);
          if (_parent === -1) {
            break;
          } else if (_parent === 0) {
            _path = _path.substring(3);
            continue;
          }
          _pos = _path.substring(0, _parent).lastIndexOf("/");
          if (_pos === -1) {
            _pos = _parent;
          }
          _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        if (_was_relative && this.is("relative")) {
          _path = _leadingParents + _path.substring(1);
        }
        this._parts.path = _path;
        this.build(!build);
        return this;
      };
      p.normalizePathname = p.normalizePath;
      p.normalizeQuery = function(build) {
        if (typeof this._parts.query === "string") {
          if (!this._parts.query.length) {
            this._parts.query = null;
          } else {
            this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
          }
          this.build(!build);
        }
        return this;
      };
      p.normalizeFragment = function(build) {
        if (!this._parts.fragment) {
          this._parts.fragment = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizeSearch = p.normalizeQuery;
      p.normalizeHash = p.normalizeFragment;
      p.iso8859 = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = escape;
        URI.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.unicode = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = strictEncodeURIComponent;
        URI.decode = unescape;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.readable = function() {
        var uri = this.clone();
        uri.username("").password("").normalize();
        var t = "";
        if (uri._parts.protocol) {
          t += uri._parts.protocol + "://";
        }
        if (uri._parts.hostname) {
          if (uri.is("punycode") && punycode) {
            t += punycode.toUnicode(uri._parts.hostname);
            if (uri._parts.port) {
              t += ":" + uri._parts.port;
            }
          } else {
            t += uri.host();
          }
        }
        if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
          t += "/";
        }
        t += uri.path(true);
        if (uri._parts.query) {
          var q2 = "";
          for (var i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
            var kv = (qp[i] || "").split("=");
            q2 += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            if (kv[1] !== void 0) {
              q2 += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            }
          }
          t += "?" + q2.substring(1);
        }
        t += URI.decodeQuery(uri.hash(), true);
        return t;
      };
      p.absoluteTo = function(base) {
        var resolved = this.clone();
        var properties = ["protocol", "username", "password", "hostname", "port"];
        var basedir, i, p2;
        if (this._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        if (!(base instanceof URI)) {
          base = new URI(base);
        }
        if (resolved._parts.protocol) {
          return resolved;
        } else {
          resolved._parts.protocol = base._parts.protocol;
        }
        if (this._parts.hostname) {
          return resolved;
        }
        for (i = 0; p2 = properties[i]; i++) {
          resolved._parts[p2] = base._parts[p2];
        }
        if (!resolved._parts.path) {
          resolved._parts.path = base._parts.path;
          if (!resolved._parts.query) {
            resolved._parts.query = base._parts.query;
          }
        } else {
          if (resolved._parts.path.substring(-2) === "..") {
            resolved._parts.path += "/";
          }
          if (resolved.path().charAt(0) !== "/") {
            basedir = base.directory();
            basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
            resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
            resolved.normalizePath();
          }
        }
        resolved.build();
        return resolved;
      };
      p.relativeTo = function(base) {
        var relative = this.clone().normalize();
        var relativeParts, baseParts, common, relativePath, basePath;
        if (relative._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        base = new URI(base).normalize();
        relativeParts = relative._parts;
        baseParts = base._parts;
        relativePath = relative.path();
        basePath = base.path();
        if (relativePath.charAt(0) !== "/") {
          throw new Error("URI is already relative");
        }
        if (basePath.charAt(0) !== "/") {
          throw new Error("Cannot calculate a URI relative to another relative URI");
        }
        if (relativeParts.protocol === baseParts.protocol) {
          relativeParts.protocol = null;
        }
        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
          return relative.build();
        }
        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
          return relative.build();
        }
        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
          relativeParts.hostname = null;
          relativeParts.port = null;
        } else {
          return relative.build();
        }
        if (relativePath === basePath) {
          relativeParts.path = "";
          return relative.build();
        }
        common = URI.commonPath(relativePath, basePath);
        if (!common) {
          return relative.build();
        }
        var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
        return relative.build();
      };
      p.equals = function(uri) {
        var one = this.clone();
        var two = new URI(uri);
        var one_map = {};
        var two_map = {};
        var checked = {};
        var one_query, two_query, key;
        one.normalize();
        two.normalize();
        if (one.toString() === two.toString()) {
          return true;
        }
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");
        if (one.toString() !== two.toString()) {
          return false;
        }
        if (one_query.length !== two_query.length) {
          return false;
        }
        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
        two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key in one_map) {
          if (hasOwn.call(one_map, key)) {
            if (!isArray(one_map[key])) {
              if (one_map[key] !== two_map[key]) {
                return false;
              }
            } else if (!arraysEqual(one_map[key], two_map[key])) {
              return false;
            }
            checked[key] = true;
          }
        }
        for (key in two_map) {
          if (hasOwn.call(two_map, key)) {
            if (!checked[key]) {
              return false;
            }
          }
        }
        return true;
      };
      p.preventInvalidHostname = function(v) {
        this._parts.preventInvalidHostname = !!v;
        return this;
      };
      p.duplicateQueryParameters = function(v) {
        this._parts.duplicateQueryParameters = !!v;
        return this;
      };
      p.escapeQuerySpace = function(v) {
        this._parts.escapeQuerySpace = !!v;
        return this;
      };
      return URI;
    });
  }
});

// node_modules/quicktype-core/dist/attributes/URIAttributes.js
var require_URIAttributes = __commonJS({
  "node_modules/quicktype-core/dist/attributes/URIAttributes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uriSchemaAttributesProducer = exports.uriInferenceAttributesProducer = exports.uriTypeAttributeKind = void 0;
    var collection_utils_1 = require_dist();
    var urijs_1 = __importDefault(require_URI());
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    var protocolsSchemaProperty = "qt-uri-protocols";
    var extensionsSchemaProperty = "qt-uri-extensions";
    var URITypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("uriAttributes");
      }
      get inIdentity() {
        return true;
      }
      combine(attrs) {
        const protocolSets = attrs.map((a) => a[0]);
        const extensionSets = attrs.map((a) => a[1]);
        return [(0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), protocolSets), (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), extensionSets)];
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema4, t, attrs) {
        if (t.kind !== "string" && t.kind !== "uri")
          return;
        const [protocols, extensions] = attrs;
        if (protocols.size > 0) {
          schema4[protocolsSchemaProperty] = Array.from(protocols).sort();
        }
        if (extensions.size > 0) {
          schema4[extensionsSchemaProperty] = Array.from(extensions).sort();
        }
      }
    };
    exports.uriTypeAttributeKind = new URITypeAttributeKind();
    var extensionRegex = /^.+(\.[^./\\]+)$/;
    function pathExtension(path) {
      const matches = extensionRegex.exec(path);
      if (matches === null)
        return void 0;
      return matches[1];
    }
    function uriInferenceAttributesProducer(s) {
      try {
        const uri = (0, urijs_1.default)(s);
        const extension = pathExtension(uri.path());
        const extensions = extension === void 0 ? [] : [extension.toLowerCase()];
        return exports.uriTypeAttributeKind.makeAttributes([/* @__PURE__ */ new Set([uri.protocol().toLowerCase()]), new Set(extensions)]);
      } catch (_a) {
        return TypeAttributes_1.emptyTypeAttributes;
      }
    }
    exports.uriInferenceAttributesProducer = uriInferenceAttributesProducer;
    function uriSchemaAttributesProducer(schema4, _ref, types) {
      if (!(typeof schema4 === "object"))
        return void 0;
      if (!types.has("string"))
        return void 0;
      let protocols;
      const maybeProtocols = schema4[protocolsSchemaProperty];
      if (maybeProtocols !== void 0) {
        protocols = new Set((0, Support_1.checkArray)(maybeProtocols, Support_1.checkString));
      } else {
        protocols = /* @__PURE__ */ new Set();
      }
      let extensions;
      const maybeExtensions = schema4[extensionsSchemaProperty];
      if (maybeExtensions !== void 0) {
        extensions = new Set((0, Support_1.checkArray)(maybeExtensions, Support_1.checkString));
      } else {
        extensions = /* @__PURE__ */ new Set();
      }
      if (protocols.size === 0 && extensions.size === 0)
        return void 0;
      return { forString: exports.uriTypeAttributeKind.makeAttributes([protocols, extensions]) };
    }
    exports.uriSchemaAttributesProducer = uriSchemaAttributesProducer;
  }
});

// node_modules/quicktype-core/dist/Graph.js
var require_Graph = __commonJS({
  "node_modules/quicktype-core/dist/Graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Graph = void 0;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    function countComponentGraphNodes(components) {
      if (components.length === 0)
        return 0;
      let largest = -1;
      let count = 0;
      for (const c of components) {
        (0, Support_1.assert)(c.length > 0, "Empty component not allowed");
        for (const v of c) {
          (0, Support_1.assert)(v >= 0, "Negative vertex index is invalid");
          largest = Math.max(largest, v);
          count += 1;
        }
      }
      (0, Support_1.assert)(largest + 1 === count, "Vertex indexes and count don't match up");
      return count;
    }
    function stronglyConnectedComponents(successors) {
      let index = 0;
      const stack = [];
      const numNodes = successors.length;
      const indexes = (0, Support_1.repeated)(numNodes, -1);
      const lowLinks = (0, Support_1.repeated)(numNodes, -1);
      const onStack = (0, Support_1.repeated)(numNodes, false);
      const sccs = [];
      function strongconnect(v) {
        indexes[v] = index;
        lowLinks[v] = index;
        index += 1;
        stack.push(v);
        onStack[v] = true;
        for (const w of successors[v]) {
          if (indexes[w] < 0) {
            strongconnect(w);
            lowLinks[v] = Math.min(lowLinks[v], lowLinks[w]);
          } else if (onStack[w]) {
            lowLinks[v] = Math.min(lowLinks[v], indexes[w]);
          }
        }
        if (lowLinks[v] === indexes[v]) {
          const scc = [];
          let w;
          do {
            w = (0, Support_1.defined)(stack.pop());
            onStack[w] = false;
            scc.push(w);
          } while (w !== v);
          sccs.push(scc);
        }
      }
      for (let v = 0; v < numNodes; v++) {
        if (indexes[v] < 0) {
          strongconnect(v);
        }
      }
      (0, Support_1.assert)(countComponentGraphNodes(sccs) === numNodes, "We didn't put all the nodes into SCCs");
      return sccs;
    }
    function buildComponentOfNodeMap(successors, components) {
      const numComponents = components.length;
      const numNodes = successors.length;
      (0, Support_1.assert)(numNodes === countComponentGraphNodes(components), "Components don't match up with graph");
      const componentOfNode = (0, Support_1.repeated)(numNodes, -1);
      for (let c = 0; c < numComponents; c++) {
        for (const n of components[c]) {
          (0, Support_1.assert)(componentOfNode[n] < 0, "We have a node that's in two components");
          componentOfNode[n] = c;
        }
      }
      return componentOfNode;
    }
    function buildMetaSuccessors(successors, components) {
      const numComponents = components.length;
      const componentOfNode = buildComponentOfNodeMap(successors, components);
      const componentAdded = (0, Support_1.repeated)(numComponents, false);
      const metaSuccessors = [];
      for (let c = 0; c < numComponents; c++) {
        const succ = [];
        for (const n of components[c]) {
          for (const s of successors[n]) {
            const ms = componentOfNode[s];
            if (ms === c || componentAdded[ms])
              continue;
            succ.push(ms);
            componentAdded[ms] = true;
          }
        }
        for (const ms of succ) {
          (0, Support_1.assert)(componentAdded[ms]);
          componentAdded[ms] = false;
        }
        metaSuccessors.push(succ);
      }
      return metaSuccessors;
    }
    function invertEdges(successors) {
      const numNodes = successors.length;
      const predecessors = (0, Support_1.repeatedCall)(numNodes, () => []);
      for (let s = 0; s < numNodes; s++) {
        for (const v of successors[s]) {
          predecessors[v].push(s);
        }
      }
      return predecessors;
    }
    function calculateInDegrees(successors) {
      const numNodes = successors.length;
      const inDegrees = (0, Support_1.repeated)(numNodes, 0);
      for (const s of successors) {
        for (const v of s) {
          inDegrees[v] += 1;
        }
      }
      return inDegrees;
    }
    function findRoots(successors) {
      const numNodes = successors.length;
      const inDegrees = calculateInDegrees(successors);
      const roots = [];
      for (let v = 0; v < numNodes; v++) {
        if (inDegrees[v] === 0) {
          roots.push(v);
        }
      }
      return roots;
    }
    var Graph = class _Graph {
      constructor(nodes, invertDirection, edges) {
        this._nodes = Array.from(nodes);
        this._indexByNode = new Map(this._nodes.map((n, i) => [n, i]));
        let edgesArray;
        if (Array.isArray(edges)) {
          edgesArray = edges;
        } else {
          edgesArray = this._nodes.map((n) => Array.from(edges(n)).map((s) => (0, Support_1.defined)(this._indexByNode.get(s))));
        }
        if (invertDirection) {
          edgesArray = invertEdges(edgesArray);
        }
        this._successors = edgesArray;
      }
      get size() {
        return this._nodes.length;
      }
      get nodes() {
        return this._nodes;
      }
      findRoots() {
        const roots = findRoots(this._successors);
        return new Set(roots.map((n) => this._nodes[n]));
      }
      // The subgraph starting at `root` must be acyclic.
      dfsTraversal(root, preOrder, process2) {
        const visited = (0, Support_1.repeated)(this.size, false);
        const visit3 = (v) => {
          if (visited[v])
            return;
          visited[v] = true;
          if (preOrder) {
            process2(this._nodes[v]);
          }
          for (const w of this._successors[v]) {
            visit3(w);
          }
          if (!preOrder) {
            process2(this._nodes[v]);
          }
        };
        visit3((0, Support_1.defined)(this._indexByNode.get(root)));
      }
      stronglyConnectedComponents() {
        const components = stronglyConnectedComponents(this._successors);
        const componentSuccessors = buildMetaSuccessors(this._successors, components);
        return new _Graph(components.map((ns) => (0, collection_utils_1.setMap)(ns, (n) => this._nodes[n])), false, componentSuccessors);
      }
      makeDot(includeNode, nodeLabel) {
        const lines = [];
        lines.push("digraph G {");
        lines.push("    ordering = out;");
        lines.push("");
        for (let i = 0; i < this.size; i++) {
          const n = this._nodes[i];
          if (!includeNode(n))
            continue;
          lines.push(`    node${i} [label="${nodeLabel(n)}"];`);
        }
        for (let i = 0; i < this.size; i++) {
          if (!includeNode(this._nodes[i]))
            continue;
          for (const j of this._successors[i]) {
            if (!includeNode(this._nodes[j]))
              continue;
            lines.push(`    node${i} -> node${j};`);
          }
        }
        lines.push("}");
        lines.push("");
        return lines.join("\n");
      }
    };
    exports.Graph = Graph;
  }
});

// node_modules/quicktype-core/dist/attributes/StringTypes.js
var require_StringTypes = __commonJS({
  "node_modules/quicktype-core/dist/attributes/StringTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inferTransformedStringTypeKindForString = exports.stringTypesTypeAttributeKind = exports.StringTypes = void 0;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    var TypeBuilder_1 = require_TypeBuilder();
    var TypeAttributes_1 = require_TypeAttributes();
    var StringTypes = class _StringTypes {
      static fromCase(s, count) {
        const caseMap = {};
        caseMap[s] = count;
        return new _StringTypes(/* @__PURE__ */ new Map([[s, count]]), /* @__PURE__ */ new Set());
      }
      static fromCases(cases) {
        const caseMap = {};
        for (const s of cases) {
          caseMap[s] = 1;
        }
        return new _StringTypes(new Map(cases.map((s) => [s, 1])), /* @__PURE__ */ new Set());
      }
      // undefined means no restrictions
      constructor(cases, transformations) {
        this.cases = cases;
        this.transformations = transformations;
        if (cases === void 0) {
          (0, Support_1.assert)(transformations.size === 0, "We can't have an unrestricted string that also allows transformations");
        }
      }
      get isRestricted() {
        return this.cases !== void 0;
      }
      union(othersArray, startIndex) {
        if (this.cases === void 0)
          return this;
        const cases = new Map(this.cases);
        const transformations = new Set(this.transformations);
        for (let i = startIndex; i < othersArray.length; i++) {
          const other = othersArray[i];
          if (other.cases === void 0)
            return other;
          (0, collection_utils_1.mapMergeWithInto)(cases, (x, y) => x + y, other.cases);
          (0, collection_utils_1.setUnionInto)(transformations, other.transformations);
        }
        return new _StringTypes(cases, transformations);
      }
      intersect(othersArray, startIndex) {
        let cases = this.cases;
        let transformations = this.transformations;
        for (let i = startIndex; i < othersArray.length; i++) {
          const other = othersArray[i];
          if (cases === void 0) {
            cases = (0, collection_utils_1.definedMap)(other.cases, (m) => new Map(m));
          } else if (other.cases !== void 0) {
            const thisCases = cases;
            const otherCases = other.cases;
            const intersects = (0, collection_utils_1.setIntersect)(thisCases.keys(), new Set(otherCases.keys()));
            const entries = intersects.size > 0 ? intersects.entries() : new Set(thisCases.keys()).entries();
            cases = (0, collection_utils_1.mapMap)(entries, (k) => {
              var _a;
              const thisValue = (0, Support_1.defined)(thisCases.get(k));
              const otherValue = (_a = otherCases.get(k)) !== null && _a !== void 0 ? _a : Math.min();
              return Math.min(thisValue, otherValue);
            });
          }
          transformations = (0, collection_utils_1.setIntersect)(transformations, other.transformations);
        }
        return new _StringTypes(cases, transformations);
      }
      applyStringTypeMapping(mapping) {
        if (!this.isRestricted)
          return this;
        const kinds = /* @__PURE__ */ new Set();
        for (const kind of this.transformations) {
          const mapped = (0, TypeBuilder_1.stringTypeMappingGet)(mapping, kind);
          if (mapped === "string")
            return _StringTypes.unrestricted;
          kinds.add(mapped);
        }
        return new _StringTypes(this.cases, new Set(kinds));
      }
      equals(other) {
        if (!(other instanceof _StringTypes))
          return false;
        return (0, collection_utils_1.areEqual)(this.cases, other.cases) && (0, collection_utils_1.areEqual)(this.transformations, other.transformations);
      }
      hashCode() {
        let h = (0, collection_utils_1.hashCodeOf)(this.cases);
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.transformations));
        return h;
      }
      toString() {
        const parts = [];
        const enumCases = this.cases;
        if (enumCases === void 0) {
          parts.push("unrestricted");
        } else {
          const firstKey = (0, collection_utils_1.iterableFirst)(enumCases.keys());
          if (firstKey === void 0) {
            parts.push("enum with no cases");
          } else {
            parts.push(`${enumCases.size.toString()} enums: ${firstKey} (${enumCases.get(firstKey)}), ...`);
          }
        }
        return parts.concat(Array.from(this.transformations)).join(",");
      }
    };
    exports.StringTypes = StringTypes;
    StringTypes.unrestricted = new StringTypes(void 0, /* @__PURE__ */ new Set());
    var StringTypesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("stringTypes");
      }
      get inIdentity() {
        return true;
      }
      requiresUniqueIdentity(st) {
        return st.cases !== void 0 && st.cases.size > 0;
      }
      combine(arr) {
        (0, Support_1.assert)(arr.length > 0);
        return arr[0].union(arr, 1);
      }
      intersect(arr) {
        (0, Support_1.assert)(arr.length > 0);
        return arr[0].intersect(arr, 1);
      }
      makeInferred(_) {
        return void 0;
      }
      stringify(st) {
        return st.toString();
      }
    };
    exports.stringTypesTypeAttributeKind = new StringTypesTypeAttributeKind();
    var INTEGER_STRING = /^(0|-?[1-9]\d*)$/;
    var MIN_INTEGER_STRING = 1 << 31;
    var MAX_INTEGER_STRING = -(MIN_INTEGER_STRING + 1);
    function isIntegerString(s) {
      if (INTEGER_STRING.exec(s) === null) {
        return false;
      }
      const i = parseInt(s, 10);
      return i >= MIN_INTEGER_STRING && i <= MAX_INTEGER_STRING;
    }
    var UUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
    function isUUID(s) {
      return UUID.exec(s) !== null;
    }
    var URI = /^(https?|ftp):\/\/[^{}]+$/;
    function isURI(s) {
      return URI.exec(s) !== null;
    }
    function inferTransformedStringTypeKindForString(s, recognizer) {
      if (s.length === 0 || !"0123456789-abcdefth".includes(s[0]))
        return void 0;
      if (recognizer.isDate(s)) {
        return "date";
      } else if (recognizer.isTime(s)) {
        return "time";
      } else if (recognizer.isDateTime(s)) {
        return "date-time";
      } else if (isIntegerString(s)) {
        return "integer-string";
      } else if (s === "false" || s === "true") {
        return "bool-string";
      } else if (isUUID(s)) {
        return "uuid";
      } else if (isURI(s)) {
        return "uri";
      }
      return void 0;
    }
    exports.inferTransformedStringTypeKindForString = inferTransformedStringTypeKindForString;
  }
});

// node_modules/quicktype-core/dist/TypeBuilder.js
var require_TypeBuilder = __commonJS({
  "node_modules/quicktype-core/dist/TypeBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeBuilder = exports.getNoStringTypeMapping = exports.stringTypeMappingGet = exports.provenanceTypeAttributeKind = void 0;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeGraph_1 = require_TypeGraph();
    var ProvenanceTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("provenance");
      }
      appliesToTypeKind(_kind) {
        return true;
      }
      combine(arr) {
        return (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), arr);
      }
      makeInferred(p) {
        return p;
      }
      stringify(p) {
        return Array.from(p).sort().map((i) => i.toString()).join(",");
      }
    };
    exports.provenanceTypeAttributeKind = new ProvenanceTypeAttributeKind();
    function stringTypeMappingGet(stm, kind) {
      const mapped = stm.get(kind);
      if (mapped === void 0)
        return "string";
      return mapped;
    }
    exports.stringTypeMappingGet = stringTypeMappingGet;
    var noStringTypeMapping;
    function getNoStringTypeMapping() {
      if (noStringTypeMapping === void 0) {
        noStringTypeMapping = new Map(Array.from(Type_1.transformedStringTypeKinds).map((k) => [k, k]));
      }
      return noStringTypeMapping;
    }
    exports.getNoStringTypeMapping = getNoStringTypeMapping;
    var TypeBuilder = class {
      constructor(typeGraphSerial, _stringTypeMapping, canonicalOrder, _allPropertiesOptional, _addProvenanceAttributes, inheritsProvenanceAttributes) {
        this._stringTypeMapping = _stringTypeMapping;
        this.canonicalOrder = canonicalOrder;
        this._allPropertiesOptional = _allPropertiesOptional;
        this._addProvenanceAttributes = _addProvenanceAttributes;
        this.topLevels = /* @__PURE__ */ new Map();
        this.types = [];
        this.typeAttributes = [];
        this._addedForwardingIntersection = false;
        this._typeForIdentity = new collection_utils_1.EqualityMap();
        (0, Support_1.assert)(!_addProvenanceAttributes || !inheritsProvenanceAttributes, "We can't both inherit as well as add provenance");
        this.typeGraph = new TypeGraph_1.TypeGraph(this, typeGraphSerial, _addProvenanceAttributes || inheritsProvenanceAttributes);
      }
      addTopLevel(name, tref) {
        (0, Support_1.assert)(!this.topLevels.has(name), "Trying to add top-level with existing name");
        (0, Support_1.assert)(this.types[(0, TypeGraph_1.typeRefIndex)(tref)] !== void 0, "Trying to add a top-level type that doesn't exist (yet?)");
        this.topLevels.set(name, tref);
      }
      reserveTypeRef() {
        const index = this.types.length;
        this.types.push(void 0);
        const tref = (0, TypeGraph_1.makeTypeRef)(this.typeGraph, index);
        const attributes = this._addProvenanceAttributes ? exports.provenanceTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([index])) : TypeAttributes_1.emptyTypeAttributes;
        this.typeAttributes.push(attributes);
        return tref;
      }
      assertTypeRefGraph(tref) {
        if (tref === void 0)
          return;
        (0, TypeGraph_1.assertTypeRefGraph)(tref, this.typeGraph);
      }
      assertTypeRefSetGraph(trefs) {
        if (trefs === void 0)
          return;
        trefs.forEach((tref) => this.assertTypeRefGraph(tref));
      }
      filterTypeAttributes(t, attributes) {
        const filtered = (0, collection_utils_1.mapFilter)(attributes, (_, k) => k.appliesToTypeKind(t.kind));
        if (attributes.size !== filtered.size) {
          this.setLostTypeAttributes();
        }
        return filtered;
      }
      commitType(tref, t) {
        this.assertTypeRefGraph(tref);
        const index = (0, TypeGraph_1.typeRefIndex)(tref);
        (0, Support_1.assert)(this.types[index] === void 0, "A type index was committed twice");
        this.types[index] = t;
        this.typeAttributes[index] = this.filterTypeAttributes(t, this.typeAttributes[index]);
      }
      addType(forwardingRef, creator, attributes) {
        if (forwardingRef !== void 0) {
          this.assertTypeRefGraph(forwardingRef);
          (0, Support_1.assert)(this.types[(0, TypeGraph_1.typeRefIndex)(forwardingRef)] === void 0);
        }
        const tref = forwardingRef !== null && forwardingRef !== void 0 ? forwardingRef : this.reserveTypeRef();
        if (attributes !== void 0) {
          const index = (0, TypeGraph_1.typeRefIndex)(tref);
          this.typeAttributes[index] = (0, TypeAttributes_1.combineTypeAttributes)("union", this.typeAttributes[index], attributes);
        }
        const t = creator(tref);
        this.commitType(tref, t);
        return tref;
      }
      typeAtIndex(index) {
        const maybeType = this.types[index];
        if (maybeType === void 0) {
          return (0, Support_1.panic)("Trying to deref an undefined type in a type builder");
        }
        return maybeType;
      }
      atIndex(index) {
        const t = this.typeAtIndex(index);
        const attribtues = this.typeAttributes[index];
        return [t, attribtues];
      }
      addAttributes(tref, attributes) {
        this.assertTypeRefGraph(tref);
        const index = (0, TypeGraph_1.typeRefIndex)(tref);
        const existingAttributes = this.typeAttributes[index];
        (0, Support_1.assert)((0, collection_utils_1.iterableEvery)(attributes, ([k, v]) => {
          if (!k.inIdentity)
            return true;
          const existing = existingAttributes.get(k);
          if (existing === void 0)
            return false;
          return (0, collection_utils_1.areEqual)(existing, v);
        }), "Can't add different identity type attributes to an existing type");
        const maybeType = this.types[index];
        if (maybeType !== void 0) {
          attributes = this.filterTypeAttributes(maybeType, attributes);
        }
        const nonIdentityAttributes = (0, collection_utils_1.mapFilter)(attributes, (_, k) => !k.inIdentity);
        this.typeAttributes[index] = (0, TypeAttributes_1.combineTypeAttributes)("union", existingAttributes, nonIdentityAttributes);
      }
      finish() {
        this.typeGraph.freeze(this.topLevels, this.types.map(Support_1.defined), this.typeAttributes);
        return this.typeGraph;
      }
      addForwardingIntersection(forwardingRef, tref) {
        this.assertTypeRefGraph(tref);
        this._addedForwardingIntersection = true;
        return this.addType(forwardingRef, (tr) => new Type_1.IntersectionType(tr, this.typeGraph, /* @__PURE__ */ new Set([tref])), void 0);
      }
      forwardIfNecessary(forwardingRef, tref) {
        if (tref === void 0)
          return void 0;
        if (forwardingRef === void 0)
          return tref;
        return this.addForwardingIntersection(forwardingRef, tref);
      }
      get didAddForwardingIntersection() {
        return this._addedForwardingIntersection;
      }
      registerTypeForIdentity(identity, tref) {
        if (identity === void 0)
          return;
        this._typeForIdentity.set(identity, tref);
      }
      makeIdentity(maker) {
        return maker();
      }
      getOrAddType(identityMaker, creator, attributes, forwardingRef) {
        const identity = this.makeIdentity(identityMaker);
        let maybeTypeRef;
        if (identity === void 0) {
          maybeTypeRef = void 0;
        } else {
          maybeTypeRef = this._typeForIdentity.get(identity);
        }
        if (maybeTypeRef !== void 0) {
          const result = this.forwardIfNecessary(forwardingRef, maybeTypeRef);
          if (attributes !== void 0) {
            this.addAttributes(result, (0, collection_utils_1.mapFilter)(attributes, (_, k) => !k.inIdentity));
          }
          return result;
        }
        const tref = this.addType(forwardingRef, creator, attributes);
        this.registerTypeForIdentity(identity, tref);
        return tref;
      }
      registerType(t) {
        this.registerTypeForIdentity(t.identity, t.typeRef);
      }
      getPrimitiveType(kind, maybeAttributes, forwardingRef) {
        const attributes = (0, collection_utils_1.withDefault)(maybeAttributes, TypeAttributes_1.emptyTypeAttributes);
        let stringTypes = kind === "string" ? void 0 : StringTypes_1.StringTypes.unrestricted;
        if ((0, Type_1.isPrimitiveStringTypeKind)(kind) && kind !== "string") {
          kind = stringTypeMappingGet(this._stringTypeMapping, kind);
        }
        if (kind === "string") {
          return this.getStringType(attributes, stringTypes, forwardingRef);
        }
        return this.getOrAddType(() => (0, Type_1.primitiveTypeIdentity)(kind, attributes), (tr) => new Type_1.PrimitiveType(tr, this.typeGraph, kind), attributes, forwardingRef);
      }
      getStringType(attributes, stringTypes, forwardingRef) {
        const existingStringTypes = (0, collection_utils_1.mapFind)(attributes, (_, k) => k === StringTypes_1.stringTypesTypeAttributeKind);
        (0, Support_1.assert)(stringTypes === void 0 !== (existingStringTypes === void 0), "Must instantiate string type with one enum case attribute");
        if (existingStringTypes === void 0) {
          attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, StringTypes_1.stringTypesTypeAttributeKind.makeAttributes((0, Support_1.defined)(stringTypes)));
        }
        return this.getOrAddType(() => (0, Type_1.primitiveTypeIdentity)("string", attributes), (tr) => new Type_1.PrimitiveType(tr, this.typeGraph, "string"), attributes, forwardingRef);
      }
      getEnumType(attributes, cases, forwardingRef) {
        return this.getOrAddType(() => (0, Type_1.enumTypeIdentity)(attributes, cases), (tr) => new Type_1.EnumType(tr, this.typeGraph, cases), attributes, forwardingRef);
      }
      makeClassProperty(tref, isOptional) {
        return new Type_1.ClassProperty(tref, this.typeGraph, isOptional);
      }
      getUniqueObjectType(attributes, properties, additionalProperties, forwardingRef) {
        this.assertTypeRefGraph(additionalProperties);
        properties = (0, collection_utils_1.definedMap)(properties, (p) => this.modifyPropertiesIfNecessary(p));
        return this.addType(forwardingRef, (tref) => new Type_1.ObjectType(tref, this.typeGraph, "object", true, properties, additionalProperties), attributes);
      }
      getUniqueMapType(forwardingRef) {
        return this.addType(forwardingRef, (tr) => new Type_1.MapType(tr, this.typeGraph, void 0), void 0);
      }
      getMapType(attributes, values, forwardingRef) {
        this.assertTypeRefGraph(values);
        return this.getOrAddType(() => (0, Type_1.mapTypeIdentify)(attributes, values), (tr) => new Type_1.MapType(tr, this.typeGraph, values), attributes, forwardingRef);
      }
      setObjectProperties(ref, properties, additionalProperties) {
        this.assertTypeRefGraph(additionalProperties);
        const type = (0, TypeGraph_1.derefTypeRef)(ref, this.typeGraph);
        if (!(type instanceof Type_1.ObjectType)) {
          return (0, Support_1.panic)("Tried to set properties of non-object type");
        }
        type.setProperties(this.modifyPropertiesIfNecessary(properties), additionalProperties);
        this.registerType(type);
      }
      getUniqueArrayType(forwardingRef) {
        return this.addType(forwardingRef, (tr) => new Type_1.ArrayType(tr, this.typeGraph, void 0), void 0);
      }
      getArrayType(attributes, items, forwardingRef) {
        this.assertTypeRefGraph(items);
        return this.getOrAddType(() => (0, Type_1.arrayTypeIdentity)(attributes, items), (tr) => new Type_1.ArrayType(tr, this.typeGraph, items), attributes, forwardingRef);
      }
      setArrayItems(ref, items) {
        this.assertTypeRefGraph(items);
        const type = (0, TypeGraph_1.derefTypeRef)(ref, this.typeGraph);
        if (!(type instanceof Type_1.ArrayType)) {
          return (0, Support_1.panic)("Tried to set items of non-array type");
        }
        type.setItems(items);
        this.registerType(type);
      }
      modifyPropertiesIfNecessary(properties) {
        properties.forEach((p) => this.assertTypeRefGraph(p.typeRef));
        if (this.canonicalOrder) {
          properties = (0, collection_utils_1.mapSortByKey)(properties);
        }
        if (this._allPropertiesOptional) {
          properties = (0, collection_utils_1.mapMap)(properties, (cp) => this.makeClassProperty(cp.typeRef, true));
        }
        return properties;
      }
      getClassType(attributes, properties, forwardingRef) {
        properties = this.modifyPropertiesIfNecessary(properties);
        return this.getOrAddType(() => (0, Type_1.classTypeIdentity)(attributes, properties), (tr) => new Type_1.ClassType(tr, this.typeGraph, false, properties), attributes, forwardingRef);
      }
      // FIXME: Maybe just distinguish between this and `getClassType`
      // via a flag?  That would make `ClassType.map` simpler.
      getUniqueClassType(attributes, isFixed, properties, forwardingRef) {
        properties = (0, collection_utils_1.definedMap)(properties, (p) => this.modifyPropertiesIfNecessary(p));
        return this.addType(forwardingRef, (tref) => new Type_1.ClassType(tref, this.typeGraph, isFixed, properties), attributes);
      }
      getUnionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.getOrAddType(() => (0, Type_1.unionTypeIdentity)(attributes, members), (tr) => new Type_1.UnionType(tr, this.typeGraph, members), attributes, forwardingRef);
      }
      // FIXME: why do we sometimes call this with defined members???
      getUniqueUnionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.addType(forwardingRef, (tref) => new Type_1.UnionType(tref, this.typeGraph, members), attributes);
      }
      getIntersectionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.getOrAddType(() => (0, Type_1.intersectionTypeIdentity)(attributes, members), (tr) => new Type_1.IntersectionType(tr, this.typeGraph, members), attributes, forwardingRef);
      }
      // FIXME: why do we sometimes call this with defined members???
      getUniqueIntersectionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.addType(forwardingRef, (tref) => new Type_1.IntersectionType(tref, this.typeGraph, members), attributes);
      }
      setSetOperationMembers(ref, members) {
        this.assertTypeRefSetGraph(members);
        const type = (0, TypeGraph_1.derefTypeRef)(ref, this.typeGraph);
        if (!(type instanceof Type_1.UnionType || type instanceof Type_1.IntersectionType)) {
          return (0, Support_1.panic)("Tried to set members of non-set-operation type");
        }
        type.setMembers(members);
        this.registerType(type);
      }
      setLostTypeAttributes() {
        return;
      }
    };
    exports.TypeBuilder = TypeBuilder;
  }
});

// node_modules/quicktype-core/dist/TypeUtils.js
var require_TypeUtils = __commonJS({
  "node_modules/quicktype-core/dist/TypeUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchCompoundType = exports.matchType = exports.matchTypeExhaustive = exports.stringTypesForType = exports.directlyReachableSingleNamedType = exports.directlyReachableTypes = exports.separateNamedTypes = exports.isNamedType = exports.getNullAsOptional = exports.nonNullTypeCases = exports.nullableFromUnion = exports.removeNullFromType = exports.removeNullFromUnion = exports.isAnyOrNull = exports.combineTypeAttributesOfTypes = exports.makeGroupsToFlatten = exports.setOperationMembersRecursively = exports.assertIsClass = exports.assertIsObject = void 0;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    function assertIsObject(t) {
      if (t instanceof Type_1.ObjectType) {
        return t;
      }
      return (0, Support_1.panic)("Supposed object type is not an object type");
    }
    exports.assertIsObject = assertIsObject;
    function assertIsClass(t) {
      if (!(t instanceof Type_1.ClassType)) {
        return (0, Support_1.panic)("Supposed class type is not a class type");
      }
      return t;
    }
    exports.assertIsClass = assertIsClass;
    function setOperationMembersRecursively(oneOrMany, combinationKind) {
      const setOperations = Array.isArray(oneOrMany) ? oneOrMany : [oneOrMany];
      const kind = setOperations[0].kind;
      const includeAny = kind !== "intersection";
      const processedSetOperations = /* @__PURE__ */ new Set();
      const members = /* @__PURE__ */ new Set();
      let attributes = TypeAttributes_1.emptyTypeAttributes;
      function process2(t) {
        if (t.kind === kind) {
          const so = t;
          if (processedSetOperations.has(so))
            return;
          processedSetOperations.add(so);
          if (combinationKind !== void 0) {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)(combinationKind, attributes, t.getAttributes());
          }
          for (const m of so.members) {
            process2(m);
          }
        } else if (includeAny || t.kind !== "any") {
          members.add(t);
        } else {
          if (combinationKind !== void 0) {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)(combinationKind, attributes, t.getAttributes());
          }
        }
      }
      for (const so of setOperations) {
        process2(so);
      }
      return [members, attributes];
    }
    exports.setOperationMembersRecursively = setOperationMembersRecursively;
    function makeGroupsToFlatten(setOperations, include) {
      const typeGroups = new collection_utils_1.EqualityMap();
      for (const u of setOperations) {
        const members = new Set(setOperationMembersRecursively(u, void 0)[0]);
        if (include !== void 0) {
          if (!include(members))
            continue;
        }
        let maybeSet = typeGroups.get(members);
        if (maybeSet === void 0) {
          maybeSet = /* @__PURE__ */ new Set();
          if (members.size === 1) {
            maybeSet.add((0, Support_1.defined)((0, collection_utils_1.iterableFirst)(members)));
          }
        }
        maybeSet.add(u);
        typeGroups.set(members, maybeSet);
      }
      return Array.from(typeGroups.values()).map((ts) => Array.from(ts));
    }
    exports.makeGroupsToFlatten = makeGroupsToFlatten;
    function combineTypeAttributesOfTypes(combinationKind, types) {
      return (0, TypeAttributes_1.combineTypeAttributes)(combinationKind, Array.from(types).map((t) => t.getAttributes()));
    }
    exports.combineTypeAttributesOfTypes = combineTypeAttributesOfTypes;
    function isAnyOrNull(t) {
      return t.kind === "any" || t.kind === "null";
    }
    exports.isAnyOrNull = isAnyOrNull;
    function removeNullFromUnion(t, sortBy = false) {
      function sort(s) {
        if (sortBy === false)
          return s;
        if (sortBy === true)
          return (0, collection_utils_1.setSortBy)(s, (m) => m.kind);
        return (0, collection_utils_1.setSortBy)(s, sortBy);
      }
      const nullType = t.findMember("null");
      if (nullType === void 0) {
        return [null, sort(t.members)];
      }
      return [nullType, sort((0, collection_utils_1.setFilter)(t.members, (m) => m.kind !== "null"))];
    }
    exports.removeNullFromUnion = removeNullFromUnion;
    function removeNullFromType(t) {
      if (t.kind === "null") {
        return [t, /* @__PURE__ */ new Set()];
      }
      if (!(t instanceof Type_1.UnionType)) {
        return [null, /* @__PURE__ */ new Set([t])];
      }
      return removeNullFromUnion(t);
    }
    exports.removeNullFromType = removeNullFromType;
    function nullableFromUnion(t) {
      const [hasNull, nonNulls] = removeNullFromUnion(t);
      if (hasNull === null)
        return null;
      if (nonNulls.size !== 1)
        return null;
      return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(nonNulls));
    }
    exports.nullableFromUnion = nullableFromUnion;
    function nonNullTypeCases(t) {
      return removeNullFromType(t)[1];
    }
    exports.nonNullTypeCases = nonNullTypeCases;
    function getNullAsOptional(cp) {
      const [maybeNull, nonNulls] = removeNullFromType(cp.type);
      if (cp.isOptional) {
        return [true, nonNulls];
      }
      return [maybeNull !== null, nonNulls];
    }
    exports.getNullAsOptional = getNullAsOptional;
    function isNamedType(t) {
      return ["class", "union", "enum", "object"].includes(t.kind);
    }
    exports.isNamedType = isNamedType;
    function separateNamedTypes(types) {
      const objects = (0, collection_utils_1.setFilter)(types, (t) => t.kind === "object" || t.kind === "class");
      const enums = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.EnumType);
      const unions = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.UnionType);
      return { objects, enums, unions };
    }
    exports.separateNamedTypes = separateNamedTypes;
    function directlyReachableTypes(t, setForType) {
      const set2 = setForType(t);
      if (set2 !== null)
        return set2;
      return (0, collection_utils_1.setUnion)(...Array.from(t.getNonAttributeChildren()).map((c) => directlyReachableTypes(c, setForType)));
    }
    exports.directlyReachableTypes = directlyReachableTypes;
    function directlyReachableSingleNamedType(type) {
      const definedTypes = directlyReachableTypes(type, (t) => {
        if (!(t instanceof Type_1.UnionType) && isNamedType(t) || t instanceof Type_1.UnionType && nullableFromUnion(t) === null) {
          return /* @__PURE__ */ new Set([t]);
        }
        return null;
      });
      (0, Support_1.assert)(definedTypes.size <= 1, "Cannot have more than one defined type per top-level");
      return (0, collection_utils_1.iterableFirst)(definedTypes);
    }
    exports.directlyReachableSingleNamedType = directlyReachableSingleNamedType;
    function stringTypesForType(t) {
      (0, Support_1.assert)(t.kind === "string", "Only strings can have string types");
      const stringTypes = StringTypes_1.stringTypesTypeAttributeKind.tryGetInAttributes(t.getAttributes());
      if (stringTypes === void 0) {
        return (0, Support_1.panic)("All strings must have a string type attribute");
      }
      return stringTypes;
    }
    exports.stringTypesForType = stringTypesForType;
    function matchTypeExhaustive(t, noneType, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, objectType, enumType, unionType, transformedStringType) {
      if (t.isPrimitive()) {
        if ((0, Type_1.isPrimitiveStringTypeKind)(t.kind)) {
          if (t.kind === "string") {
            return stringType(t);
          }
          return transformedStringType(t);
        }
        const kind = t.kind;
        const f = {
          none: noneType,
          any: anyType,
          null: nullType,
          bool: boolType,
          integer: integerType,
          double: doubleType
        }[kind];
        if (f !== void 0)
          return f(t);
        return (0, Support_1.assertNever)(f);
      } else if (t instanceof Type_1.ArrayType)
        return arrayType(t);
      else if (t instanceof Type_1.ClassType)
        return classType(t);
      else if (t instanceof Type_1.MapType)
        return mapType(t);
      else if (t instanceof Type_1.ObjectType)
        return objectType(t);
      else if (t instanceof Type_1.EnumType)
        return enumType(t);
      else if (t instanceof Type_1.UnionType)
        return unionType(t);
      return (0, Support_1.panic)(`Unknown type ${t.kind}`);
    }
    exports.matchTypeExhaustive = matchTypeExhaustive;
    function matchType(type, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, enumType, unionType, transformedStringType) {
      function typeNotSupported(t) {
        return (0, Support_1.panic)(`Unsupported type ${t.kind} in non-exhaustive match`);
      }
      return matchTypeExhaustive(type, typeNotSupported, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, typeNotSupported, enumType, unionType, transformedStringType !== null && transformedStringType !== void 0 ? transformedStringType : typeNotSupported);
    }
    exports.matchType = matchType;
    function matchCompoundType(t, arrayType, classType, mapType, objectType, unionType) {
      function ignore(_) {
        return;
      }
      matchTypeExhaustive(t, ignore, ignore, ignore, ignore, ignore, ignore, ignore, arrayType, classType, mapType, objectType, ignore, unionType, ignore);
    }
    exports.matchCompoundType = matchCompoundType;
  }
});

// node_modules/quicktype-core/dist/GraphRewriting.js
var require_GraphRewriting = __commonJS({
  "node_modules/quicktype-core/dist/GraphRewriting.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphRewriteBuilder = exports.GraphRemapBuilder = exports.BaseGraphRewriteBuilder = exports.TypeReconstituter = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var TypeBuilder_1 = require_TypeBuilder();
    var TypeGraph_1 = require_TypeGraph();
    var TypeUtils_1 = require_TypeUtils();
    var TypeReconstituter = class {
      constructor(_typeBuilder, _makeClassUnique, _typeAttributes, _forwardingRef, _register) {
        this._typeBuilder = _typeBuilder;
        this._makeClassUnique = _makeClassUnique;
        this._typeAttributes = _typeAttributes;
        this._forwardingRef = _forwardingRef;
        this._register = _register;
        this._wasUsed = false;
        this._typeRef = void 0;
      }
      builderForNewType() {
        (0, Support_1.assert)(!this._wasUsed, "TypeReconstituter used more than once");
        this._wasUsed = true;
        return this._typeBuilder;
      }
      builderForSetting() {
        (0, Support_1.assert)(this._wasUsed && this._typeRef !== void 0, "Can't set type members before constructing a type");
        return this._typeBuilder;
      }
      getResult() {
        if (this._typeRef === void 0) {
          return (0, Support_1.panic)("Type was not reconstituted");
        }
        return this._typeRef;
      }
      // FIXME: Do registration automatically.
      register(tref) {
        (0, Support_1.assert)(this._typeRef === void 0, "Cannot register a type twice");
        this._typeRef = tref;
        this._register(tref);
      }
      registerAndAddAttributes(tref) {
        this._typeBuilder.addAttributes(tref, this._typeAttributes);
        this.register(tref);
      }
      lookup(trefs) {
        (0, Support_1.assert)(!this._wasUsed, "Cannot lookup constituents after building type");
        if ((0, TypeGraph_1.isTypeRef)(trefs)) {
          return this._typeBuilder.lookupTypeRefs([trefs], void 0, false);
        } else {
          const maybeRefs = Array.from(trefs).map((tref) => this._typeBuilder.lookupTypeRefs([tref], void 0, false));
          if (maybeRefs.some((tref) => tref === void 0))
            return void 0;
          return maybeRefs;
        }
      }
      lookupMap(trefs) {
        const resultValues = this.lookup(trefs.values());
        if (resultValues === void 0)
          return void 0;
        (0, Support_1.assert)(resultValues.length === trefs.size, "Didn't get back the correct number of types");
        const result = /* @__PURE__ */ new Map();
        let i = 0;
        for (const k of trefs.keys()) {
          result.set(k, resultValues[i]);
          i += 1;
        }
        return result;
      }
      reconstitute(trefs) {
        (0, Support_1.assert)(this._wasUsed, "Cannot reconstitute constituents before building type");
        if ((0, TypeGraph_1.isTypeRef)(trefs)) {
          return this._typeBuilder.reconstituteTypeRef(trefs);
        } else {
          return Array.from(trefs).map((tref) => this._typeBuilder.reconstituteTypeRef(tref));
        }
      }
      reconstituteMap(trefs) {
        return (0, collection_utils_1.mapMap)(trefs, (tref) => this._typeBuilder.reconstituteTypeRef(tref));
      }
      getPrimitiveType(kind) {
        this.register(this.builderForNewType().getPrimitiveType(kind, this._typeAttributes, this._forwardingRef));
      }
      getEnumType(cases) {
        this.register(this.builderForNewType().getEnumType(this._typeAttributes, cases, this._forwardingRef));
      }
      getUniqueMapType() {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueMapType(this._forwardingRef));
      }
      getMapType(values) {
        this.register(this.builderForNewType().getMapType(this._typeAttributes, values, this._forwardingRef));
      }
      getUniqueArrayType() {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueArrayType(this._forwardingRef));
      }
      getArrayType(items) {
        this.register(this.builderForNewType().getArrayType(this._typeAttributes, items, this._forwardingRef));
      }
      setArrayItems(items) {
        this.builderForSetting().setArrayItems(this.getResult(), items);
      }
      makeClassProperty(tref, isOptional) {
        return this._typeBuilder.makeClassProperty(tref, isOptional);
      }
      getObjectType(properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
      }
      getUniqueObjectType(properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
      }
      getClassType(properties) {
        if (this._makeClassUnique) {
          this.getUniqueClassType(false, properties);
          return;
        }
        this.register(this.builderForNewType().getClassType(this._typeAttributes, properties, this._forwardingRef));
      }
      getUniqueClassType(isFixed, properties) {
        this.register(this.builderForNewType().getUniqueClassType(this._typeAttributes, isFixed, properties, this._forwardingRef));
      }
      setObjectProperties(properties, additionalProperties) {
        this.builderForSetting().setObjectProperties(this.getResult(), properties, additionalProperties);
      }
      getUnionType(members) {
        this.register(this.builderForNewType().getUnionType(this._typeAttributes, members, this._forwardingRef));
      }
      getUniqueUnionType() {
        this.register(this.builderForNewType().getUniqueUnionType(this._typeAttributes, void 0, this._forwardingRef));
      }
      getIntersectionType(members) {
        this.register(this.builderForNewType().getIntersectionType(this._typeAttributes, members, this._forwardingRef));
      }
      getUniqueIntersectionType(members) {
        this.register(this.builderForNewType().getUniqueIntersectionType(this._typeAttributes, members, this._forwardingRef));
      }
      setSetOperationMembers(members) {
        this.builderForSetting().setSetOperationMembers(this.getResult(), members);
      }
    };
    exports.TypeReconstituter = TypeReconstituter;
    var BaseGraphRewriteBuilder = class extends TypeBuilder_1.TypeBuilder {
      constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrint) {
        super(originalGraph.serial + 1, stringTypeMapping, alphabetizeProperties, false, false, graphHasProvenanceAttributes);
        this.originalGraph = originalGraph;
        this.debugPrint = debugPrint;
        this.reconstitutedTypes = /* @__PURE__ */ new Map();
        this._lostTypeAttributes = false;
        this._printIndent = 0;
      }
      withForwardingRef(maybeForwardingRef, typeCreator) {
        if (maybeForwardingRef !== void 0) {
          return typeCreator(maybeForwardingRef);
        }
        const forwardingRef = this.reserveTypeRef();
        const actualRef = typeCreator(forwardingRef);
        (0, Support_1.assert)(actualRef === forwardingRef, "Type creator didn't return its forwarding ref");
        return actualRef;
      }
      reconstituteType(t, attributes, forwardingRef) {
        return this.reconstituteTypeRef(t.typeRef, attributes, forwardingRef);
      }
      reconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        const maybeRef = this.lookupTypeRefs([originalRef], maybeForwardingRef);
        if (maybeRef !== void 0) {
          if (attributes !== void 0) {
            this.addAttributes(maybeRef, attributes);
          }
          return maybeRef;
        }
        return this.forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef);
      }
      reconstituteTypeAttributes(attributes) {
        return (0, collection_utils_1.mapMap)(attributes, (v, a) => a.reconstitute(this, v));
      }
      assertTypeRefsToReconstitute(typeRefs, forwardingRef) {
        (0, Support_1.assert)(typeRefs.length > 0, "Must have at least one type to reconstitute");
        for (const originalRef of typeRefs) {
          (0, TypeGraph_1.assertTypeRefGraph)(originalRef, this.originalGraph);
        }
        if (forwardingRef !== void 0) {
          (0, TypeGraph_1.assertTypeRefGraph)(forwardingRef, this.typeGraph);
        }
      }
      changeDebugPrintIndent(delta) {
        this._printIndent += delta;
      }
      get debugPrintIndentation() {
        return (0, Support_1.indentationString)(this._printIndent);
      }
      finish() {
        for (const [name, t] of this.originalGraph.topLevels) {
          this.addTopLevel(name, this.reconstituteType(t));
        }
        return super.finish();
      }
      setLostTypeAttributes() {
        this._lostTypeAttributes = true;
      }
      get lostTypeAttributes() {
        return this._lostTypeAttributes;
      }
    };
    exports.BaseGraphRewriteBuilder = BaseGraphRewriteBuilder;
    var GraphRemapBuilder = class extends BaseGraphRewriteBuilder {
      constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, _map, debugPrintRemapping) {
        super(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintRemapping);
        this._map = _map;
        this._attributeSources = /* @__PURE__ */ new Map();
        for (const [source, target] of _map) {
          let maybeSources = this._attributeSources.get(target);
          if (maybeSources === void 0) {
            maybeSources = [target];
            this._attributeSources.set(target, maybeSources);
          }
          maybeSources.push(source);
        }
      }
      makeIdentity(_maker) {
        return void 0;
      }
      getMapTarget(tref) {
        const maybeType = this._map.get((0, TypeGraph_1.derefTypeRef)(tref, this.originalGraph));
        if (maybeType === void 0)
          return tref;
        (0, Support_1.assert)(this._map.get(maybeType) === void 0, "We have a type that's remapped to a remapped type");
        return maybeType.typeRef;
      }
      addForwardingIntersection(_forwardingRef, _tref) {
        return (0, Support_1.panic)("We can't add forwarding intersections when we're removing forwarding intersections");
      }
      lookupTypeRefs(typeRefs, forwardingRef) {
        (0, Support_1.assert)(forwardingRef === void 0, "We can't have a forwarding ref when we remap");
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        const first = this.reconstitutedTypes.get((0, TypeGraph_1.typeRefIndex)(this.getMapTarget(typeRefs[0])));
        if (first === void 0)
          return void 0;
        for (let i = 1; i < typeRefs.length; i++) {
          const other = this.reconstitutedTypes.get((0, TypeGraph_1.typeRefIndex)(this.getMapTarget(typeRefs[i])));
          if (first !== other)
            return void 0;
        }
        return first;
      }
      forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        originalRef = this.getMapTarget(originalRef);
        const index = (0, TypeGraph_1.typeRefIndex)(originalRef);
        (0, Support_1.assert)(this.reconstitutedTypes.get(index) === void 0, "Type has already been reconstituted");
        (0, Support_1.assert)(maybeForwardingRef === void 0, "We can't have a forwarding ref when we remap");
        return this.withForwardingRef(void 0, (forwardingRef) => {
          this.reconstitutedTypes.set(index, forwardingRef);
          if (this.debugPrint) {
            console.log(`${this.debugPrintIndentation}reconstituting ${index} as ${(0, TypeGraph_1.typeRefIndex)(forwardingRef)}`);
            this.changeDebugPrintIndent(1);
          }
          const [originalType, originalAttributes] = (0, TypeGraph_1.typeAndAttributesForTypeRef)(originalRef, this.originalGraph);
          const attributeSources = this._attributeSources.get(originalType);
          if (attributes === void 0) {
            attributes = TypeAttributes_1.emptyTypeAttributes;
          }
          if (attributeSources === void 0) {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
          } else {
            attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, this.reconstituteTypeAttributes((0, TypeUtils_1.combineTypeAttributesOfTypes)("union", attributeSources)));
          }
          const newAttributes = attributes;
          const reconstituter = new TypeReconstituter(this, this.canonicalOrder, newAttributes, forwardingRef, (tref) => {
            (0, Support_1.assert)(tref === forwardingRef, "Reconstituted type as a different ref");
            if (this.debugPrint) {
              this.changeDebugPrintIndent(-1);
              console.log(`${this.debugPrintIndentation}reconstituted ${index} as ${(0, TypeGraph_1.typeRefIndex)(tref)}`);
            }
          });
          originalType.reconstitute(reconstituter, this.canonicalOrder);
          return reconstituter.getResult();
        });
      }
    };
    exports.GraphRemapBuilder = GraphRemapBuilder;
    var GraphRewriteBuilder = class extends BaseGraphRewriteBuilder {
      constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, setsToReplace, debugPrintReconstitution, _replacer) {
        super(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintReconstitution);
        this._replacer = _replacer;
        this._reconstitutedUnions = new collection_utils_1.EqualityMap();
        this._setsToReplaceByMember = /* @__PURE__ */ new Map();
        for (const types of setsToReplace) {
          const set2 = new Set(types);
          for (const t of set2) {
            const index = t.index;
            (0, Support_1.assert)(!this._setsToReplaceByMember.has(index), "A type is member of more than one set to be replaced");
            this._setsToReplaceByMember.set(index, set2);
          }
        }
      }
      registerUnion(typeRefs, reconstituted) {
        const set2 = new Set(typeRefs);
        (0, Support_1.assert)(!this._reconstitutedUnions.has(set2), "Cannot register reconstituted set twice");
        this._reconstitutedUnions.set(set2, reconstituted);
      }
      replaceSet(typesToReplace, maybeForwardingRef) {
        return this.withForwardingRef(maybeForwardingRef, (forwardingRef) => {
          if (this.debugPrint) {
            console.log(`${this.debugPrintIndentation}replacing set ${Array.from(typesToReplace).map((t) => t.index.toString()).join(",")} as ${(0, TypeGraph_1.typeRefIndex)(forwardingRef)}`);
            this.changeDebugPrintIndent(1);
          }
          for (const t of typesToReplace) {
            const originalRef = t.typeRef;
            const index = (0, TypeGraph_1.typeRefIndex)(originalRef);
            this.reconstitutedTypes.set(index, forwardingRef);
            this._setsToReplaceByMember.delete(index);
          }
          const result = this._replacer(typesToReplace, this, forwardingRef);
          (0, Support_1.assert)(result === forwardingRef, "The forwarding ref got lost when replacing");
          if (this.debugPrint) {
            this.changeDebugPrintIndent(-1);
            console.log(`${this.debugPrintIndentation}replaced set ${Array.from(typesToReplace).map((t) => t.index.toString()).join(",")} as ${(0, TypeGraph_1.typeRefIndex)(forwardingRef)}`);
          }
          return result;
        });
      }
      forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        const [originalType, originalAttributes] = (0, TypeGraph_1.typeAndAttributesForTypeRef)(originalRef, this.originalGraph);
        const index = (0, TypeGraph_1.typeRefIndex)(originalRef);
        if (this.debugPrint) {
          console.log(`${this.debugPrintIndentation}reconstituting ${index}`);
          this.changeDebugPrintIndent(1);
        }
        if (attributes === void 0) {
          attributes = this.reconstituteTypeAttributes(originalAttributes);
        } else {
          attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
        }
        const reconstituter = new TypeReconstituter(this, this.canonicalOrder, attributes, maybeForwardingRef, (tref) => {
          if (this.debugPrint) {
            this.changeDebugPrintIndent(-1);
            console.log(`${this.debugPrintIndentation}reconstituted ${index} as ${(0, TypeGraph_1.typeRefIndex)(tref)}`);
          }
          if (maybeForwardingRef !== void 0) {
            (0, Support_1.assert)(tref === maybeForwardingRef, "We didn't pass the forwarding ref");
          }
          const alreadyReconstitutedType = this.reconstitutedTypes.get(index);
          if (alreadyReconstitutedType === void 0) {
            this.reconstitutedTypes.set(index, tref);
          } else {
            (0, Support_1.assert)(tref === alreadyReconstitutedType, "We reconstituted a type twice differently");
          }
        });
        originalType.reconstitute(reconstituter, this.canonicalOrder);
        return reconstituter.getResult();
      }
      /*
       public reconstituteTypeUnmodified(originalType: Type): TypeRef {
          const reconstituter = new TypeReconstituter(
              this,
              this.alphabetizeProperties,
              emptyTypeAttributes,
              undefined,
              () => {}
          );
          originalType.reconstitute(reconstituter);
          return reconstituter.getResult();
      }
      */
      // If the union of these type refs have been, or are supposed to be, reconstituted to
      // one target type, return it.  Otherwise return undefined.
      lookupTypeRefs(typeRefs, forwardingRef, replaceSet = true) {
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        let maybeRef = this.reconstitutedTypes.get((0, TypeGraph_1.typeRefIndex)(typeRefs[0]));
        if (maybeRef !== void 0 && maybeRef !== forwardingRef) {
          let allEqual = true;
          for (let i = 1; i < typeRefs.length; i++) {
            if (this.reconstitutedTypes.get((0, TypeGraph_1.typeRefIndex)(typeRefs[i])) !== maybeRef) {
              allEqual = false;
              break;
            }
          }
          if (allEqual) {
            return this.forwardIfNecessary(forwardingRef, maybeRef);
          }
        }
        maybeRef = this._reconstitutedUnions.get(new Set(typeRefs));
        if (maybeRef !== void 0 && maybeRef !== forwardingRef) {
          return this.forwardIfNecessary(forwardingRef, maybeRef);
        }
        const maybeSet = this._setsToReplaceByMember.get((0, TypeGraph_1.typeRefIndex)(typeRefs[0]));
        if (maybeSet === void 0) {
          return void 0;
        }
        for (let i = 1; i < typeRefs.length; i++) {
          if (this._setsToReplaceByMember.get((0, TypeGraph_1.typeRefIndex)(typeRefs[i])) !== maybeSet) {
            return void 0;
          }
        }
        if (!replaceSet)
          return void 0;
        return this.replaceSet(maybeSet, forwardingRef);
      }
    };
    exports.GraphRewriteBuilder = GraphRewriteBuilder;
  }
});

// node_modules/quicktype-core/dist/TypeGraph.js
var require_TypeGraph = __commonJS({
  "node_modules/quicktype-core/dist/TypeGraph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeIndirectionIntersections = exports.optionalToNullable = exports.noneToAny = exports.TypeGraph = exports.TypeAttributeStoreView = exports.TypeAttributeStore = exports.typeAndAttributesForTypeRef = exports.attributesForTypeRef = exports.derefTypeRef = exports.assertTypeRefGraph = exports.typeRefIndex = exports.makeTypeRef = exports.isTypeRef = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var TypeNames_1 = require_TypeNames();
    var Graph_1 = require_Graph();
    var GraphRewriting_1 = require_GraphRewriting();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeBuilder_1 = require_TypeBuilder();
    var TypeUtils_1 = require_TypeUtils();
    var indexBits = 26;
    var indexMask = (1 << indexBits) - 1;
    var serialBits = 31 - indexBits;
    var serialMask = (1 << serialBits) - 1;
    function isTypeRef(x) {
      return typeof x === "number";
    }
    exports.isTypeRef = isTypeRef;
    function makeTypeRef(graph, index) {
      (0, Support_1.assert)(index <= indexMask, "Too many types in graph");
      return (graph.serial & serialMask) << indexBits | index;
    }
    exports.makeTypeRef = makeTypeRef;
    function typeRefIndex(tref) {
      return tref & indexMask;
    }
    exports.typeRefIndex = typeRefIndex;
    function assertTypeRefGraph(tref, graph) {
      (0, Support_1.assert)((tref >> indexBits & serialMask) === (graph.serial & serialMask), "Mixing the wrong type reference and graph");
    }
    exports.assertTypeRefGraph = assertTypeRefGraph;
    function getGraph(graphOrBuilder) {
      if (graphOrBuilder instanceof TypeGraph)
        return graphOrBuilder;
      return graphOrBuilder.originalGraph;
    }
    function derefTypeRef(tref, graphOrBuilder) {
      const graph = getGraph(graphOrBuilder);
      assertTypeRefGraph(tref, graph);
      return graph.typeAtIndex(typeRefIndex(tref));
    }
    exports.derefTypeRef = derefTypeRef;
    function attributesForTypeRef(tref, graphOrBuilder) {
      const graph = getGraph(graphOrBuilder);
      assertTypeRefGraph(tref, graph);
      return graph.atIndex(typeRefIndex(tref))[1];
    }
    exports.attributesForTypeRef = attributesForTypeRef;
    function typeAndAttributesForTypeRef(tref, graphOrBuilder) {
      const graph = getGraph(graphOrBuilder);
      assertTypeRefGraph(tref, graph);
      return graph.atIndex(typeRefIndex(tref));
    }
    exports.typeAndAttributesForTypeRef = typeAndAttributesForTypeRef;
    var TypeAttributeStore = class {
      constructor(_typeGraph, _values) {
        this._typeGraph = _typeGraph;
        this._values = _values;
        this._topLevelValues = /* @__PURE__ */ new Map();
      }
      getTypeIndex(t) {
        const tref = t.typeRef;
        assertTypeRefGraph(tref, this._typeGraph);
        return typeRefIndex(tref);
      }
      attributesForType(t) {
        const index = this.getTypeIndex(t);
        const maybeAttributes = this._values[index];
        if (maybeAttributes !== void 0) {
          return maybeAttributes;
        }
        return TypeAttributes_1.emptyTypeAttributes;
      }
      attributesForTopLevel(name) {
        const maybeAttributes = this._topLevelValues.get(name);
        if (maybeAttributes !== void 0) {
          return maybeAttributes;
        }
        return TypeAttributes_1.emptyTypeAttributes;
      }
      setInMap(attributes, kind, value) {
        return new Map(attributes).set(kind, value);
      }
      set(kind, t, value) {
        const index = this.getTypeIndex(t);
        while (index >= this._values.length) {
          this._values.push(void 0);
        }
        this._values[index] = this.setInMap(this.attributesForType(t), kind, value);
      }
      setForTopLevel(kind, topLevelName, value) {
        this._topLevelValues.set(topLevelName, this.setInMap(this.attributesForTopLevel(topLevelName), kind, value));
      }
      tryGetInMap(attributes, kind) {
        return attributes.get(kind);
      }
      tryGet(kind, t) {
        return this.tryGetInMap(this.attributesForType(t), kind);
      }
      tryGetForTopLevel(kind, topLevelName) {
        return this.tryGetInMap(this.attributesForTopLevel(topLevelName), kind);
      }
    };
    exports.TypeAttributeStore = TypeAttributeStore;
    var TypeAttributeStoreView = class {
      constructor(_attributeStore, _definition) {
        this._attributeStore = _attributeStore;
        this._definition = _definition;
      }
      set(t, value) {
        this._attributeStore.set(this._definition, t, value);
      }
      setForTopLevel(name, value) {
        this._attributeStore.setForTopLevel(this._definition, name, value);
      }
      tryGet(t) {
        return this._attributeStore.tryGet(this._definition, t);
      }
      get(t) {
        return (0, Support_1.defined)(this.tryGet(t));
      }
      tryGetForTopLevel(name) {
        return this._attributeStore.tryGetForTopLevel(this._definition, name);
      }
      getForTopLevel(name) {
        return (0, Support_1.defined)(this.tryGetForTopLevel(name));
      }
    };
    exports.TypeAttributeStoreView = TypeAttributeStoreView;
    var TypeGraph = class {
      constructor(typeBuilder, serial, _haveProvenanceAttributes) {
        this.serial = serial;
        this._haveProvenanceAttributes = _haveProvenanceAttributes;
        this._attributeStore = void 0;
        this._topLevels = /* @__PURE__ */ new Map();
        this._parents = void 0;
        this._printOnRewrite = false;
        this._typeBuilder = typeBuilder;
      }
      get isFrozen() {
        return this._typeBuilder === void 0;
      }
      get attributeStore() {
        return (0, Support_1.defined)(this._attributeStore);
      }
      freeze(topLevels, types, typeAttributes) {
        (0, Support_1.assert)(!this.isFrozen, "Tried to freeze TypeGraph a second time");
        for (const t of types) {
          assertTypeRefGraph(t.typeRef, this);
        }
        this._attributeStore = new TypeAttributeStore(this, typeAttributes);
        this._types = types;
        this._typeBuilder = void 0;
        this._topLevels = (0, collection_utils_1.mapMap)(topLevels, (tref) => derefTypeRef(tref, this));
      }
      get topLevels() {
        (0, Support_1.assert)(this.isFrozen, "Cannot get top-levels from a non-frozen graph");
        return this._topLevels;
      }
      typeAtIndex(index) {
        if (this._typeBuilder !== void 0) {
          return this._typeBuilder.typeAtIndex(index);
        }
        return (0, Support_1.defined)(this._types)[index];
      }
      atIndex(index) {
        if (this._typeBuilder !== void 0) {
          return this._typeBuilder.atIndex(index);
        }
        const t = this.typeAtIndex(index);
        return [t, (0, Support_1.defined)(this._attributeStore).attributesForType(t)];
      }
      filterTypes(predicate) {
        const seen = /* @__PURE__ */ new Set();
        let types = [];
        function addFromType(t) {
          if (seen.has(t))
            return;
          seen.add(t);
          const required = predicate === void 0 || predicate(t);
          if (required) {
            types.push(t);
          }
          for (const c of t.getChildren()) {
            addFromType(c);
          }
        }
        for (const [, t] of this.topLevels) {
          addFromType(t);
        }
        return new Set(types);
      }
      allNamedTypes() {
        return this.filterTypes(TypeUtils_1.isNamedType);
      }
      allNamedTypesSeparated() {
        const types = this.allNamedTypes();
        return (0, TypeUtils_1.separateNamedTypes)(types);
      }
      allProvenance() {
        (0, Support_1.assert)(this._haveProvenanceAttributes);
        const view = new TypeAttributeStoreView(this.attributeStore, TypeBuilder_1.provenanceTypeAttributeKind);
        const sets = Array.from(this.allTypesUnordered()).map((t) => {
          const maybeSet = view.tryGet(t);
          if (maybeSet !== void 0)
            return maybeSet;
          return /* @__PURE__ */ new Set();
        });
        const result = /* @__PURE__ */ new Set();
        (0, collection_utils_1.setUnionManyInto)(result, sets);
        return result;
      }
      setPrintOnRewrite() {
        this._printOnRewrite = true;
      }
      checkLostTypeAttributes(builder, newGraph) {
        if (!this._haveProvenanceAttributes || builder.lostTypeAttributes)
          return;
        const oldProvenance = this.allProvenance();
        const newProvenance = newGraph.allProvenance();
        if (oldProvenance.size !== newProvenance.size) {
          const difference = (0, collection_utils_1.setSubtract)(oldProvenance, newProvenance);
          const indexes = Array.from(difference);
          return (0, Messages_1.messageError)("IRTypeAttributesNotPropagated", { count: difference.size, indexes });
        }
      }
      printRewrite(title) {
        if (!this._printOnRewrite)
          return;
        console.log(`
# ${title}`);
      }
      // Each array in `replacementGroups` is a bunch of types to be replaced by a
      // single new type.  `replacer` is a function that takes a group and a
      // TypeBuilder, and builds a new type with that builder that replaces the group.
      // That particular TypeBuilder will have to take as inputs types in the old
      // graph, but return types in the new graph.  Recursive types must be handled
      // carefully.
      rewrite(title, stringTypeMapping, alphabetizeProperties, replacementGroups, debugPrintReconstitution, replacer, force = false) {
        this.printRewrite(title);
        if (!force && replacementGroups.length === 0)
          return this;
        const builder = new GraphRewriting_1.GraphRewriteBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, replacementGroups, debugPrintReconstitution, replacer);
        const newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
          newGraph.setPrintOnRewrite();
          newGraph.printGraph();
        }
        if (!builder.didAddForwardingIntersection)
          return newGraph;
        return removeIndirectionIntersections(newGraph, stringTypeMapping, debugPrintReconstitution);
      }
      remap(title, stringTypeMapping, alphabetizeProperties, map2, debugPrintRemapping, force = false) {
        this.printRewrite(title);
        if (!force && map2.size === 0)
          return this;
        const builder = new GraphRewriting_1.GraphRemapBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, map2, debugPrintRemapping);
        const newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
          newGraph.setPrintOnRewrite();
          newGraph.printGraph();
        }
        (0, Support_1.assert)(!builder.didAddForwardingIntersection);
        return newGraph;
      }
      garbageCollect(alphabetizeProperties, debugPrintReconstitution) {
        const newGraph = this.remap("GC", (0, TypeBuilder_1.getNoStringTypeMapping)(), alphabetizeProperties, /* @__PURE__ */ new Map(), debugPrintReconstitution, true);
        return newGraph;
      }
      rewriteFixedPoint(alphabetizeProperties, debugPrintReconstitution) {
        let graph = this;
        for (; ; ) {
          const newGraph = this.rewrite("fixed-point", (0, TypeBuilder_1.getNoStringTypeMapping)(), alphabetizeProperties, [], debugPrintReconstitution, Support_1.mustNotHappen, true);
          if (graph.allTypesUnordered().size === newGraph.allTypesUnordered().size) {
            return graph;
          }
          graph = newGraph;
        }
      }
      allTypesUnordered() {
        (0, Support_1.assert)(this.isFrozen, "Tried to get all graph types before it was frozen");
        return new Set((0, Support_1.defined)(this._types));
      }
      makeGraph(invertDirection, childrenOfType) {
        return new Graph_1.Graph((0, Support_1.defined)(this._types), invertDirection, childrenOfType);
      }
      getParentsOfType(t) {
        assertTypeRefGraph(t.typeRef, this);
        if (this._parents === void 0) {
          const parents = (0, Support_1.defined)(this._types).map((_) => /* @__PURE__ */ new Set());
          for (const p of this.allTypesUnordered()) {
            for (const c of p.getChildren()) {
              const index = c.index;
              parents[index] = parents[index].add(p);
            }
          }
          this._parents = parents;
        }
        return this._parents[t.index];
      }
      printGraph() {
        const types = (0, Support_1.defined)(this._types);
        for (let i = 0; i < types.length; i++) {
          const t = types[i];
          const parts = [];
          parts.push(`${t.debugPrintKind}${t.hasNames ? ` ${t.getCombinedName()}` : ""}`);
          const children = t.getChildren();
          if (children.size > 0) {
            parts.push(`children ${Array.from(children).map((c) => c.index).join(",")}`);
          }
          for (const [kind, value] of t.getAttributes()) {
            const maybeString = kind.stringify(value);
            if (maybeString !== void 0) {
              parts.push(maybeString);
            }
          }
          console.log(`${i}: ${parts.join(" | ")}`);
        }
      }
    };
    exports.TypeGraph = TypeGraph;
    function noneToAny(graph, stringTypeMapping, debugPrintReconstitution) {
      const noneTypes = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t.kind === "none");
      if (noneTypes.size === 0) {
        return graph;
      }
      (0, Support_1.assert)(noneTypes.size === 1, "Cannot have more than one none type");
      return graph.rewrite("none to any", stringTypeMapping, false, [Array.from(noneTypes)], debugPrintReconstitution, (types, builder, forwardingRef) => {
        const attributes = (0, TypeUtils_1.combineTypeAttributesOfTypes)("union", types);
        const tref = builder.getPrimitiveType("any", attributes, forwardingRef);
        return tref;
      });
    }
    exports.noneToAny = noneToAny;
    function optionalToNullable(graph, stringTypeMapping, debugPrintReconstitution) {
      function rewriteClass(c, builder, forwardingRef) {
        const properties = (0, collection_utils_1.mapMap)(c.getProperties(), (p, name) => {
          const t = p.type;
          let ref;
          if (!p.isOptional || t.isNullable) {
            ref = builder.reconstituteType(t);
          } else {
            const nullType = builder.getPrimitiveType("null");
            let members;
            if (t instanceof Type_1.UnionType) {
              members = (0, collection_utils_1.setMap)(t.members, (m) => builder.reconstituteType(m)).add(nullType);
            } else {
              members = /* @__PURE__ */ new Set([builder.reconstituteType(t), nullType]);
            }
            const attributes = TypeNames_1.namesTypeAttributeKind.setDefaultInAttributes(t.getAttributes(), () => TypeNames_1.TypeNames.make(/* @__PURE__ */ new Set([name]), /* @__PURE__ */ new Set(), true));
            ref = builder.getUnionType(attributes, members);
          }
          return builder.makeClassProperty(ref, p.isOptional);
        });
        if (c.isFixed) {
          return builder.getUniqueClassType(c.getAttributes(), true, properties, forwardingRef);
        } else {
          return builder.getClassType(c.getAttributes(), properties, forwardingRef);
        }
      }
      const classesWithOptional = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t instanceof Type_1.ClassType && (0, collection_utils_1.mapSome)(t.getProperties(), (p) => p.isOptional));
      const replacementGroups = Array.from(classesWithOptional).map((c) => [c]);
      if (classesWithOptional.size === 0) {
        return graph;
      }
      return graph.rewrite("optional to nullable", stringTypeMapping, false, replacementGroups, debugPrintReconstitution, (setOfClass, builder, forwardingRef) => {
        (0, Support_1.assert)(setOfClass.size === 1);
        const c = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfClass));
        return rewriteClass(c, builder, forwardingRef);
      });
    }
    exports.optionalToNullable = optionalToNullable;
    function removeIndirectionIntersections(graph, stringTypeMapping, debugPrintRemapping) {
      const map2 = [];
      for (const t of graph.allTypesUnordered()) {
        if (!(t instanceof Type_1.IntersectionType))
          continue;
        const seen = /* @__PURE__ */ new Set([t]);
        let current = t;
        while (current.members.size === 1) {
          const member = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(current.members));
          if (!(member instanceof Type_1.IntersectionType)) {
            map2.push([t, member]);
            break;
          }
          if (seen.has(member)) {
            return (0, Support_1.panic)("There's a cycle of intersection types");
          }
          seen.add(member);
          current = member;
        }
      }
      return graph.remap("remove indirection intersections", stringTypeMapping, false, new Map(map2), debugPrintRemapping);
    }
    exports.removeIndirectionIntersections = removeIndirectionIntersections;
  }
});

// node_modules/quicktype-core/dist/Type.js
var require_Type = __commonJS({
  "node_modules/quicktype-core/dist/Type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnionType = exports.IntersectionType = exports.SetOperationType = exports.intersectionTypeIdentity = exports.unionTypeIdentity = exports.setOperationTypeIdentity = exports.setOperationCasesEqual = exports.EnumType = exports.enumTypeIdentity = exports.MapType = exports.ClassType = exports.ObjectType = exports.mapTypeIdentify = exports.classTypeIdentity = exports.ClassProperty = exports.GenericClassProperty = exports.ArrayType = exports.arrayTypeIdentity = exports.PrimitiveType = exports.primitiveTypeIdentity = exports.Type = exports.TypeIdentity = exports.isPrimitiveTypeKind = exports.isNumberTypeKind = exports.targetTypeKindForTransformedStringTypeKind = exports.isPrimitiveStringTypeKind = exports.transformedStringTypeKinds = exports.transformedStringTypeTargetTypeKindsMap = void 0;
    var collection_utils_1 = require_dist();
    var TypeNames_1 = require_TypeNames();
    var URIAttributes_1 = require_URIAttributes();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var TypeGraph_1 = require_TypeGraph();
    var transformedStringTypeTargetTypeKinds = {
      date: { jsonSchema: "date", primitive: void 0 },
      time: { jsonSchema: "time", primitive: void 0 },
      "date-time": { jsonSchema: "date-time", primitive: void 0 },
      uuid: { jsonSchema: "uuid", primitive: void 0 },
      uri: { jsonSchema: "uri", primitive: void 0, attributesProducer: URIAttributes_1.uriInferenceAttributesProducer },
      "integer-string": { jsonSchema: "integer", primitive: "integer" },
      "bool-string": { jsonSchema: "boolean", primitive: "bool" }
    };
    exports.transformedStringTypeTargetTypeKindsMap = (0, collection_utils_1.mapFromObject)(transformedStringTypeTargetTypeKinds);
    exports.transformedStringTypeKinds = new Set(Object.getOwnPropertyNames(transformedStringTypeTargetTypeKinds));
    function isPrimitiveStringTypeKind(kind) {
      return kind === "string" || (0, collection_utils_1.hasOwnProperty)(transformedStringTypeTargetTypeKinds, kind);
    }
    exports.isPrimitiveStringTypeKind = isPrimitiveStringTypeKind;
    function targetTypeKindForTransformedStringTypeKind(kind) {
      const target = exports.transformedStringTypeTargetTypeKindsMap.get(kind);
      if (target === void 0)
        return void 0;
      return target.primitive;
    }
    exports.targetTypeKindForTransformedStringTypeKind = targetTypeKindForTransformedStringTypeKind;
    function isNumberTypeKind(kind) {
      return kind === "integer" || kind === "double";
    }
    exports.isNumberTypeKind = isNumberTypeKind;
    function isPrimitiveTypeKind(kind) {
      if (isPrimitiveStringTypeKind(kind))
        return true;
      if (isNumberTypeKind(kind))
        return true;
      return kind === "none" || kind === "any" || kind === "null" || kind === "bool";
    }
    exports.isPrimitiveTypeKind = isPrimitiveTypeKind;
    function triviallyStructurallyCompatible(x, y) {
      if (x.index === y.index)
        return true;
      if (x.kind === "none" || y.kind === "none")
        return true;
      return false;
    }
    var TypeIdentity = class _TypeIdentity {
      constructor(_kind, _components) {
        this._kind = _kind;
        this._components = _components;
        let h = collection_utils_1.hashCodeInit;
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this._kind));
        for (const c of _components) {
          h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(c));
        }
        this._hashCode = h;
      }
      equals(other) {
        if (!(other instanceof _TypeIdentity))
          return false;
        if (this._kind !== other._kind)
          return false;
        const n = this._components.length;
        (0, Support_1.assert)(n === other._components.length, "Components of a type kind's identity must have the same length");
        for (let i = 0; i < n; i++) {
          if (!(0, collection_utils_1.areEqual)(this._components[i], other._components[i]))
            return false;
        }
        return true;
      }
      hashCode() {
        return this._hashCode;
      }
    };
    exports.TypeIdentity = TypeIdentity;
    var Type = class _Type {
      constructor(typeRef, graph) {
        this.typeRef = typeRef;
        this.graph = graph;
      }
      get index() {
        return (0, TypeGraph_1.typeRefIndex)(this.typeRef);
      }
      getChildren() {
        let result = this.getNonAttributeChildren();
        for (const [k, v] of this.getAttributes()) {
          if (k.children === void 0)
            continue;
          (0, collection_utils_1.setUnionInto)(result, k.children(v));
        }
        return result;
      }
      getAttributes() {
        return (0, TypeGraph_1.attributesForTypeRef)(this.typeRef, this.graph);
      }
      get hasNames() {
        return TypeNames_1.namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()) !== void 0;
      }
      getNames() {
        return (0, Support_1.defined)(TypeNames_1.namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()));
      }
      getCombinedName() {
        return this.getNames().combinedName;
      }
      get debugPrintKind() {
        return this.kind;
      }
      equals(other) {
        if (!(other instanceof _Type))
          return false;
        return this.typeRef === other.typeRef;
      }
      hashCode() {
        return (0, collection_utils_1.hashCodeOf)(this.typeRef);
      }
      structurallyCompatible(other, conflateNumbers = false) {
        function kindsCompatible(kind1, kind2) {
          if (kind1 === kind2)
            return true;
          if (!conflateNumbers)
            return false;
          if (kind1 === "integer")
            return kind2 === "double";
          if (kind1 === "double")
            return kind2 === "integer";
          return false;
        }
        if (triviallyStructurallyCompatible(this, other))
          return true;
        if (!kindsCompatible(this.kind, other.kind))
          return false;
        const workList = [[this, other]];
        const done = [];
        let failed;
        const queue = (x, y) => {
          if (triviallyStructurallyCompatible(x, y))
            return true;
          if (!kindsCompatible(x.kind, y.kind)) {
            failed = true;
            return false;
          }
          workList.push([x, y]);
          return true;
        };
        while (workList.length > 0) {
          let [a, b] = (0, Support_1.defined)(workList.pop());
          if (a.index > b.index) {
            [a, b] = [b, a];
          }
          if (!a.isPrimitive()) {
            let ai = a.index;
            let bi = b.index;
            let found = false;
            for (const [dai, dbi] of done) {
              if (dai === ai && dbi === bi) {
                found = true;
                break;
              }
            }
            if (found)
              continue;
            done.push([ai, bi]);
          }
          failed = false;
          if (!a.structuralEqualityStep(b, conflateNumbers, queue))
            return false;
          if (failed)
            return false;
        }
        return true;
      }
      getParentTypes() {
        return this.graph.getParentsOfType(this);
      }
      getAncestorsNotInSet(set2) {
        const workList = [this];
        const processed = /* @__PURE__ */ new Set();
        const ancestors = /* @__PURE__ */ new Set();
        for (; ; ) {
          const t = workList.pop();
          if (t === void 0)
            break;
          const parents = t.getParentTypes();
          console.log(`${parents.size} parents`);
          for (const p of parents) {
            if (processed.has(p))
              continue;
            processed.add(p);
            if (set2.has(p.typeRef)) {
              console.log(`adding ${p.kind}`);
              workList.push(p);
            } else {
              console.log(`found ${p.kind}`);
              ancestors.add(p);
            }
          }
        }
        return ancestors;
      }
    };
    exports.Type = Type;
    function hasUniqueIdentityAttributes(attributes) {
      return (0, collection_utils_1.mapSome)(attributes, (v, ta) => ta.requiresUniqueIdentity(v));
    }
    function identityAttributes(attributes) {
      return (0, collection_utils_1.mapFilter)(attributes, (_, kind) => kind.inIdentity);
    }
    function primitiveTypeIdentity(kind, attributes) {
      if (hasUniqueIdentityAttributes(attributes))
        return void 0;
      return new TypeIdentity(kind, [identityAttributes(attributes)]);
    }
    exports.primitiveTypeIdentity = primitiveTypeIdentity;
    var PrimitiveType = class extends Type {
      constructor(typeRef, graph, kind) {
        super(typeRef, graph);
        this.kind = kind;
      }
      get isNullable() {
        return this.kind === "null" || this.kind === "any" || this.kind === "none";
      }
      isPrimitive() {
        return true;
      }
      getNonAttributeChildren() {
        return /* @__PURE__ */ new Set();
      }
      get identity() {
        return primitiveTypeIdentity(this.kind, this.getAttributes());
      }
      reconstitute(builder) {
        builder.getPrimitiveType(this.kind);
      }
      structuralEqualityStep(_other, _conflateNumbers, _queue) {
        return true;
      }
    };
    exports.PrimitiveType = PrimitiveType;
    function arrayTypeIdentity(attributes, itemsRef) {
      if (hasUniqueIdentityAttributes(attributes))
        return void 0;
      return new TypeIdentity("array", [identityAttributes(attributes), itemsRef]);
    }
    exports.arrayTypeIdentity = arrayTypeIdentity;
    var ArrayType = class extends Type {
      constructor(typeRef, graph, _itemsRef) {
        super(typeRef, graph);
        this._itemsRef = _itemsRef;
        this.kind = "array";
      }
      setItems(itemsRef) {
        if (this._itemsRef !== void 0) {
          return (0, Support_1.panic)("Can only set array items once");
        }
        this._itemsRef = itemsRef;
      }
      getItemsRef() {
        if (this._itemsRef === void 0) {
          return (0, Support_1.panic)("Array items accessed before they were set");
        }
        return this._itemsRef;
      }
      get items() {
        return (0, TypeGraph_1.derefTypeRef)(this.getItemsRef(), this.graph);
      }
      getNonAttributeChildren() {
        return /* @__PURE__ */ new Set([this.items]);
      }
      get isNullable() {
        return false;
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        return arrayTypeIdentity(this.getAttributes(), this.getItemsRef());
      }
      reconstitute(builder) {
        const itemsRef = this.getItemsRef();
        const maybeItems = builder.lookup(itemsRef);
        if (maybeItems === void 0) {
          builder.getUniqueArrayType();
          builder.setArrayItems(builder.reconstitute(this.getItemsRef()));
        } else {
          builder.getArrayType(maybeItems);
        }
      }
      structuralEqualityStep(other, _conflateNumbers, queue) {
        return queue(this.items, other.items);
      }
    };
    exports.ArrayType = ArrayType;
    var GenericClassProperty = class _GenericClassProperty {
      constructor(typeData, isOptional) {
        this.typeData = typeData;
        this.isOptional = isOptional;
      }
      equals(other) {
        if (!(other instanceof _GenericClassProperty)) {
          return false;
        }
        return (0, collection_utils_1.areEqual)(this.typeData, other.typeData) && this.isOptional === other.isOptional;
      }
      hashCode() {
        return (0, collection_utils_1.hashCodeOf)(this.typeData) + (this.isOptional ? 17 : 23);
      }
    };
    exports.GenericClassProperty = GenericClassProperty;
    var ClassProperty = class extends GenericClassProperty {
      constructor(typeRef, graph, isOptional) {
        super(typeRef, isOptional);
        this.graph = graph;
      }
      get typeRef() {
        return this.typeData;
      }
      get type() {
        return (0, TypeGraph_1.derefTypeRef)(this.typeRef, this.graph);
      }
    };
    exports.ClassProperty = ClassProperty;
    function objectTypeIdentify(kind, attributes, properties, additionalPropertiesRef) {
      if (hasUniqueIdentityAttributes(attributes))
        return void 0;
      return new TypeIdentity(kind, [identityAttributes(attributes), properties, additionalPropertiesRef]);
    }
    function classTypeIdentity(attributes, properties) {
      return objectTypeIdentify("class", attributes, properties, void 0);
    }
    exports.classTypeIdentity = classTypeIdentity;
    function mapTypeIdentify(attributes, additionalPropertiesRef) {
      return objectTypeIdentify("map", attributes, /* @__PURE__ */ new Map(), additionalPropertiesRef);
    }
    exports.mapTypeIdentify = mapTypeIdentify;
    var ObjectType = class extends Type {
      constructor(typeRef, graph, kind, isFixed, _properties, _additionalPropertiesRef) {
        super(typeRef, graph);
        this.kind = kind;
        this.isFixed = isFixed;
        this._properties = _properties;
        this._additionalPropertiesRef = _additionalPropertiesRef;
        if (kind === "map") {
          if (_properties !== void 0) {
            (0, Support_1.assert)(_properties.size === 0);
          }
          (0, Support_1.assert)(!isFixed);
        } else if (kind === "class") {
          (0, Support_1.assert)(_additionalPropertiesRef === void 0);
        } else {
          (0, Support_1.assert)(isFixed);
        }
      }
      setProperties(properties, additionalPropertiesRef) {
        (0, Support_1.assert)(this._properties === void 0, "Tried to set object properties twice");
        if (this instanceof MapType) {
          (0, Support_1.assert)(properties.size === 0, "Cannot set properties on map type");
        }
        if (this instanceof ClassType) {
          (0, Support_1.assert)(additionalPropertiesRef === void 0, "Cannot set additional properties of class type");
        }
        this._properties = properties;
        this._additionalPropertiesRef = additionalPropertiesRef;
      }
      getProperties() {
        return (0, Support_1.defined)(this._properties);
      }
      getSortedProperties() {
        return (0, collection_utils_1.mapSortByKey)(this.getProperties());
      }
      getAdditionalPropertiesRef() {
        (0, Support_1.assert)(this._properties !== void 0, "Properties are not set yet");
        return this._additionalPropertiesRef;
      }
      getAdditionalProperties() {
        const tref = this.getAdditionalPropertiesRef();
        if (tref === void 0)
          return void 0;
        return (0, TypeGraph_1.derefTypeRef)(tref, this.graph);
      }
      getNonAttributeChildren() {
        const types = (0, collection_utils_1.mapSortToArray)(this.getProperties(), (_, k) => k).map(([_, p]) => p.type);
        const additionalProperties = this.getAdditionalProperties();
        if (additionalProperties !== void 0) {
          types.push(additionalProperties);
        }
        return new Set(types);
      }
      get isNullable() {
        return false;
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        if (this.isFixed)
          return void 0;
        return objectTypeIdentify(this.kind, this.getAttributes(), this.getProperties(), this.getAdditionalPropertiesRef());
      }
      reconstitute(builder, canonicalOrder) {
        const sortedProperties = this.getSortedProperties();
        const propertiesInNewOrder = canonicalOrder ? sortedProperties : this.getProperties();
        const maybePropertyTypes = builder.lookupMap((0, collection_utils_1.mapMap)(sortedProperties, (cp) => cp.typeRef));
        const maybeAdditionalProperties = (0, collection_utils_1.definedMap)(this._additionalPropertiesRef, (r) => builder.lookup(r));
        if (maybePropertyTypes !== void 0 && (maybeAdditionalProperties !== void 0 || this._additionalPropertiesRef === void 0)) {
          const properties = (0, collection_utils_1.mapMap)(propertiesInNewOrder, (cp, n) => builder.makeClassProperty((0, Support_1.defined)(maybePropertyTypes.get(n)), cp.isOptional));
          switch (this.kind) {
            case "object":
              (0, Support_1.assert)(this.isFixed);
              builder.getObjectType(properties, maybeAdditionalProperties);
              break;
            case "map":
              builder.getMapType((0, Support_1.defined)(maybeAdditionalProperties));
              break;
            case "class":
              if (this.isFixed) {
                builder.getUniqueClassType(true, properties);
              } else {
                builder.getClassType(properties);
              }
              break;
            default:
              return (0, Support_1.panic)(`Invalid object type kind ${this.kind}`);
          }
        } else {
          switch (this.kind) {
            case "object":
              (0, Support_1.assert)(this.isFixed);
              builder.getUniqueObjectType(void 0, void 0);
              break;
            case "map":
              builder.getUniqueMapType();
              break;
            case "class":
              builder.getUniqueClassType(this.isFixed, void 0);
              break;
            default:
              return (0, Support_1.panic)(`Invalid object type kind ${this.kind}`);
          }
          const reconstitutedTypes = (0, collection_utils_1.mapMap)(sortedProperties, (cp) => builder.reconstitute(cp.typeRef));
          const properties = (0, collection_utils_1.mapMap)(propertiesInNewOrder, (cp, n) => builder.makeClassProperty((0, Support_1.defined)(reconstitutedTypes.get(n)), cp.isOptional));
          const additionalProperties = (0, collection_utils_1.definedMap)(this._additionalPropertiesRef, (r) => builder.reconstitute(r));
          builder.setObjectProperties(properties, additionalProperties);
        }
      }
      structuralEqualityStep(other, _conflateNumbers, queue) {
        const pa = this.getProperties();
        const pb = other.getProperties();
        if (pa.size !== pb.size)
          return false;
        let failed = false;
        for (const [name, cpa] of pa) {
          const cpb = pb.get(name);
          if (cpb === void 0 || cpa.isOptional !== cpb.isOptional || !queue(cpa.type, cpb.type)) {
            failed = true;
            return false;
          }
        }
        if (failed)
          return false;
        const thisAdditionalProperties = this.getAdditionalProperties();
        const otherAdditionalProperties = other.getAdditionalProperties();
        if (thisAdditionalProperties === void 0 !== (otherAdditionalProperties === void 0))
          return false;
        if (thisAdditionalProperties === void 0 || otherAdditionalProperties === void 0)
          return true;
        return queue(thisAdditionalProperties, otherAdditionalProperties);
      }
    };
    exports.ObjectType = ObjectType;
    var ClassType = class extends ObjectType {
      constructor(typeRef, graph, isFixed, properties) {
        super(typeRef, graph, "class", isFixed, properties, void 0);
      }
    };
    exports.ClassType = ClassType;
    var MapType = class extends ObjectType {
      constructor(typeRef, graph, valuesRef) {
        super(typeRef, graph, "map", false, (0, collection_utils_1.definedMap)(valuesRef, () => /* @__PURE__ */ new Map()), valuesRef);
      }
      // FIXME: Remove and use `getAdditionalProperties()` instead.
      get values() {
        return (0, Support_1.defined)(this.getAdditionalProperties());
      }
    };
    exports.MapType = MapType;
    function enumTypeIdentity(attributes, cases) {
      if (hasUniqueIdentityAttributes(attributes))
        return void 0;
      return new TypeIdentity("enum", [identityAttributes(attributes), cases]);
    }
    exports.enumTypeIdentity = enumTypeIdentity;
    var EnumType = class extends Type {
      constructor(typeRef, graph, cases) {
        super(typeRef, graph);
        this.cases = cases;
        this.kind = "enum";
      }
      get isNullable() {
        return false;
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        return enumTypeIdentity(this.getAttributes(), this.cases);
      }
      getNonAttributeChildren() {
        return /* @__PURE__ */ new Set();
      }
      reconstitute(builder) {
        builder.getEnumType(this.cases);
      }
      structuralEqualityStep(other, _conflateNumbers, _queue) {
        return (0, collection_utils_1.areEqual)(this.cases, other.cases);
      }
    };
    exports.EnumType = EnumType;
    function setOperationCasesEqual(typesA, typesB, conflateNumbers, membersEqual) {
      const ma = (0, collection_utils_1.toReadonlySet)(typesA);
      const mb = (0, collection_utils_1.toReadonlySet)(typesB);
      if (ma.size !== mb.size)
        return false;
      return (0, collection_utils_1.iterableEvery)(ma, (ta) => {
        const tb = (0, collection_utils_1.iterableFind)(mb, (t) => t.kind === ta.kind);
        if (tb !== void 0) {
          if (membersEqual(ta, tb))
            return true;
        }
        if (conflateNumbers) {
          if (ta.kind === "integer" && (0, collection_utils_1.iterableSome)(mb, (t) => t.kind === "double"))
            return true;
          if (ta.kind === "double" && (0, collection_utils_1.iterableSome)(mb, (t) => t.kind === "integer"))
            return true;
        }
        return false;
      });
    }
    exports.setOperationCasesEqual = setOperationCasesEqual;
    function setOperationTypeIdentity(kind, attributes, memberRefs) {
      if (hasUniqueIdentityAttributes(attributes))
        return void 0;
      return new TypeIdentity(kind, [identityAttributes(attributes), memberRefs]);
    }
    exports.setOperationTypeIdentity = setOperationTypeIdentity;
    function unionTypeIdentity(attributes, memberRefs) {
      return setOperationTypeIdentity("union", attributes, memberRefs);
    }
    exports.unionTypeIdentity = unionTypeIdentity;
    function intersectionTypeIdentity(attributes, memberRefs) {
      return setOperationTypeIdentity("intersection", attributes, memberRefs);
    }
    exports.intersectionTypeIdentity = intersectionTypeIdentity;
    var SetOperationType = class extends Type {
      constructor(typeRef, graph, kind, _memberRefs) {
        super(typeRef, graph);
        this.kind = kind;
        this._memberRefs = _memberRefs;
      }
      setMembers(memberRefs) {
        if (this._memberRefs !== void 0) {
          return (0, Support_1.panic)("Can only set map members once");
        }
        this._memberRefs = memberRefs;
      }
      getMemberRefs() {
        if (this._memberRefs === void 0) {
          return (0, Support_1.panic)("Map members accessed before they were set");
        }
        return this._memberRefs;
      }
      get members() {
        return (0, collection_utils_1.setMap)(this.getMemberRefs(), (tref) => (0, TypeGraph_1.derefTypeRef)(tref, this.graph));
      }
      get sortedMembers() {
        return this.getNonAttributeChildren();
      }
      getNonAttributeChildren() {
        return (0, collection_utils_1.setSortBy)(this.members, (t) => t.kind);
      }
      isPrimitive() {
        return false;
      }
      get identity() {
        return setOperationTypeIdentity(this.kind, this.getAttributes(), this.getMemberRefs());
      }
      reconstituteSetOperation(builder, canonicalOrder, getType) {
        const sortedMemberRefs = (0, collection_utils_1.mapMap)(this.sortedMembers.entries(), (t) => t.typeRef);
        const membersInOrder = canonicalOrder ? this.sortedMembers : this.members;
        const maybeMembers = builder.lookupMap(sortedMemberRefs);
        if (maybeMembers === void 0) {
          getType(void 0);
          const reconstituted = builder.reconstituteMap(sortedMemberRefs);
          builder.setSetOperationMembers((0, collection_utils_1.setMap)(membersInOrder, (t) => (0, Support_1.defined)(reconstituted.get(t))));
        } else {
          getType((0, collection_utils_1.setMap)(membersInOrder, (t) => (0, Support_1.defined)(maybeMembers.get(t))));
        }
      }
      structuralEqualityStep(other, conflateNumbers, queue) {
        return setOperationCasesEqual(this.members, other.members, conflateNumbers, queue);
      }
    };
    exports.SetOperationType = SetOperationType;
    var IntersectionType = class extends SetOperationType {
      constructor(typeRef, graph, memberRefs) {
        super(typeRef, graph, "intersection", memberRefs);
      }
      get isNullable() {
        return (0, Support_1.panic)("isNullable not implemented for IntersectionType");
      }
      reconstitute(builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, (members) => {
          if (members === void 0) {
            builder.getUniqueIntersectionType();
          } else {
            builder.getIntersectionType(members);
          }
        });
      }
    };
    exports.IntersectionType = IntersectionType;
    var UnionType = class extends SetOperationType {
      constructor(typeRef, graph, memberRefs) {
        super(typeRef, graph, "union", memberRefs);
        if (memberRefs !== void 0) {
          (0, Messages_1.messageAssert)(memberRefs.size > 0, "IRNoEmptyUnions", {});
        }
      }
      setMembers(memberRefs) {
        (0, Messages_1.messageAssert)(memberRefs.size > 0, "IRNoEmptyUnions", {});
        super.setMembers(memberRefs);
      }
      get stringTypeMembers() {
        return (0, collection_utils_1.setFilter)(this.members, (t) => isPrimitiveStringTypeKind(t.kind) || t.kind === "enum");
      }
      findMember(kind) {
        return (0, collection_utils_1.iterableFind)(this.members, (t) => t.kind === kind);
      }
      get isNullable() {
        return this.findMember("null") !== void 0;
      }
      get isCanonical() {
        const members = this.members;
        if (members.size <= 1)
          return false;
        const kinds = (0, collection_utils_1.setMap)(members, (t) => t.kind);
        if (kinds.size < members.size)
          return false;
        if (kinds.has("union") || kinds.has("intersection"))
          return false;
        if (kinds.has("none") || kinds.has("any"))
          return false;
        if (kinds.has("string") && kinds.has("enum"))
          return false;
        let numObjectTypes = 0;
        if (kinds.has("class"))
          numObjectTypes += 1;
        if (kinds.has("map"))
          numObjectTypes += 1;
        if (kinds.has("object"))
          numObjectTypes += 1;
        if (numObjectTypes > 1)
          return false;
        return true;
      }
      reconstitute(builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, (members) => {
          if (members === void 0) {
            builder.getUniqueUnionType();
          } else {
            builder.getUnionType(members);
          }
        });
      }
    };
    exports.UnionType = UnionType;
  }
});

// node_modules/quicktype-core/dist/Transformers.js
var require_Transformers = __commonJS({
  "node_modules/quicktype-core/dist/Transformers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.followTargetType = exports.transformationForType = exports.transformationTypeAttributeKind = exports.Transformation = exports.MinMaxValueTransformer = exports.MinMaxLengthCheckTransformer = exports.StringifyTransformer = exports.ParseStringTransformer = exports.StringProducerTransformer = exports.UnionInstantiationTransformer = exports.StringMatchTransformer = exports.UnionMemberMatchTransformer = exports.DecodingChoiceTransformer = exports.ChoiceTransformer = exports.ArrayEncodingTransformer = exports.ArrayDecodingTransformer = exports.EncodingTransformer = exports.DecodingTransformer = exports.MatchTransformer = exports.ProducerTransformer = exports.Transformer = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeGraph_1 = require_TypeGraph();
    function debugStringForType(t) {
      const target = followTargetType(t);
      if (t === target) {
        return t.kind;
      }
      return `${t.kind} (${target.kind})`;
    }
    function getNumberOfNodes(xfer) {
      return (0, collection_utils_1.definedMapWithDefault)(xfer, 0, (x) => x.getNumberOfNodes());
    }
    var Transformer = class {
      constructor(kind, graph, sourceTypeRef) {
        this.kind = kind;
        this.graph = graph;
        this.sourceTypeRef = sourceTypeRef;
      }
      get sourceType() {
        return (0, TypeGraph_1.derefTypeRef)(this.sourceTypeRef, this.graph);
      }
      /** This must return a newly constructed set. */
      getChildren() {
        return /* @__PURE__ */ new Set([this.sourceType]);
      }
      getNumberOfNodes() {
        return 1;
      }
      equals(other) {
        return this.sourceTypeRef === other.sourceTypeRef;
      }
      hashCode() {
        return (0, collection_utils_1.hashCodeOf)(this.sourceTypeRef);
      }
      debugDescription() {
        return `${debugStringForType(this.sourceType)} -> ${this.kind}`;
      }
      debugPrintContinuations(_indent) {
        return;
      }
      debugPrint(indent) {
        console.log((0, Support_1.indentationString)(indent) + this.debugDescription());
        this.debugPrintContinuations(indent + 1);
      }
    };
    exports.Transformer = Transformer;
    var ProducerTransformer = class _ProducerTransformer extends Transformer {
      constructor(kind, graph, sourceTypeRef, consumer) {
        super(kind, graph, sourceTypeRef);
        this.consumer = consumer;
      }
      getChildren() {
        const children = super.getChildren();
        if (this.consumer === void 0)
          return children;
        return (0, collection_utils_1.setUnionInto)(children, this.consumer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + getNumberOfNodes(this.consumer);
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _ProducerTransformer))
          return false;
        return (0, collection_utils_1.areEqual)(this.consumer, other.consumer);
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.consumer));
      }
      debugPrintContinuations(indent) {
        if (this.consumer === void 0)
          return;
        this.consumer.debugPrint(indent);
      }
    };
    exports.ProducerTransformer = ProducerTransformer;
    var MatchTransformer = class _MatchTransformer extends Transformer {
      constructor(kind, graph, sourceTypeRef, transformer) {
        super(kind, graph, sourceTypeRef);
        this.transformer = transformer;
      }
      getChildren() {
        return (0, collection_utils_1.setUnionInto)(super.getChildren(), this.transformer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + this.transformer.getNumberOfNodes();
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _MatchTransformer))
          return false;
        return this.transformer.equals(other.transformer);
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, this.transformer.hashCode());
      }
      debugPrintContinuations(indent) {
        this.transformer.debugPrint(indent);
      }
    };
    exports.MatchTransformer = MatchTransformer;
    var DecodingTransformer = class _DecodingTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer) {
        super("decode", graph, sourceTypeRef, consumer);
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer !== void 0) {
          return (0, Support_1.panic)("Reversing a decoding transformer cannot have a continuation");
        }
        if (this.consumer === void 0) {
          return new EncodingTransformer(this.graph, targetTypeRef);
        } else {
          return this.consumer.reverse(targetTypeRef, new EncodingTransformer(this.graph, this.consumer.sourceTypeRef));
        }
      }
      reconstitute(builder) {
        return new _DecodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        return other instanceof _DecodingTransformer;
      }
    };
    exports.DecodingTransformer = DecodingTransformer;
    var EncodingTransformer = class _EncodingTransformer extends Transformer {
      constructor(graph, sourceTypeRef) {
        super("encode", graph, sourceTypeRef);
      }
      get canFail() {
        return false;
      }
      reverse(_targetTypeRef, _continuationTransformer) {
        return (0, Support_1.panic)("Can't reverse encoding transformer");
      }
      reconstitute(builder) {
        return new _EncodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _EncodingTransformer))
          return false;
        return true;
      }
    };
    exports.EncodingTransformer = EncodingTransformer;
    var ArrayDecodingTransformer = class _ArrayDecodingTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, _itemTargetTypeRef, itemTransformer) {
        super("decode-array", graph, sourceTypeRef, consumer);
        this._itemTargetTypeRef = _itemTargetTypeRef;
        this.itemTransformer = itemTransformer;
      }
      getChildren() {
        const children = super.getChildren();
        children.add(this.itemTargetType);
        return (0, collection_utils_1.setUnionInto)(children, this.itemTransformer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + this.itemTransformer.getNumberOfNodes();
      }
      get canFail() {
        return false;
      }
      get itemTargetType() {
        return (0, TypeGraph_1.derefTypeRef)(this._itemTargetTypeRef, this.graph);
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer !== void 0) {
          return (0, Support_1.panic)("Reversing a decoding transformer cannot have a continuation");
        }
        const itemTransformer = this.itemTransformer.reverse(this._itemTargetTypeRef, void 0);
        if (this.consumer === void 0) {
          return new ArrayEncodingTransformer(this.graph, targetTypeRef, this.itemTransformer.sourceTypeRef, itemTransformer);
        } else {
          return this.consumer.reverse(targetTypeRef, new ArrayEncodingTransformer(this.graph, this.consumer.sourceTypeRef, this.itemTransformer.sourceTypeRef, itemTransformer));
        }
      }
      reconstitute(builder) {
        return new _ArrayDecodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), builder.reconstituteTypeRef(this._itemTargetTypeRef), this.itemTransformer.reconstitute(builder));
      }
      hashCode() {
        let h = super.hashCode();
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this._itemTargetTypeRef));
        h = (0, collection_utils_1.addHashCode)(h, this.itemTransformer.hashCode());
        return h;
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _ArrayDecodingTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this._itemTargetTypeRef, other._itemTargetTypeRef))
          return false;
        return this.itemTransformer.equals(other.itemTransformer);
      }
      debugPrintContinuations(indent) {
        this.itemTransformer.debugPrint(indent);
        super.debugPrintContinuations(indent);
      }
    };
    exports.ArrayDecodingTransformer = ArrayDecodingTransformer;
    var ArrayEncodingTransformer = class _ArrayEncodingTransformer extends Transformer {
      constructor(graph, sourceTypeRef, _itemTargetTypeRef, itemTransformer) {
        super("encode-array", graph, sourceTypeRef);
        this._itemTargetTypeRef = _itemTargetTypeRef;
        this.itemTransformer = itemTransformer;
      }
      getChildren() {
        const children = super.getChildren();
        children.add(this.itemTargetType);
        return (0, collection_utils_1.setUnionInto)(children, this.itemTransformer.getChildren());
      }
      getNumberOfNodes() {
        return super.getNumberOfNodes() + this.itemTransformer.getNumberOfNodes();
      }
      get canFail() {
        return false;
      }
      get itemTargetType() {
        return (0, TypeGraph_1.derefTypeRef)(this._itemTargetTypeRef, this.graph);
      }
      reverse(_targetTypeRef, _continuationTransformer) {
        return (0, Support_1.panic)("Can't reverse array encoding transformer");
      }
      reconstitute(builder) {
        return new _ArrayEncodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), builder.reconstituteTypeRef(this._itemTargetTypeRef), this.itemTransformer.reconstitute(builder));
      }
      hashCode() {
        let h = super.hashCode();
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this._itemTargetTypeRef));
        return (0, collection_utils_1.addHashCode)(h, this.itemTransformer.hashCode());
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _ArrayEncodingTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this._itemTargetTypeRef, other._itemTargetTypeRef))
          return false;
        return this.itemTransformer.equals(other.itemTransformer);
      }
      debugPrintContinuations(indent) {
        this.itemTransformer.debugPrint(indent);
        super.debugPrintContinuations(indent);
      }
    };
    exports.ArrayEncodingTransformer = ArrayEncodingTransformer;
    var ChoiceTransformer = class _ChoiceTransformer extends Transformer {
      constructor(graph, sourceTypeRef, transformers) {
        super("choice", graph, sourceTypeRef);
        this.transformers = transformers;
        (0, Support_1.assert)(transformers.length > 0, "Choice must have at least one transformer");
      }
      getChildren() {
        let children = super.getChildren();
        for (const xfer of this.transformers) {
          (0, collection_utils_1.setUnionInto)(children, xfer.getChildren());
        }
        return children;
      }
      getNumberOfNodes() {
        let n = 0;
        for (const xfer of this.transformers) {
          n += xfer.getNumberOfNodes();
        }
        return super.getNumberOfNodes() + n;
      }
      get canFail() {
        return this.transformers.some((xfer) => xfer.canFail);
      }
      reverse(targetTypeRef, continuationTransformer) {
        const transformers = this.transformers.map((xfer) => xfer.reverse(targetTypeRef, continuationTransformer));
        if (transformers.every((xfer) => xfer instanceof UnionMemberMatchTransformer)) {
          const memberMatchers = transformers;
          const first = memberMatchers[0];
          if (memberMatchers.every((xfer) => first.memberType.equals(xfer.memberType))) {
            const subTransformers = memberMatchers.map((xfer) => xfer.transformer);
            return new UnionMemberMatchTransformer(this.graph, targetTypeRef, new _ChoiceTransformer(this.graph, subTransformers[0].sourceTypeRef, subTransformers), first.memberTypeRef);
          }
        }
        return new _ChoiceTransformer(this.graph, targetTypeRef, transformers);
      }
      reconstitute(builder) {
        return new _ChoiceTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformers.map((xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _ChoiceTransformer))
          return false;
        return (0, collection_utils_1.areEqual)(this.transformers, other.transformers);
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.transformers));
      }
      debugPrintContinuations(indent) {
        for (const xfer of this.transformers) {
          xfer.debugPrint(indent);
        }
      }
    };
    exports.ChoiceTransformer = ChoiceTransformer;
    var DecodingChoiceTransformer = class _DecodingChoiceTransformer extends Transformer {
      constructor(graph, sourceTypeRef, nullTransformer, integerTransformer, doubleTransformer, boolTransformer, stringTransformer, arrayTransformer, objectTransformer) {
        super("decoding-choice", graph, sourceTypeRef);
        this.nullTransformer = nullTransformer;
        this.integerTransformer = integerTransformer;
        this.doubleTransformer = doubleTransformer;
        this.boolTransformer = boolTransformer;
        this.stringTransformer = stringTransformer;
        this.arrayTransformer = arrayTransformer;
        this.objectTransformer = objectTransformer;
      }
      get transformers() {
        const transformers = [];
        function add(xfer) {
          if (xfer === void 0)
            return;
          transformers.push(xfer);
        }
        add(this.nullTransformer);
        add(this.integerTransformer);
        add(this.doubleTransformer);
        add(this.boolTransformer);
        add(this.stringTransformer);
        add(this.arrayTransformer);
        add(this.objectTransformer);
        return transformers;
      }
      getChildren() {
        let children = super.getChildren();
        for (const xfer of this.transformers) {
          (0, collection_utils_1.setUnionInto)(children, xfer.getChildren());
        }
        return children;
      }
      getNumberOfNodes() {
        let n = super.getNumberOfNodes();
        for (const xfer of this.transformers) {
          n += getNumberOfNodes(xfer);
        }
        return n;
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        (0, Support_1.assert)(continuationTransformer === void 0, "Reversing a decoding transformer can't have a target transformer");
        let transformers = /* @__PURE__ */ new Map();
        let memberMatchTransformers = /* @__PURE__ */ new Map();
        function addCase(reversed) {
          if (reversed instanceof UnionMemberMatchTransformer) {
            const memberType = reversed.memberType;
            let arr = memberMatchTransformers.get(memberType);
            if (arr === void 0) {
              arr = [];
              memberMatchTransformers.set(memberType, arr);
            }
            arr.push(reversed);
          } else {
            const kind = reversed.sourceType.kind;
            let arr = transformers.get(kind);
            if (arr === void 0) {
              arr = [];
              transformers.set(kind, arr);
            }
            arr.push(reversed);
          }
        }
        function reverseAndAdd(transformer) {
          const reversed = transformer.reverse(targetTypeRef, void 0);
          let cases = [];
          if (reversed instanceof ChoiceTransformer) {
            cases = reversed.transformers;
          } else {
            cases = [reversed];
          }
          for (const xfer of cases) {
            addCase(xfer);
          }
        }
        function filter(xfers) {
          (0, Support_1.assert)(xfers.length > 0, "Must have at least one transformer");
          const nonfailing = xfers.filter((xfer) => {
            if (xfer instanceof UnionMemberMatchTransformer) {
              return !xfer.transformer.canFail;
            } else {
              return !xfer.canFail;
            }
          });
          if (nonfailing.length === 0)
            return xfers;
          const smallest = (0, collection_utils_1.arraySortByInto)(nonfailing.map((x) => [x.getNumberOfNodes(), x]), ([c, _]) => c)[0][1];
          return [smallest];
        }
        this.transformers.forEach(reverseAndAdd);
        const allTransformers = Array.from(transformers.values()).concat(Array.from(memberMatchTransformers.values()));
        const resultingTransformers = [].concat(...allTransformers.map(filter));
        if (resultingTransformers.length === 1) {
          return resultingTransformers[0];
        }
        return new ChoiceTransformer(this.graph, targetTypeRef, resultingTransformers);
      }
      reconstitute(builder) {
        function reconstitute(xf) {
          if (xf === void 0)
            return void 0;
          return xf.reconstitute(builder);
        }
        return new _DecodingChoiceTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), reconstitute(this.nullTransformer), reconstitute(this.integerTransformer), reconstitute(this.doubleTransformer), reconstitute(this.boolTransformer), reconstitute(this.stringTransformer), reconstitute(this.arrayTransformer), reconstitute(this.objectTransformer));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _DecodingChoiceTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this.nullTransformer, other.nullTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this.integerTransformer, other.integerTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this.doubleTransformer, other.doubleTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this.boolTransformer, other.boolTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this.stringTransformer, other.stringTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this.arrayTransformer, other.arrayTransformer))
          return false;
        if (!(0, collection_utils_1.areEqual)(this.objectTransformer, other.objectTransformer))
          return false;
        return true;
      }
      hashCode() {
        let h = super.hashCode();
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.nullTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.integerTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.doubleTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.boolTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.stringTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.arrayTransformer));
        h = (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.objectTransformer));
        return h;
      }
      debugPrintContinuations(indent) {
        for (const xfer of this.transformers) {
          xfer.debugPrint(indent);
        }
      }
    };
    exports.DecodingChoiceTransformer = DecodingChoiceTransformer;
    var UnionMemberMatchTransformer = class _UnionMemberMatchTransformer extends MatchTransformer {
      constructor(graph, sourceTypeRef, transformer, memberTypeRef) {
        super("union-member-match", graph, sourceTypeRef, transformer);
        this.memberTypeRef = memberTypeRef;
      }
      get sourceType() {
        const t = (0, TypeGraph_1.derefTypeRef)(this.sourceTypeRef, this.graph);
        if (!(t instanceof Type_1.UnionType)) {
          return (0, Support_1.panic)("The source of a union member match transformer must be a union type");
        }
        return t;
      }
      get canFail() {
        return true;
      }
      get memberType() {
        return (0, TypeGraph_1.derefTypeRef)(this.memberTypeRef, this.graph);
      }
      getChildren() {
        return super.getChildren().add(this.memberType);
      }
      reverse(_targetTypeRef, _continuationTransformer) {
        return (0, Support_1.panic)("Can't reverse union member match transformer");
      }
      reconstitute(builder) {
        return new _UnionMemberMatchTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformer.reconstitute(builder), builder.reconstituteTypeRef(this.memberTypeRef));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _UnionMemberMatchTransformer))
          return false;
        return this.memberTypeRef === other.memberTypeRef;
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.memberTypeRef));
      }
      debugDescription() {
        return `${super.debugDescription()} - member: ${debugStringForType(this.memberType)}`;
      }
    };
    exports.UnionMemberMatchTransformer = UnionMemberMatchTransformer;
    var StringMatchTransformer = class _StringMatchTransformer extends MatchTransformer {
      constructor(graph, sourceTypeRef, transformer, stringCase) {
        super("string-match", graph, sourceTypeRef, transformer);
        this.stringCase = stringCase;
      }
      get sourceType() {
        const t = (0, TypeGraph_1.derefTypeRef)(this.sourceTypeRef, this.graph);
        if (!(t instanceof Type_1.EnumType) && !(t instanceof Type_1.PrimitiveType && t.kind === "string")) {
          return (0, Support_1.panic)("The source of a string match transformer must be an enum or string type");
        }
        return t;
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        return this.transformer.reverse(targetTypeRef, new StringProducerTransformer(this.graph, this.transformer.sourceTypeRef, continuationTransformer, this.stringCase));
      }
      reconstitute(builder) {
        return new _StringMatchTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformer.reconstitute(builder), this.stringCase);
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _StringMatchTransformer))
          return false;
        return this.stringCase !== other.stringCase;
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashString)(this.stringCase));
      }
      debugDescription() {
        return `${super.debugDescription()} - case: ${this.stringCase}`;
      }
    };
    exports.StringMatchTransformer = StringMatchTransformer;
    var UnionInstantiationTransformer = class _UnionInstantiationTransformer extends Transformer {
      constructor(graph, sourceTypeRef) {
        super("union-instantiation", graph, sourceTypeRef);
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer === void 0) {
          return (0, Support_1.panic)("Union instantiation transformer reverse must have a continuation");
        }
        return new UnionMemberMatchTransformer(this.graph, targetTypeRef, continuationTransformer, this.sourceTypeRef);
      }
      reconstitute(builder) {
        return new _UnionInstantiationTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        return other instanceof _UnionInstantiationTransformer;
      }
    };
    exports.UnionInstantiationTransformer = UnionInstantiationTransformer;
    var StringProducerTransformer = class _StringProducerTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, result) {
        super("string-producer", graph, sourceTypeRef, consumer);
        this.result = result;
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer === void 0) {
          return (0, Support_1.panic)("Reversing a string producer transformer must have a continuation");
        }
        if (this.consumer === void 0) {
          return new StringMatchTransformer(this.graph, targetTypeRef, continuationTransformer, this.result);
        } else {
          return this.consumer.reverse(targetTypeRef, new StringMatchTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.result));
        }
      }
      reconstitute(builder) {
        return new _StringProducerTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), this.result);
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        if (!(other instanceof _StringProducerTransformer))
          return false;
        return this.result === other.result;
      }
      hashCode() {
        const h = super.hashCode();
        return (0, collection_utils_1.addHashCode)(h, (0, collection_utils_1.hashCodeOf)(this.consumer));
      }
      debugDescription() {
        return `${super.debugDescription()} - result: ${this.result}`;
      }
    };
    exports.StringProducerTransformer = StringProducerTransformer;
    var ParseStringTransformer = class _ParseStringTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer) {
        super("parse-string", graph, sourceTypeRef, consumer);
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new StringifyTransformer(this.graph, targetTypeRef, continuationTransformer);
        } else {
          return this.consumer.reverse(targetTypeRef, new StringifyTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer));
        }
      }
      reconstitute(builder) {
        return new _ParseStringTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        return other instanceof _ParseStringTransformer;
      }
    };
    exports.ParseStringTransformer = ParseStringTransformer;
    var StringifyTransformer = class _StringifyTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer) {
        super("stringify", graph, sourceTypeRef, consumer);
      }
      get canFail() {
        return false;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new ParseStringTransformer(this.graph, targetTypeRef, continuationTransformer);
        } else {
          return this.consumer.reverse(targetTypeRef, new ParseStringTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer));
        }
      }
      reconstitute(builder) {
        return new _StringifyTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)));
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        return other instanceof _StringifyTransformer;
      }
    };
    exports.StringifyTransformer = StringifyTransformer;
    var MinMaxLengthCheckTransformer = class _MinMaxLengthCheckTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, minLength, maxLength) {
        super("min-max-length-check", graph, sourceTypeRef, consumer);
        this.minLength = minLength;
        this.maxLength = maxLength;
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new _MinMaxLengthCheckTransformer(this.graph, targetTypeRef, continuationTransformer, this.minLength, this.maxLength);
        } else {
          return this.consumer.reverse(targetTypeRef, new _MinMaxLengthCheckTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.minLength, this.maxLength));
        }
      }
      reconstitute(builder) {
        return new _MinMaxLengthCheckTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), this.minLength, this.maxLength);
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        return other instanceof _MinMaxLengthCheckTransformer && this.minLength === other.minLength && this.maxLength === other.maxLength;
      }
    };
    exports.MinMaxLengthCheckTransformer = MinMaxLengthCheckTransformer;
    var MinMaxValueTransformer = class _MinMaxValueTransformer extends ProducerTransformer {
      constructor(graph, sourceTypeRef, consumer, minimum, maximum) {
        super("min-max-value-check", graph, sourceTypeRef, consumer);
        this.minimum = minimum;
        this.maximum = maximum;
      }
      get canFail() {
        return true;
      }
      reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === void 0) {
          return new _MinMaxValueTransformer(this.graph, targetTypeRef, continuationTransformer, this.minimum, this.maximum);
        } else {
          return this.consumer.reverse(targetTypeRef, new _MinMaxValueTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.minimum, this.maximum));
        }
      }
      reconstitute(builder) {
        return new _MinMaxValueTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), (0, collection_utils_1.definedMap)(this.consumer, (xfer) => xfer.reconstitute(builder)), this.minimum, this.maximum);
      }
      equals(other) {
        if (!super.equals(other))
          return false;
        return other instanceof _MinMaxValueTransformer && this.minimum === other.minimum && this.maximum === other.maximum;
      }
    };
    exports.MinMaxValueTransformer = MinMaxValueTransformer;
    var Transformation = class _Transformation {
      constructor(_graph, _targetTypeRef, transformer) {
        this._graph = _graph;
        this._targetTypeRef = _targetTypeRef;
        this.transformer = transformer;
      }
      get sourceType() {
        return this.transformer.sourceType;
      }
      get targetType() {
        return (0, TypeGraph_1.derefTypeRef)(this._targetTypeRef, this._graph);
      }
      get reverse() {
        return new _Transformation(this._graph, this.transformer.sourceTypeRef, this.transformer.reverse(this._targetTypeRef, void 0));
      }
      getChildren() {
        return this.transformer.getChildren().add(this.targetType);
      }
      reconstitute(builder) {
        return new _Transformation(builder.typeGraph, builder.reconstituteTypeRef(this._targetTypeRef), this.transformer.reconstitute(builder));
      }
      equals(other) {
        if (!(other instanceof _Transformation))
          return false;
        return this._targetTypeRef === other._targetTypeRef && this.transformer.equals(other.transformer);
      }
      hashCode() {
        let h = (0, collection_utils_1.hashCodeOf)(this._targetTypeRef);
        h = (0, collection_utils_1.addHashCode)(h, this.transformer.hashCode());
        return h;
      }
      debugPrint() {
        this.transformer.debugPrint(0);
        console.log(`-> ${debugStringForType(this.targetType)}`);
      }
    };
    exports.Transformation = Transformation;
    var TransformationTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("transformation");
      }
      appliesToTypeKind(_kind) {
        return true;
      }
      get inIdentity() {
        return true;
      }
      children(xf) {
        return xf.getChildren();
      }
      reconstitute(builder, xf) {
        return xf.reconstitute(builder);
      }
      stringify(_) {
        return "transformation";
      }
    };
    exports.transformationTypeAttributeKind = new TransformationTypeAttributeKind();
    function transformationForType(t) {
      return exports.transformationTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
    exports.transformationForType = transformationForType;
    function followTargetType(t) {
      for (; ; ) {
        const xf = transformationForType(t);
        if (xf === void 0)
          return t;
        t = xf.targetType;
      }
    }
    exports.followTargetType = followTargetType;
  }
});

// node_modules/quicktype-core/dist/GatherNames.js
var require_GatherNames = __commonJS({
  "node_modules/quicktype-core/dist/GatherNames.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gatherNames = void 0;
    var collection_utils_1 = require_dist();
    var pluralize = __importStar(require_pluralize());
    var TypeNames_1 = require_TypeNames();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var UniqueQueue = class {
      constructor() {
        this._present = /* @__PURE__ */ new Set();
        this._queue = [];
        this._front = 0;
      }
      get size() {
        return this._queue.length - this._front;
      }
      get isEmpty() {
        return this.size <= 0;
      }
      push(v) {
        if (this._present.has(v))
          return;
        this._queue.push(v);
        this._present.add(v);
      }
      unshift() {
        (0, Support_1.assert)(!this.isEmpty, "Trying to unshift from an empty queue");
        const v = this._queue[this._front];
        if (v === void 0) {
          return (0, Support_1.panic)("Value should have been present in queue");
        }
        this._queue[this._front] = void 0;
        this._front += 1;
        this._present.delete(v);
        if (this._front > this.size) {
          this._queue = this._queue.slice(this._front);
          this._front = 0;
        }
        return v;
      }
    };
    function gatherNames(graph, destructive, debugPrint) {
      function setNames(t, tn) {
        graph.attributeStore.set(TypeNames_1.namesTypeAttributeKind, t, tn);
      }
      if (destructive) {
        for (const t of graph.allTypesUnordered()) {
          if (t.hasNames) {
            setNames(t, t.getNames().clearInferred());
          }
        }
      }
      const queue = new UniqueQueue();
      const namesForType = /* @__PURE__ */ new Map();
      function addNames(t, names) {
        if (t.hasNames) {
          const originalNames = t.getNames();
          if (!originalNames.areInferred) {
            names = originalNames.names;
          }
        }
        const oldNames = namesForType.get(t);
        if (oldNames === null)
          return;
        let newNames;
        if (oldNames === void 0) {
          newNames = names;
        } else if (names === null) {
          newNames = null;
        } else {
          newNames = (0, collection_utils_1.setUnion)(oldNames, names);
        }
        if (newNames !== null && newNames.size >= TypeNames_1.tooManyNamesThreshold) {
          newNames = null;
        }
        namesForType.set(t, newNames);
        const transformation = (0, Transformers_1.transformationForType)(t);
        if (transformation !== void 0) {
          addNames(transformation.targetType, names);
        }
        if (oldNames !== void 0 && newNames !== null) {
          if (oldNames.size === newNames.size) {
            return;
          }
        } else if (oldNames === newNames) {
          return;
        }
        queue.push(t);
      }
      for (const [name, t] of graph.topLevels) {
        addNames(t, /* @__PURE__ */ new Set([name]));
      }
      while (!queue.isEmpty) {
        const t = queue.unshift();
        const names = (0, Support_1.defined)(namesForType.get(t));
        if (t instanceof Type_1.ObjectType) {
          const properties = t.getSortedProperties();
          for (const [propertyName, property] of properties) {
            addNames(property.type, /* @__PURE__ */ new Set([propertyName]));
          }
          const values = t.getAdditionalProperties();
          if (values !== void 0) {
            addNames(values, names === null ? null : (0, collection_utils_1.setMap)(names, pluralize.singular));
          }
        } else {
          (0, TypeUtils_1.matchCompoundType)(t, (arrayType) => {
            addNames(arrayType.items, names === null ? null : (0, collection_utils_1.setMap)(names, pluralize.singular));
          }, (_classType) => (0, Support_1.panic)("We handled this above"), (_mapType) => (0, Support_1.panic)("We handled this above"), (_objectType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
            const members = (0, collection_utils_1.setSortBy)(unionType.members, (member) => member.kind);
            for (const memberType of members) {
              addNames(memberType, names);
            }
          });
        }
      }
      if (debugPrint) {
        for (const t of graph.allTypesUnordered()) {
          const names = namesForType.get(t);
          if (names === void 0)
            return;
          const index = t.index;
          console.log(`${index}: ${names === null ? "*** too many ***" : Array.from(names).join(" ")}`);
        }
      }
      const directAlternativesForType = /* @__PURE__ */ new Map();
      const ancestorAlternativesForType = /* @__PURE__ */ new Map();
      const pairsProcessed = /* @__PURE__ */ new Map();
      function addAlternatives(existing, alternatives) {
        if (alternatives.length === 0) {
          return existing;
        }
        if (existing === void 0) {
          existing = /* @__PURE__ */ new Set();
        }
        existing = (0, collection_utils_1.setUnion)(existing, alternatives);
        if (existing.size < TypeNames_1.tooManyNamesThreshold) {
          return existing;
        }
        return null;
      }
      function processType(ancestor, t, alternativeSuffix) {
        const names = (0, Support_1.defined)(namesForType.get(t));
        let processedEntry = pairsProcessed.get(ancestor);
        if (processedEntry === void 0)
          processedEntry = /* @__PURE__ */ new Set();
        if (processedEntry.has(t))
          return;
        processedEntry.add(t);
        pairsProcessed.set(ancestor, processedEntry);
        const transformation = (0, Transformers_1.transformationForType)(t);
        if (transformation !== void 0) {
          processType(ancestor, transformation.targetType, alternativeSuffix);
        }
        let ancestorAlternatives = ancestorAlternativesForType.get(t);
        let directAlternatives = directAlternativesForType.get(t);
        if (names === null) {
          ancestorAlternatives = null;
          directAlternatives = null;
        } else {
          if (ancestor !== void 0 && ancestorAlternatives !== null) {
            const ancestorNames = namesForType.get(ancestor);
            if (ancestorNames === null) {
              ancestorAlternatives = null;
            } else if (ancestorNames !== void 0) {
              const alternatives = [];
              for (const name of names) {
                alternatives.push(...Array.from(ancestorNames).map((an) => `${an}_${name}`));
                alternatives.push(...Array.from(ancestorNames).map((an) => `${an}_${name}_${t.kind}`));
              }
              ancestorAlternatives = addAlternatives(ancestorAlternatives, alternatives);
            }
          }
          if (alternativeSuffix !== void 0 && directAlternatives !== null) {
            const alternatives = [];
            for (const name of names) {
              alternatives.push(`${name}_${alternativeSuffix}`);
            }
            directAlternatives = addAlternatives(directAlternatives, alternatives);
          }
        }
        if (ancestorAlternatives !== void 0) {
          ancestorAlternativesForType.set(t, ancestorAlternatives);
        }
        if (directAlternatives !== void 0) {
          directAlternativesForType.set(t, directAlternatives);
        }
        if (t instanceof Type_1.ObjectType) {
          const properties = t.getSortedProperties();
          for (const [, property] of properties) {
            processType(t, property.type, void 0);
          }
          const values = t.getAdditionalProperties();
          if (values !== void 0) {
            processType(properties.size === 0 ? ancestor : t, values, "value");
          }
        } else {
          (0, TypeUtils_1.matchCompoundType)(t, (arrayType) => {
            processType(ancestor, arrayType.items, "element");
          }, (_classType) => (0, Support_1.panic)("We handled this above"), (_mapType) => (0, Support_1.panic)("We handled this above"), (_objectType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
            const members = (0, collection_utils_1.setSortBy)(unionType.members, (member) => member.kind);
            const unionHasGivenName = unionType.hasNames && !unionType.getNames().areInferred;
            const unionIsAncestor = unionHasGivenName || (0, TypeUtils_1.nullableFromUnion)(unionType) === null;
            const ancestorForMembers = unionIsAncestor ? unionType : ancestor;
            for (const memberType of members) {
              processType(ancestorForMembers, memberType, void 0);
            }
          });
        }
      }
      for (const [, t] of graph.topLevels) {
        processType(void 0, t, void 0);
      }
      for (const t of graph.allTypesUnordered()) {
        const names = namesForType.get(t);
        if (names === void 0)
          continue;
        if (names === null) {
          directAlternativesForType.set(t, null);
          continue;
        }
        let alternatives = directAlternativesForType.get(t);
        if (alternatives === null)
          continue;
        if (alternatives === void 0) {
          alternatives = /* @__PURE__ */ new Set();
        }
        alternatives = (0, collection_utils_1.setUnion)(alternatives, (0, collection_utils_1.setMap)(names, (name) => `${name}_${t.kind}`));
        directAlternativesForType.set(t, alternatives);
      }
      for (const t of graph.allTypesUnordered()) {
        const names = namesForType.get(t);
        if (names === void 0)
          continue;
        let typeNames;
        if (names === null) {
          typeNames = new TypeNames_1.TooManyTypeNames(1);
        } else {
          const ancestorAlternatives = ancestorAlternativesForType.get(t);
          const directAlternatives = directAlternativesForType.get(t);
          let alternatives;
          if (ancestorAlternatives === null && directAlternatives === null) {
            alternatives = void 0;
          } else {
            if (directAlternatives !== null && directAlternatives !== void 0) {
              alternatives = directAlternatives;
            } else {
              alternatives = /* @__PURE__ */ new Set();
            }
            if (ancestorAlternatives !== null && ancestorAlternatives !== void 0) {
              alternatives = (0, collection_utils_1.setUnion)(alternatives, ancestorAlternatives);
            }
          }
          typeNames = TypeNames_1.TypeNames.makeWithDistance(names, alternatives, destructive ? 1 : 10);
        }
        setNames(t, t.hasNames ? t.getNames().add([typeNames]) : typeNames);
      }
    }
    exports.gatherNames = gatherNames;
  }
});

// node_modules/quicktype-core/dist/attributes/AccessorNames.js
var require_AccessorNames = __commonJS({
  "node_modules/quicktype-core/dist/attributes/AccessorNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accessorNamesAttributeProducer = exports.makeAccessorNames = exports.unionMemberName = exports.makeUnionMemberNamesAttribute = exports.unionMemberNamesTypeAttributeKind = exports.makeUnionIdentifierAttribute = exports.unionIdentifierTypeAttributeKind = exports.getAccessorName = exports.enumCaseNames = exports.objectPropertyNames = exports.lookupKey = exports.accessorNamesTypeAttributeKind = void 0;
    var collection_utils_1 = require_dist();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    var AccessorNamesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("accessorNames");
      }
      makeInferred(_) {
        return void 0;
      }
    };
    exports.accessorNamesTypeAttributeKind = new AccessorNamesTypeAttributeKind();
    function getFromEntry(entry, language) {
      if (typeof entry === "string")
        return [entry, false];
      const maybeForLanguage = entry.get(language);
      if (maybeForLanguage !== void 0)
        return [maybeForLanguage, true];
      const maybeWildcard = entry.get("*");
      if (maybeWildcard !== void 0)
        return [maybeWildcard, false];
      return void 0;
    }
    function lookupKey(accessors, key, language) {
      const entry = accessors.get(key);
      if (entry === void 0)
        return void 0;
      return getFromEntry(entry, language);
    }
    exports.lookupKey = lookupKey;
    function objectPropertyNames(o, language) {
      const accessors = exports.accessorNamesTypeAttributeKind.tryGetInAttributes(o.getAttributes());
      const map2 = o.getProperties();
      if (accessors === void 0)
        return (0, collection_utils_1.mapMap)(map2, (_) => void 0);
      return (0, collection_utils_1.mapMap)(map2, (_cp, n) => lookupKey(accessors, n, language));
    }
    exports.objectPropertyNames = objectPropertyNames;
    function enumCaseNames(e, language) {
      const accessors = exports.accessorNamesTypeAttributeKind.tryGetInAttributes(e.getAttributes());
      if (accessors === void 0)
        return (0, collection_utils_1.mapMap)(e.cases.entries(), (_) => void 0);
      return (0, collection_utils_1.mapMap)(e.cases.entries(), (c) => lookupKey(accessors, c, language));
    }
    exports.enumCaseNames = enumCaseNames;
    function getAccessorName(names, original) {
      const maybeName = names.get(original);
      if (maybeName === void 0)
        return [void 0, false];
      return maybeName;
    }
    exports.getAccessorName = getAccessorName;
    var UnionIdentifierTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("unionIdentifier");
      }
      combine(arr) {
        return (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), arr);
      }
      makeInferred(_) {
        return /* @__PURE__ */ new Set();
      }
    };
    exports.unionIdentifierTypeAttributeKind = new UnionIdentifierTypeAttributeKind();
    var nextUnionIdentifier = 0;
    function makeUnionIdentifierAttribute() {
      const attributes = exports.unionIdentifierTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([nextUnionIdentifier]));
      nextUnionIdentifier += 1;
      return attributes;
    }
    exports.makeUnionIdentifierAttribute = makeUnionIdentifierAttribute;
    var UnionMemberNamesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("unionMemberNames");
      }
      combine(arr) {
        const result = /* @__PURE__ */ new Map();
        for (const m of arr) {
          (0, collection_utils_1.mapMergeInto)(result, m);
        }
        return result;
      }
    };
    exports.unionMemberNamesTypeAttributeKind = new UnionMemberNamesTypeAttributeKind();
    function makeUnionMemberNamesAttribute(unionAttributes, entry) {
      const identifiers = (0, Support_1.defined)(exports.unionIdentifierTypeAttributeKind.tryGetInAttributes(unionAttributes));
      const map2 = (0, collection_utils_1.mapFromIterable)(identifiers, (_) => entry);
      return exports.unionMemberNamesTypeAttributeKind.makeAttributes(map2);
    }
    exports.makeUnionMemberNamesAttribute = makeUnionMemberNamesAttribute;
    function unionMemberName(u, member, language) {
      const identifiers = exports.unionIdentifierTypeAttributeKind.tryGetInAttributes(u.getAttributes());
      if (identifiers === void 0)
        return [void 0, false];
      const memberNames = exports.unionMemberNamesTypeAttributeKind.tryGetInAttributes(member.getAttributes());
      if (memberNames === void 0)
        return [void 0, false];
      const names = /* @__PURE__ */ new Set();
      const fixedNames = /* @__PURE__ */ new Set();
      for (const i of identifiers) {
        const maybeEntry = memberNames.get(i);
        if (maybeEntry === void 0)
          continue;
        const maybeName = getFromEntry(maybeEntry, language);
        if (maybeName === void 0)
          continue;
        const [name, isNameFixed] = maybeName;
        if (isNameFixed) {
          fixedNames.add(name);
        } else {
          names.add(name);
        }
      }
      let size;
      let isFixed;
      let first = (0, collection_utils_1.iterableFirst)(fixedNames);
      if (first !== void 0) {
        size = fixedNames.size;
        isFixed = true;
      } else {
        first = (0, collection_utils_1.iterableFirst)(names);
        if (first === void 0)
          return [void 0, false];
        size = names.size;
        isFixed = false;
      }
      (0, Messages_1.messageAssert)(size === 1, "SchemaMoreThanOneUnionMemberName", { names: Array.from(names) });
      return [first, isFixed];
    }
    exports.unionMemberName = unionMemberName;
    function isAccessorEntry(x) {
      if (typeof x === "string") {
        return true;
      }
      return (0, Support_1.isStringMap)(x, (v) => typeof v === "string");
    }
    function makeAccessorEntry(ae) {
      if (typeof ae === "string")
        return ae;
      return (0, collection_utils_1.mapFromObject)(ae);
    }
    function makeAccessorNames(x) {
      const stringMap = (0, Support_1.checkStringMap)(x, isAccessorEntry);
      return (0, collection_utils_1.mapMap)((0, collection_utils_1.mapFromObject)(stringMap), makeAccessorEntry);
    }
    exports.makeAccessorNames = makeAccessorNames;
    function accessorNamesAttributeProducer(schema4, canonicalRef, _types, cases) {
      if (typeof schema4 !== "object")
        return void 0;
      const maybeAccessors = schema4["qt-accessors"];
      if (maybeAccessors === void 0)
        return void 0;
      if (cases === void 0) {
        return { forType: exports.accessorNamesTypeAttributeKind.makeAttributes(makeAccessorNames(maybeAccessors)) };
      } else {
        const identifierAttribute = makeUnionIdentifierAttribute();
        const accessors = (0, Support_1.checkArray)(maybeAccessors, isAccessorEntry);
        (0, Messages_1.messageAssert)(cases.length === accessors.length, "SchemaWrongAccessorEntryArrayLength", {
          operation: "oneOf",
          ref: canonicalRef.push("oneOf")
        });
        const caseAttributes = accessors.map((accessor) => makeUnionMemberNamesAttribute(identifierAttribute, makeAccessorEntry(accessor)));
        return { forUnion: identifierAttribute, forCases: caseAttributes };
      }
    }
    exports.accessorNamesAttributeProducer = accessorNamesAttributeProducer;
  }
});

// node_modules/quicktype-core/dist/attributes/Constraints.js
var require_Constraints = __commonJS({
  "node_modules/quicktype-core/dist/attributes/Constraints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.patternForType = exports.patternAttributeProducer = exports.patternTypeAttributeKind = exports.PatternTypeAttributeKind = exports.minMaxLengthForType = exports.minMaxValueForType = exports.minMaxLengthAttributeProducer = exports.minMaxAttributeProducer = exports.minMaxLengthTypeAttributeKind = exports.minMaxTypeAttributeKind = exports.MinMaxConstraintTypeAttributeKind = void 0;
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var TypeAttributes_1 = require_TypeAttributes();
    function checkMinMaxConstraint(minmax) {
      const [min, max] = minmax;
      if (typeof min === "number" && typeof max === "number" && min > max) {
        return (0, Messages_1.messageError)("MiscInvalidMinMaxConstraint", { min, max });
      }
      if (min === void 0 && max === void 0) {
        return void 0;
      }
      return minmax;
    }
    var MinMaxConstraintTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor(name, _typeKinds, _minSchemaProperty, _maxSchemaProperty) {
        super(name);
        this._typeKinds = _typeKinds;
        this._minSchemaProperty = _minSchemaProperty;
        this._maxSchemaProperty = _maxSchemaProperty;
      }
      get inIdentity() {
        return true;
      }
      combine(arr) {
        (0, Support_1.assert)(arr.length > 0);
        let [min, max] = arr[0];
        for (let i = 1; i < arr.length; i++) {
          const [otherMin, otherMax] = arr[i];
          if (typeof min === "number" && typeof otherMin === "number") {
            min = Math.min(min, otherMin);
          } else {
            min = void 0;
          }
          if (typeof max === "number" && typeof otherMax === "number") {
            max = Math.max(max, otherMax);
          } else {
            max = void 0;
          }
        }
        return checkMinMaxConstraint([min, max]);
      }
      intersect(arr) {
        (0, Support_1.assert)(arr.length > 0);
        let [min, max] = arr[0];
        for (let i = 1; i < arr.length; i++) {
          const [otherMin, otherMax] = arr[i];
          if (typeof min === "number" && typeof otherMin === "number") {
            min = Math.max(min, otherMin);
          } else if (min === void 0) {
            min = otherMin;
          }
          if (typeof max === "number" && typeof otherMax === "number") {
            max = Math.min(max, otherMax);
          } else if (max === void 0) {
            max = otherMax;
          }
        }
        return checkMinMaxConstraint([min, max]);
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema4, t, attr) {
        if (this._typeKinds.has(t.kind))
          return;
        const [min, max] = attr;
        if (min !== void 0) {
          schema4[this._minSchemaProperty] = min;
        }
        if (max !== void 0) {
          schema4[this._maxSchemaProperty] = max;
        }
      }
      stringify([min, max]) {
        return `${min}-${max}`;
      }
    };
    exports.MinMaxConstraintTypeAttributeKind = MinMaxConstraintTypeAttributeKind;
    exports.minMaxTypeAttributeKind = new MinMaxConstraintTypeAttributeKind("minMax", /* @__PURE__ */ new Set(["integer", "double"]), "minimum", "maximum");
    exports.minMaxLengthTypeAttributeKind = new MinMaxConstraintTypeAttributeKind("minMaxLength", /* @__PURE__ */ new Set(["string"]), "minLength", "maxLength");
    function producer(schema4, minProperty, maxProperty) {
      if (!(typeof schema4 === "object"))
        return void 0;
      let min = void 0;
      let max = void 0;
      if (typeof schema4[minProperty] === "number") {
        min = schema4[minProperty];
      }
      if (typeof schema4[maxProperty] === "number") {
        max = schema4[maxProperty];
      }
      if (min === void 0 && max === void 0)
        return void 0;
      return [min, max];
    }
    function minMaxAttributeProducer(schema4, _ref, types) {
      if (!types.has("number") && !types.has("integer"))
        return void 0;
      const maybeMinMax = producer(schema4, "minimum", "maximum");
      if (maybeMinMax === void 0)
        return void 0;
      return { forNumber: exports.minMaxTypeAttributeKind.makeAttributes(maybeMinMax) };
    }
    exports.minMaxAttributeProducer = minMaxAttributeProducer;
    function minMaxLengthAttributeProducer(schema4, _ref, types) {
      if (!types.has("string"))
        return void 0;
      const maybeMinMaxLength = producer(schema4, "minLength", "maxLength");
      if (maybeMinMaxLength === void 0)
        return void 0;
      return { forString: exports.minMaxLengthTypeAttributeKind.makeAttributes(maybeMinMaxLength) };
    }
    exports.minMaxLengthAttributeProducer = minMaxLengthAttributeProducer;
    function minMaxValueForType(t) {
      return exports.minMaxTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
    exports.minMaxValueForType = minMaxValueForType;
    function minMaxLengthForType(t) {
      return exports.minMaxLengthTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
    exports.minMaxLengthForType = minMaxLengthForType;
    var PatternTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("pattern");
      }
      get inIdentity() {
        return true;
      }
      combine(arr) {
        (0, Support_1.assert)(arr.length > 0);
        return arr.map((p) => `(${p})`).join("|");
      }
      intersect(_arr) {
        return void 0;
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema4, t, attr) {
        if (t.kind !== "string")
          return;
        schema4.pattern = attr;
      }
    };
    exports.PatternTypeAttributeKind = PatternTypeAttributeKind;
    exports.patternTypeAttributeKind = new PatternTypeAttributeKind();
    function patternAttributeProducer(schema4, _ref, types) {
      if (!(typeof schema4 === "object"))
        return void 0;
      if (!types.has("string"))
        return void 0;
      const patt = schema4.pattern;
      if (typeof patt !== "string")
        return void 0;
      return { forString: exports.patternTypeAttributeKind.makeAttributes(patt) };
    }
    exports.patternAttributeProducer = patternAttributeProducer;
    function patternForType(t) {
      return exports.patternTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    }
    exports.patternForType = patternForType;
  }
});

// node_modules/quicktype-core/dist/attributes/EnumValues.js
var require_EnumValues = __commonJS({
  "node_modules/quicktype-core/dist/attributes/EnumValues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumValuesAttributeProducer = exports.enumCaseValues = exports.enumValuesTypeAttributeKind = void 0;
    var collection_utils_1 = require_dist();
    var AccessorNames_1 = require_AccessorNames();
    var TypeAttributes_1 = require_TypeAttributes();
    var EnumValuesTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("enumValues");
      }
      makeInferred(_) {
        return void 0;
      }
    };
    exports.enumValuesTypeAttributeKind = new EnumValuesTypeAttributeKind();
    function enumCaseValues(e, language) {
      const enumValues = exports.enumValuesTypeAttributeKind.tryGetInAttributes(e.getAttributes());
      if (enumValues === void 0)
        return (0, collection_utils_1.mapMap)(e.cases.entries(), (_) => void 0);
      return (0, collection_utils_1.mapMap)(e.cases.entries(), (c) => (0, AccessorNames_1.lookupKey)(enumValues, c, language));
    }
    exports.enumCaseValues = enumCaseValues;
    function enumValuesAttributeProducer(schema4, _canonicalRef, _types) {
      if (typeof schema4 !== "object")
        return void 0;
      const maybeEnumValues = schema4["qt-enum-values"];
      if (maybeEnumValues === void 0)
        return void 0;
      return { forType: exports.enumValuesTypeAttributeKind.makeAttributes((0, AccessorNames_1.makeAccessorNames)(maybeEnumValues)) };
    }
    exports.enumValuesAttributeProducer = enumValuesAttributeProducer;
  }
});

// node_modules/quicktype-core/dist/input/JSONSchemaStore.js
var require_JSONSchemaStore = __commonJS({
  "node_modules/quicktype-core/dist/input/JSONSchemaStore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONSchemaStore = void 0;
    var Support_1 = require_Support();
    var JSONSchemaStore = class {
      constructor() {
        this._schemas = /* @__PURE__ */ new Map();
      }
      add(address, schema4) {
        (0, Support_1.assert)(!this._schemas.has(address), "Cannot set a schema for an address twice");
        this._schemas.set(address, schema4);
      }
      get(address, debugPrint) {
        return __awaiter(this, void 0, void 0, function* () {
          let schema4 = this._schemas.get(address);
          if (schema4 !== void 0) {
            return schema4;
          }
          if (debugPrint) {
            console.log(`trying to fetch ${address}`);
          }
          try {
            schema4 = yield this.fetch(address);
          } catch (e) {
          }
          if (schema4 === void 0) {
            if (debugPrint) {
              console.log(`couldn't fetch ${address}`);
            }
            return void 0;
          }
          if (debugPrint) {
            console.log(`successully fetched ${address}`);
          }
          this.add(address, schema4);
          return schema4;
        });
      }
    };
    exports.JSONSchemaStore = JSONSchemaStore;
  }
});

// node_modules/quicktype-core/dist/input/JSONSchemaInput.js
var require_JSONSchemaInput = __commonJS({
  "node_modules/quicktype-core/dist/input/JSONSchemaInput.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONSchemaInput = exports.schemaTypeDict = exports.Ref = exports.PathElementKind = void 0;
    var collection_utils_1 = require_dist();
    var urijs_1 = __importDefault(require_URI());
    var AccessorNames_1 = require_AccessorNames();
    var Constraints_1 = require_Constraints();
    var Description_1 = require_Description();
    var EnumValues_1 = require_EnumValues();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var TypeNames_1 = require_TypeNames();
    var URIAttributes_1 = require_URIAttributes();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var JSONSchemaStore_1 = require_JSONSchemaStore();
    var PathElementKind;
    (function(PathElementKind2) {
      PathElementKind2[PathElementKind2["Root"] = 1] = "Root";
      PathElementKind2[PathElementKind2["KeyOrIndex"] = 2] = "KeyOrIndex";
      PathElementKind2[PathElementKind2["Type"] = 3] = "Type";
      PathElementKind2[PathElementKind2["Object"] = 4] = "Object";
    })(PathElementKind = exports.PathElementKind || (exports.PathElementKind = {}));
    function keyOrIndex(pe) {
      if (pe.kind !== PathElementKind.KeyOrIndex)
        return void 0;
      return pe.key;
    }
    function pathElementEquals(a, b) {
      if (a.kind !== b.kind)
        return false;
      if (a.kind === PathElementKind.Type && b.kind === PathElementKind.Type) {
        return a.index === b.index;
      }
      if (a.kind === PathElementKind.KeyOrIndex && b.kind === PathElementKind.KeyOrIndex) {
        return a.key === b.key;
      }
      return true;
    }
    function withRef(refOrLoc, props) {
      const ref = typeof refOrLoc === "function" ? refOrLoc() : refOrLoc instanceof Ref ? refOrLoc : refOrLoc.canonicalRef;
      return Object.assign({ ref }, props !== null && props !== void 0 ? props : {});
    }
    function checkJSONSchemaObject(x, refOrLoc) {
      if (Array.isArray(x)) {
        return (0, Messages_1.messageError)("SchemaArrayIsInvalidSchema", withRef(refOrLoc));
      }
      if (x === null) {
        return (0, Messages_1.messageError)("SchemaNullIsInvalidSchema", withRef(refOrLoc));
      }
      if (typeof x !== "object") {
        return (0, Messages_1.messageError)("SchemaInvalidJSONSchemaType", withRef(refOrLoc, { type: typeof x }));
      }
      return x;
    }
    function checkJSONSchema(x, refOrLoc) {
      if (typeof x === "boolean")
        return x;
      return checkJSONSchemaObject(x, refOrLoc);
    }
    var numberRegexp = new RegExp("^[0-9]+$");
    function normalizeURI(uri) {
      if (typeof uri === "string") {
        uri = new urijs_1.default(uri);
      }
      return new urijs_1.default(urijs_1.default.decode(uri.clone().normalize().toString()));
    }
    var Ref = class _Ref {
      static root(address) {
        const uri = (0, collection_utils_1.definedMap)(address, (a) => new urijs_1.default(a));
        return new _Ref(uri, []);
      }
      static parsePath(path) {
        const elements = [];
        if (path.startsWith("/")) {
          elements.push({ kind: PathElementKind.Root });
          path = path.slice(1);
        }
        if (path !== "") {
          const parts = path.split("/");
          parts.forEach((part) => elements.push({ kind: PathElementKind.KeyOrIndex, key: part }));
        }
        return elements;
      }
      static parseURI(uri, destroyURI = false) {
        if (!destroyURI) {
          uri = uri.clone();
        }
        let path = uri.fragment();
        uri.fragment("");
        if ((uri.host() !== "" || uri.filename() !== "") && path === "") {
          path = "/";
        }
        const elements = _Ref.parsePath(path);
        return new _Ref(uri, elements);
      }
      static parse(ref) {
        return _Ref.parseURI(new urijs_1.default(ref), true);
      }
      constructor(addressURI, path) {
        this.path = path;
        if (addressURI !== void 0) {
          (0, Support_1.assert)(addressURI.fragment() === "", `Ref URI with fragment is not allowed: ${addressURI.toString()}`);
          this.addressURI = normalizeURI(addressURI);
        } else {
          this.addressURI = void 0;
        }
      }
      get hasAddress() {
        return this.addressURI !== void 0;
      }
      get address() {
        return (0, Support_1.defined)(this.addressURI).toString();
      }
      get isRoot() {
        return this.path.length === 1 && this.path[0].kind === PathElementKind.Root;
      }
      pushElement(pe) {
        const newPath = Array.from(this.path);
        newPath.push(pe);
        return new _Ref(this.addressURI, newPath);
      }
      push(...keys) {
        let ref = this;
        for (const key of keys) {
          ref = ref.pushElement({ kind: PathElementKind.KeyOrIndex, key });
        }
        return ref;
      }
      pushObject() {
        return this.pushElement({ kind: PathElementKind.Object });
      }
      pushType(index) {
        return this.pushElement({ kind: PathElementKind.Type, index });
      }
      resolveAgainst(base) {
        let addressURI = this.addressURI;
        if ((base === null || base === void 0 ? void 0 : base.addressURI) !== void 0) {
          addressURI = addressURI === void 0 ? base.addressURI : addressURI.absoluteTo(base.addressURI);
        }
        return new _Ref(addressURI, this.path);
      }
      get name() {
        const path = Array.from(this.path);
        for (; ; ) {
          const e = path.pop();
          if (e === void 0 || e.kind === PathElementKind.Root) {
            let name = this.addressURI !== void 0 ? this.addressURI.filename() : "";
            const suffix = this.addressURI !== void 0 ? this.addressURI.suffix() : "";
            if (name.length > suffix.length + 1) {
              name = name.slice(0, name.length - suffix.length - 1);
            }
            if (name === "") {
              return "Something";
            }
            return name;
          }
          switch (e.kind) {
            case PathElementKind.KeyOrIndex:
              if (numberRegexp.test(e.key)) {
                return e.key;
              }
              break;
            case PathElementKind.Type:
            case PathElementKind.Object:
              return (0, Support_1.panic)("We shouldn't try to get the name of Type or Object refs");
            default:
              return (0, Support_1.assertNever)(e);
          }
        }
      }
      get definitionName() {
        const pe = (0, collection_utils_1.arrayGetFromEnd)(this.path, 2);
        if (pe === void 0)
          return void 0;
        if (keyOrIndex(pe) === "definitions")
          return keyOrIndex((0, Support_1.defined)((0, collection_utils_1.arrayLast)(this.path)));
        return void 0;
      }
      toString() {
        function elementToString(e) {
          switch (e.kind) {
            case PathElementKind.Root:
              return "";
            case PathElementKind.Type:
              return `type/${e.index.toString()}`;
            case PathElementKind.Object:
              return "object";
            case PathElementKind.KeyOrIndex:
              return e.key;
            default:
              return (0, Support_1.assertNever)(e);
          }
        }
        const address = this.addressURI === void 0 ? "" : this.addressURI.toString();
        return address + "#" + this.path.map(elementToString).join("/");
      }
      lookup(local, path, root) {
        const refMaker = () => new _Ref(this.addressURI, path);
        const first = path[0];
        if (first === void 0) {
          return checkJSONSchema(local, refMaker);
        }
        const rest = path.slice(1);
        switch (first.kind) {
          case PathElementKind.Root:
            return this.lookup(root, rest, root);
          case PathElementKind.KeyOrIndex:
            const key = first.key;
            if (Array.isArray(local)) {
              if (!/^\d+$/.test(key)) {
                return (0, Messages_1.messageError)("SchemaCannotIndexArrayWithNonNumber", withRef(refMaker, { actual: key }));
              }
              const index = parseInt(first.key, 10);
              if (index >= local.length) {
                return (0, Messages_1.messageError)("SchemaIndexNotInArray", withRef(refMaker, { index }));
              }
              return this.lookup(local[index], rest, root);
            } else {
              if (!(0, collection_utils_1.hasOwnProperty)(local, key)) {
                return (0, Messages_1.messageError)("SchemaKeyNotInObject", withRef(refMaker, { key }));
              }
              return this.lookup(checkJSONSchemaObject(local, refMaker)[first.key], rest, root);
            }
          case PathElementKind.Type:
            return (0, Support_1.panic)('Cannot look up path that indexes "type"');
          case PathElementKind.Object:
            return (0, Support_1.panic)('Cannot look up path that indexes "object"');
          default:
            return (0, Support_1.assertNever)(first);
        }
      }
      lookupRef(root) {
        return this.lookup(root, this.path, root);
      }
      equals(other) {
        if (!(other instanceof _Ref))
          return false;
        if (this.addressURI !== void 0 && other.addressURI !== void 0) {
          if (!this.addressURI.equals(other.addressURI))
            return false;
        } else {
          if (this.addressURI === void 0 !== (other.addressURI === void 0))
            return false;
        }
        const l = this.path.length;
        if (l !== other.path.length)
          return false;
        for (let i = 0; i < l; i++) {
          if (!pathElementEquals(this.path[i], other.path[i]))
            return false;
        }
        return true;
      }
      hashCode() {
        let acc = (0, collection_utils_1.hashCodeOf)((0, collection_utils_1.definedMap)(this.addressURI, (u) => u.toString()));
        for (const pe of this.path) {
          acc = (0, collection_utils_1.addHashCode)(acc, pe.kind);
          switch (pe.kind) {
            case PathElementKind.Type:
              acc = (0, collection_utils_1.addHashCode)(acc, pe.index);
              break;
            case PathElementKind.KeyOrIndex:
              acc = (0, collection_utils_1.addHashCode)(acc, (0, collection_utils_1.hashString)(pe.key));
              break;
            default:
              break;
          }
        }
        return acc;
      }
    };
    exports.Ref = Ref;
    var Location = class _Location {
      constructor(canonicalRef, virtualRef, haveID = false) {
        this.haveID = haveID;
        this.canonicalRef = canonicalRef;
        this.virtualRef = virtualRef !== null && virtualRef !== void 0 ? virtualRef : canonicalRef;
      }
      updateWithID(id) {
        if (typeof id !== "string")
          return this;
        const parsed = Ref.parse(id);
        const virtual = this.haveID ? parsed.resolveAgainst(this.virtualRef) : parsed;
        if (!this.haveID) {
          (0, Messages_1.messageAssert)(virtual.hasAddress, "SchemaIDMustHaveAddress", withRef(this, { id }));
        }
        return new _Location(this.canonicalRef, virtual, true);
      }
      push(...keys) {
        return new _Location(this.canonicalRef.push(...keys), this.virtualRef.push(...keys), this.haveID);
      }
      pushObject() {
        return new _Location(this.canonicalRef.pushObject(), this.virtualRef.pushObject(), this.haveID);
      }
      pushType(index) {
        return new _Location(this.canonicalRef.pushType(index), this.virtualRef.pushType(index), this.haveID);
      }
      toString() {
        return `${this.virtualRef.toString()} (${this.canonicalRef.toString()})`;
      }
    };
    var Canonizer = class {
      constructor(_ctx) {
        this._ctx = _ctx;
        this._map = new collection_utils_1.EqualityMap();
        this._schemaAddressesAdded = /* @__PURE__ */ new Set();
      }
      addIDs(schema4, loc) {
        if (schema4 === null)
          return;
        if (Array.isArray(schema4)) {
          for (let i = 0; i < schema4.length; i++) {
            this.addIDs(schema4[i], loc.push(i.toString()));
          }
          return;
        }
        if (typeof schema4 !== "object") {
          return;
        }
        const locWithoutID = loc;
        const maybeID = "$id" in schema4 ? schema4.$id : void 0;
        if (typeof maybeID === "string") {
          loc = loc.updateWithID(maybeID);
        }
        if (loc.haveID) {
          if (this._ctx.debugPrintSchemaResolving) {
            console.log(`adding mapping ${loc.toString()}`);
          }
          this._map.set(loc.virtualRef, locWithoutID);
        }
        for (const property of Object.getOwnPropertyNames(schema4)) {
          this.addIDs(schema4[property], loc.push(property));
        }
      }
      addSchema(schema4, address) {
        if (this._schemaAddressesAdded.has(address))
          return false;
        this.addIDs(schema4, new Location(Ref.root(address), Ref.root(void 0)));
        this._schemaAddressesAdded.add(address);
        return true;
      }
      // Returns: Canonical ref
      canonize(base, ref) {
        const virtual = ref.resolveAgainst(base.virtualRef);
        const loc = this._map.get(virtual);
        if (loc !== void 0) {
          return loc;
        }
        const canonicalRef = virtual.addressURI === void 0 ? new Ref(base.canonicalRef.addressURI, virtual.path) : virtual;
        return new Location(canonicalRef, new Ref(void 0, virtual.path));
      }
    };
    function checkTypeList(typeOrTypes, loc) {
      let set2;
      if (typeof typeOrTypes === "string") {
        set2 = /* @__PURE__ */ new Set([typeOrTypes]);
      } else if (Array.isArray(typeOrTypes)) {
        const arr = [];
        for (const t of typeOrTypes) {
          if (typeof t !== "string") {
            return (0, Messages_1.messageError)("SchemaTypeElementMustBeString", withRef(loc, { element: t }));
          }
          arr.push(t);
        }
        set2 = new Set(arr);
      } else {
        return (0, Messages_1.messageError)("SchemaTypeMustBeStringOrStringArray", withRef(loc, { actual: typeOrTypes }));
      }
      (0, Messages_1.messageAssert)(set2.size > 0, "SchemaNoTypeSpecified", withRef(loc));
      const validTypes = ["null", "boolean", "object", "array", "number", "string", "integer"];
      const maybeInvalid = (0, collection_utils_1.iterableFind)(set2, (s) => !validTypes.includes(s));
      if (maybeInvalid !== void 0) {
        return (0, Messages_1.messageError)("SchemaInvalidType", withRef(loc, { type: maybeInvalid }));
      }
      return set2;
    }
    function checkRequiredArray(arr, loc) {
      if (!Array.isArray(arr)) {
        return (0, Messages_1.messageError)("SchemaRequiredMustBeStringOrStringArray", withRef(loc, { actual: arr }));
      }
      for (const e of arr) {
        if (typeof e !== "string") {
          return (0, Messages_1.messageError)("SchemaRequiredElementMustBeString", withRef(loc, { element: e }));
        }
      }
      return arr;
    }
    exports.schemaTypeDict = {
      null: true,
      boolean: true,
      string: true,
      integer: true,
      number: true,
      array: true,
      object: true
    };
    var schemaTypes = Object.getOwnPropertyNames(exports.schemaTypeDict);
    function typeKindForJSONSchemaFormat(format) {
      const target = (0, collection_utils_1.iterableFind)(Type_1.transformedStringTypeTargetTypeKindsMap, ([_, { jsonSchema }]) => jsonSchema === format);
      if (target === void 0)
        return void 0;
      return target[0];
    }
    function schemaFetchError(base, address) {
      if (base === void 0) {
        return (0, Messages_1.messageError)("SchemaFetchErrorTopLevel", { address });
      } else {
        return (0, Messages_1.messageError)("SchemaFetchError", { address, base: base.canonicalRef });
      }
    }
    var Resolver = class {
      constructor(_ctx, _store, _canonizer) {
        this._ctx = _ctx;
        this._store = _store;
        this._canonizer = _canonizer;
      }
      tryResolveVirtualRef(fetchBase, lookupBase, virtualRef) {
        return __awaiter(this, void 0, void 0, function* () {
          let didAdd = false;
          for (; ; ) {
            const loc = this._canonizer.canonize(fetchBase, virtualRef);
            const canonical = loc.canonicalRef;
            (0, Support_1.assert)(canonical.hasAddress, "Canonical ref can't be resolved without an address");
            const address = canonical.address;
            let schema4 = canonical.addressURI === void 0 ? void 0 : yield this._store.get(address, this._ctx.debugPrintSchemaResolving);
            if (schema4 === void 0) {
              return [void 0, loc];
            }
            if (this._canonizer.addSchema(schema4, address)) {
              (0, Support_1.assert)(!didAdd, "We can't add a schema twice");
              didAdd = true;
            } else {
              let lookupLoc = this._canonizer.canonize(lookupBase, virtualRef);
              if (fetchBase !== void 0) {
                lookupLoc = new Location(new Ref(loc.canonicalRef.addressURI, lookupLoc.canonicalRef.path), lookupLoc.virtualRef, lookupLoc.haveID);
              }
              return [lookupLoc.canonicalRef.lookupRef(schema4), lookupLoc];
            }
          }
        });
      }
      resolveVirtualRef(base, virtualRef) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._ctx.debugPrintSchemaResolving) {
            console.log(`resolving ${virtualRef.toString()} relative to ${base.toString()}`);
          }
          let result = yield this.tryResolveVirtualRef(base, base, virtualRef);
          let schema4 = result[0];
          if (schema4 !== void 0) {
            if (this._ctx.debugPrintSchemaResolving) {
              console.log(`resolved to ${result[1].toString()}`);
            }
            return [schema4, result[1]];
          }
          const altBase = new Location(base.canonicalRef, new Ref(base.canonicalRef.addressURI, base.virtualRef.path), base.haveID);
          result = yield this.tryResolveVirtualRef(altBase, base, virtualRef);
          schema4 = result[0];
          if (schema4 !== void 0) {
            if (this._ctx.debugPrintSchemaResolving) {
              console.log(`resolved to ${result[1].toString()}`);
            }
            return [schema4, result[1]];
          }
          return schemaFetchError(base, virtualRef.address);
        });
      }
      resolveTopLevelRef(ref) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.resolveVirtualRef(new Location(new Ref(ref.addressURI, [])), new Ref(void 0, ref.path));
        });
      }
    };
    function addTypesInSchema(resolver, typeBuilder, references, attributeProducers) {
      return __awaiter(this, void 0, void 0, function* () {
        let typeForCanonicalRef = new collection_utils_1.EqualityMap();
        function setTypeForLocation(loc, t) {
          const maybeRef = typeForCanonicalRef.get(loc.canonicalRef);
          if (maybeRef !== void 0) {
            (0, Support_1.assert)(maybeRef === t, "Trying to set path again to different type");
          }
          typeForCanonicalRef.set(loc.canonicalRef, t);
        }
        function makeObject(loc, attributes, properties, requiredArray, additionalProperties, sortKey = (k) => k.toLowerCase()) {
          return __awaiter(this, void 0, void 0, function* () {
            const required = new Set(requiredArray);
            const propertiesMap = (0, collection_utils_1.mapSortBy)((0, collection_utils_1.mapFromObject)(properties), (_, k) => sortKey(k));
            const props = yield (0, collection_utils_1.mapMapSync)(propertiesMap, (propSchema, propName) => __awaiter(this, void 0, void 0, function* () {
              const propLoc = loc.push("properties", propName);
              const t = yield toType(checkJSONSchema(propSchema, propLoc.canonicalRef), propLoc, (0, TypeNames_1.makeNamesTypeAttributes)(propName, true));
              const isOptional = !required.has(propName);
              return typeBuilder.makeClassProperty(t, isOptional);
            }));
            let additionalPropertiesType;
            if (additionalProperties === void 0 || additionalProperties === true) {
              additionalPropertiesType = typeBuilder.getPrimitiveType("any");
            } else if (additionalProperties === false) {
              additionalPropertiesType = void 0;
            } else {
              const additionalLoc = loc.push("additionalProperties");
              additionalPropertiesType = yield toType(checkJSONSchema(additionalProperties, additionalLoc.canonicalRef), additionalLoc, (0, TypeNames_1.singularizeTypeNames)(attributes));
            }
            const additionalRequired = (0, collection_utils_1.setSubtract)(required, props.keys());
            if (additionalRequired.size > 0) {
              const t = additionalPropertiesType;
              if (t === void 0) {
                return (0, Messages_1.messageError)("SchemaAdditionalTypesForbidRequired", withRef(loc));
              }
              const additionalProps = (0, collection_utils_1.mapFromIterable)(additionalRequired, (_name) => typeBuilder.makeClassProperty(t, false));
              (0, collection_utils_1.mapMergeInto)(props, additionalProps);
            }
            return typeBuilder.getUniqueObjectType(attributes, props, additionalPropertiesType);
          });
        }
        function convertToType(schema4, loc, typeAttributes) {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
            const enumArray = Array.isArray(schema4.enum) ? schema4.enum : void 0;
            const isConst = schema4.const !== void 0;
            const typeSet = (0, collection_utils_1.definedMap)(schema4.type, (t) => checkTypeList(t, loc));
            function isTypeIncluded(name) {
              var _a2;
              if (typeSet !== void 0 && !typeSet.has(name)) {
                return false;
              }
              if (enumArray !== void 0) {
                let predicate;
                switch (name) {
                  case "null":
                    predicate = (x) => x === null;
                    break;
                  case "integer":
                    predicate = (x) => typeof x === "number" && x === Math.floor(x);
                    break;
                  default:
                    predicate = (x) => typeof x === name;
                    break;
                }
                return enumArray.find(predicate) !== void 0;
              }
              if (isConst) {
                return name === ((_a2 = schema4.type) !== null && _a2 !== void 0 ? _a2 : typeof schema4.const);
              }
              return true;
            }
            const includedTypes = (0, collection_utils_1.setFilter)(schemaTypes, isTypeIncluded);
            let producedAttributesForNoCases = void 0;
            function forEachProducedAttribute(cases, f) {
              let attributes;
              if (cases === void 0 && producedAttributesForNoCases !== void 0) {
                attributes = producedAttributesForNoCases;
              } else {
                attributes = [];
                for (const producer of attributeProducers) {
                  const newAttributes = producer(schema4, loc.canonicalRef, includedTypes, cases);
                  if (newAttributes === void 0)
                    continue;
                  attributes.push(newAttributes);
                }
                if (cases === void 0) {
                  producedAttributesForNoCases = attributes;
                }
              }
              for (const a of attributes) {
                f(a);
              }
            }
            function combineProducedAttributes(f) {
              let result = TypeAttributes_1.emptyTypeAttributes;
              forEachProducedAttribute(void 0, (attr) => {
                const maybeAttributes = f(attr);
                if (maybeAttributes === void 0)
                  return;
                result = (0, TypeAttributes_1.combineTypeAttributes)("union", result, maybeAttributes);
              });
              return result;
            }
            function makeAttributes(attributes) {
              if (schema4.oneOf === void 0) {
                attributes = (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, combineProducedAttributes(({ forType, forUnion, forCases }) => {
                  (0, Support_1.assert)(forUnion === void 0 && forCases === void 0, "We can't have attributes for unions and cases if we don't have a union");
                  return forType;
                }));
              }
              return (0, TypeNames_1.modifyTypeNames)(attributes, (maybeTypeNames) => {
                const typeNames = (0, Support_1.defined)(maybeTypeNames);
                if (!typeNames.areInferred) {
                  return typeNames;
                }
                let title = schema4.title;
                if (typeof title !== "string") {
                  title = loc.canonicalRef.definitionName;
                }
                if (typeof title === "string") {
                  return TypeNames_1.TypeNames.make(/* @__PURE__ */ new Set([title]), /* @__PURE__ */ new Set(), schema4.$ref !== void 0);
                } else {
                  return typeNames.makeInferred();
                }
              });
            }
            typeAttributes = makeAttributes(typeAttributes);
            const inferredAttributes = (0, TypeAttributes_1.makeTypeAttributesInferred)(typeAttributes);
            function makeStringType(attributes) {
              const kind = typeKindForJSONSchemaFormat(schema4.format);
              if (kind === void 0) {
                return typeBuilder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted);
              } else {
                return typeBuilder.getPrimitiveType(kind, attributes);
              }
            }
            function makeArrayType() {
              return __awaiter(this, void 0, void 0, function* () {
                const singularAttributes = (0, TypeNames_1.singularizeTypeNames)(typeAttributes);
                const items = schema4.items;
                let itemType;
                if (Array.isArray(items)) {
                  const itemsLoc = loc.push("items");
                  const itemTypes = yield (0, collection_utils_1.arrayMapSync)(items, (item, i) => __awaiter(this, void 0, void 0, function* () {
                    const itemLoc = itemsLoc.push(i.toString());
                    return yield toType(checkJSONSchema(item, itemLoc.canonicalRef), itemLoc, singularAttributes);
                  }));
                  itemType = typeBuilder.getUnionType(TypeAttributes_1.emptyTypeAttributes, new Set(itemTypes));
                } else if (typeof items === "object") {
                  const itemsLoc = loc.push("items");
                  itemType = yield toType(checkJSONSchema(items, itemsLoc.canonicalRef), itemsLoc, singularAttributes);
                } else if (items !== void 0 && items !== true) {
                  return (0, Messages_1.messageError)("SchemaArrayItemsMustBeStringOrArray", withRef(loc, { actual: items }));
                } else {
                  itemType = typeBuilder.getPrimitiveType("any");
                }
                typeBuilder.addAttributes(itemType, singularAttributes);
                return typeBuilder.getArrayType(TypeAttributes_1.emptyTypeAttributes, itemType);
              });
            }
            function makeObjectType() {
              return __awaiter(this, void 0, void 0, function* () {
                let required;
                if (schema4.required === void 0 || typeof schema4.required === "boolean") {
                  required = [];
                } else {
                  required = Array.from(checkRequiredArray(schema4.required, loc));
                }
                let properties;
                if (schema4.properties === void 0) {
                  properties = {};
                } else {
                  properties = checkJSONSchemaObject(schema4.properties, loc.canonicalRef);
                }
                for (const p of Object.getOwnPropertyNames(properties)) {
                  if (properties[p].required === true && !required.includes(p)) {
                    required.push(p);
                  }
                }
                let additionalProperties = schema4.additionalProperties;
                if (additionalProperties === void 0 && typeof schema4.patternProperties === "object" && (0, collection_utils_1.hasOwnProperty)(schema4.patternProperties, ".*")) {
                  additionalProperties = schema4.patternProperties[".*"];
                }
                const objectAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", inferredAttributes, combineProducedAttributes(({ forObject }) => forObject));
                const order = schema4.quicktypePropertyOrder ? schema4.quicktypePropertyOrder : [];
                const orderKey = (propertyName) => {
                  const index = order.indexOf(propertyName);
                  return index !== -1 ? index : propertyName.toLowerCase();
                };
                return yield makeObject(loc, objectAttributes, properties, required, additionalProperties, orderKey);
              });
            }
            function makeTypesFromCases(cases, kind) {
              return __awaiter(this, void 0, void 0, function* () {
                const kindLoc = loc.push(kind);
                if (!Array.isArray(cases)) {
                  return (0, Messages_1.messageError)("SchemaSetOperationCasesIsNotArray", withRef(kindLoc, { operation: kind, cases }));
                }
                return yield (0, collection_utils_1.arrayMapSync)(cases, (t, index) => __awaiter(this, void 0, void 0, function* () {
                  const caseLoc = kindLoc.push(index.toString());
                  return yield toType(checkJSONSchema(t, caseLoc.canonicalRef), caseLoc, (0, TypeAttributes_1.makeTypeAttributesInferred)(typeAttributes));
                }));
              });
            }
            const intersectionType = typeBuilder.getUniqueIntersectionType(typeAttributes, void 0);
            setTypeForLocation(loc, intersectionType);
            function convertOneOrAnyOf(cases, kind) {
              return __awaiter(this, void 0, void 0, function* () {
                const typeRefs = yield makeTypesFromCases(cases, kind);
                let unionAttributes = (0, TypeAttributes_1.makeTypeAttributesInferred)(typeAttributes);
                if (kind === "oneOf") {
                  forEachProducedAttribute(cases, ({ forType, forUnion, forCases }) => {
                    if (forType !== void 0) {
                      typeBuilder.addAttributes(intersectionType, forType);
                    }
                    if (forUnion !== void 0) {
                      unionAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", unionAttributes, forUnion);
                    }
                    if (forCases !== void 0) {
                      (0, Support_1.assert)(forCases.length === typeRefs.length, "Number of case attributes doesn't match number of cases");
                      for (let i = 0; i < typeRefs.length; i++) {
                        typeBuilder.addAttributes(typeRefs[i], forCases[i]);
                      }
                    }
                  });
                }
                const unionType = typeBuilder.getUniqueUnionType(unionAttributes, void 0);
                typeBuilder.setSetOperationMembers(unionType, new Set(typeRefs));
                return unionType;
              });
            }
            const includeObject = enumArray === void 0 && !isConst && (typeSet === void 0 || typeSet.has("object"));
            const includeArray = enumArray === void 0 && !isConst && (typeSet === void 0 || typeSet.has("array"));
            const needStringEnum = includedTypes.has("string") && enumArray !== void 0 && enumArray.find((x) => typeof x === "string") !== void 0;
            const needUnion = typeSet !== void 0 || schema4.properties !== void 0 || schema4.additionalProperties !== void 0 || schema4.items !== void 0 || schema4.required !== void 0 || enumArray !== void 0 || isConst;
            const types = [];
            if (needUnion) {
              const unionTypes = [];
              const numberAttributes = combineProducedAttributes(({ forNumber }) => forNumber);
              for (const [name, kind] of [
                ["null", "null"],
                ["number", "double"],
                ["integer", "integer"],
                ["boolean", "bool"]
              ]) {
                if (!includedTypes.has(name))
                  continue;
                const attributes = (0, Type_1.isNumberTypeKind)(kind) ? numberAttributes : void 0;
                unionTypes.push(typeBuilder.getPrimitiveType(kind, attributes));
              }
              const stringAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", inferredAttributes, combineProducedAttributes(({ forString }) => forString));
              if (needStringEnum || isConst) {
                const cases = isConst ? [schema4.const] : (_a = enumArray === null || enumArray === void 0 ? void 0 : enumArray.filter((x) => typeof x === "string")) !== null && _a !== void 0 ? _a : [];
                unionTypes.push(typeBuilder.getStringType(stringAttributes, StringTypes_1.StringTypes.fromCases(cases)));
              } else if (includedTypes.has("string")) {
                unionTypes.push(makeStringType(stringAttributes));
              }
              if (includeArray) {
                unionTypes.push(yield makeArrayType());
              }
              if (includeObject) {
                unionTypes.push(yield makeObjectType());
              }
              types.push(typeBuilder.getUniqueUnionType(inferredAttributes, new Set(unionTypes)));
            }
            if (schema4.$ref !== void 0) {
              if (typeof schema4.$ref !== "string") {
                return (0, Messages_1.messageError)("SchemaRefMustBeString", withRef(loc, { actual: typeof schema4.$ref }));
              }
              const virtualRef = Ref.parse(schema4.$ref);
              const [target, newLoc] = yield resolver.resolveVirtualRef(loc, virtualRef);
              const attributes = (0, TypeNames_1.modifyTypeNames)(typeAttributes, (tn) => {
                if (!(0, Support_1.defined)(tn).areInferred)
                  return tn;
                return TypeNames_1.TypeNames.make(/* @__PURE__ */ new Set([newLoc.canonicalRef.name]), /* @__PURE__ */ new Set(), true);
              });
              types.push(yield toType(target, newLoc, attributes));
            }
            if (schema4.allOf !== void 0) {
              types.push(...yield makeTypesFromCases(schema4.allOf, "allOf"));
            }
            if (schema4.oneOf !== void 0) {
              types.push(yield convertOneOrAnyOf(schema4.oneOf, "oneOf"));
            }
            if (schema4.anyOf !== void 0) {
              types.push(yield convertOneOrAnyOf(schema4.anyOf, "anyOf"));
            }
            typeBuilder.setSetOperationMembers(intersectionType, new Set(types));
            return intersectionType;
          });
        }
        function toType(schema4, loc, typeAttributes) {
          return __awaiter(this, void 0, void 0, function* () {
            const maybeType = typeForCanonicalRef.get(loc.canonicalRef);
            if (maybeType !== void 0) {
              return maybeType;
            }
            let result;
            if (typeof schema4 === "boolean") {
              (0, Messages_1.messageAssert)(schema4 === true, "SchemaFalseNotSupported", withRef(loc));
              result = typeBuilder.getPrimitiveType("any");
            } else {
              loc = loc.updateWithID(schema4.$id);
              result = yield convertToType(schema4, loc, typeAttributes);
            }
            setTypeForLocation(loc, result);
            return result;
          });
        }
        for (const [topLevelName, topLevelRef] of references) {
          const [target, loc] = yield resolver.resolveTopLevelRef(topLevelRef);
          const t = yield toType(target, loc, (0, TypeNames_1.makeNamesTypeAttributes)(topLevelName, false));
          typeBuilder.addTopLevel(topLevelName, t);
        }
      });
    }
    function removeExtension(fn) {
      const lower = fn.toLowerCase();
      const extensions = [".json", ".schema"];
      for (const ext of extensions) {
        if (lower.endsWith(ext)) {
          const base = fn.slice(0, fn.length - ext.length);
          if (base.length > 0) {
            return base;
          }
        }
      }
      return fn;
    }
    function nameFromURI(uri) {
      const fragment = uri.fragment();
      if (fragment !== "") {
        const components = fragment.split("/");
        const len = components.length;
        if (components[len - 1] !== "") {
          return removeExtension(components[len - 1]);
        }
        if (len > 1 && components[len - 2] !== "") {
          return removeExtension(components[len - 2]);
        }
      }
      const filename = uri.filename();
      if (filename !== "") {
        return removeExtension(filename);
      }
      return (0, Messages_1.messageError)("DriverCannotInferNameForSchema", { uri: uri.toString() });
    }
    function refsInSchemaForURI(resolver, uri, defaultName) {
      return __awaiter(this, void 0, void 0, function* () {
        const fragment = uri.fragment();
        let propertiesAreTypes = fragment.endsWith("/");
        if (propertiesAreTypes) {
          uri = uri.clone().fragment(fragment.slice(0, -1));
        }
        const ref = Ref.parseURI(uri);
        if (ref.isRoot) {
          propertiesAreTypes = false;
        }
        const schema4 = (yield resolver.resolveTopLevelRef(ref))[0];
        if (propertiesAreTypes) {
          if (typeof schema4 !== "object") {
            return (0, Messages_1.messageError)("SchemaCannotGetTypesFromBoolean", { ref: ref.toString() });
          }
          return (0, collection_utils_1.mapMap)((0, collection_utils_1.mapFromObject)(schema4), (_, name) => ref.push(name));
        } else {
          let name;
          if (typeof schema4 === "object" && typeof schema4.title === "string") {
            name = schema4.title;
          } else {
            const maybeName = nameFromURI(uri);
            name = maybeName !== null && maybeName !== void 0 ? maybeName : defaultName;
          }
          return [name, ref];
        }
      });
    }
    var InputJSONSchemaStore = class extends JSONSchemaStore_1.JSONSchemaStore {
      constructor(_inputs, _delegate) {
        super();
        this._inputs = _inputs;
        this._delegate = _delegate;
      }
      fetch(address) {
        return __awaiter(this, void 0, void 0, function* () {
          const maybeInput = this._inputs.get(address);
          if (maybeInput !== void 0) {
            return checkJSONSchema((0, Support_1.parseJSON)(maybeInput, "JSON Schema", address), () => Ref.root(address));
          }
          if (this._delegate === void 0) {
            return (0, Support_1.panic)(`Schema URI ${address} requested, but no store given`);
          }
          return yield this._delegate.fetch(address);
        });
      }
    };
    var JSONSchemaInput = class {
      constructor(_schemaStore, additionalAttributeProducers = [], _additionalSchemaAddresses = []) {
        this._schemaStore = _schemaStore;
        this._additionalSchemaAddresses = _additionalSchemaAddresses;
        this.kind = "schema";
        this.needSchemaProcessing = true;
        this._schemaInputs = /* @__PURE__ */ new Map();
        this._schemaSources = [];
        this._topLevels = /* @__PURE__ */ new Map();
        this._needIR = false;
        this._attributeProducers = [
          Description_1.descriptionAttributeProducer,
          AccessorNames_1.accessorNamesAttributeProducer,
          EnumValues_1.enumValuesAttributeProducer,
          URIAttributes_1.uriSchemaAttributesProducer,
          Constraints_1.minMaxAttributeProducer,
          Constraints_1.minMaxLengthAttributeProducer,
          Constraints_1.patternAttributeProducer
        ].concat(additionalAttributeProducers);
      }
      get needIR() {
        return this._needIR;
      }
      addTopLevel(name, ref) {
        this._topLevels.set(name, ref);
      }
      addTypes(ctx, typeBuilder) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._schemaSources.length === 0)
            return;
          let maybeSchemaStore = this._schemaStore;
          if (this._schemaInputs.size === 0) {
            if (maybeSchemaStore === void 0) {
              return (0, Support_1.panic)("Must have a schema store to process JSON Schema");
            }
          } else {
            maybeSchemaStore = this._schemaStore = new InputJSONSchemaStore(this._schemaInputs, maybeSchemaStore);
          }
          const schemaStore = maybeSchemaStore;
          const canonizer = new Canonizer(ctx);
          for (const address of this._additionalSchemaAddresses) {
            const schema4 = yield schemaStore.get(address, ctx.debugPrintSchemaResolving);
            if (schema4 === void 0) {
              return (0, Messages_1.messageError)("SchemaFetchErrorAdditional", { address });
            }
            canonizer.addSchema(schema4, address);
          }
          const resolver = new Resolver(ctx, (0, Support_1.defined)(this._schemaStore), canonizer);
          for (const [normalizedURI, source] of this._schemaSources) {
            const givenName = source.name;
            const refs = yield refsInSchemaForURI(resolver, normalizedURI, givenName);
            if (Array.isArray(refs)) {
              let name;
              if (this._schemaSources.length === 1 && givenName !== void 0) {
                name = givenName;
              } else {
                name = refs[0];
              }
              this.addTopLevel(name, refs[1]);
            } else {
              for (const [refName, ref] of refs) {
                this.addTopLevel(refName, ref);
              }
            }
          }
          yield addTypesInSchema(resolver, typeBuilder, this._topLevels, this._attributeProducers);
        });
      }
      addTypesSync() {
        return (0, Support_1.panic)("addTypesSync not supported in JSONSchemaInput");
      }
      addSource(schemaSource) {
        return __awaiter(this, void 0, void 0, function* () {
          this.addSourceSync(schemaSource);
        });
      }
      addSourceSync(schemaSource) {
        const { name, uris, schema: schema4, isConverted } = schemaSource;
        if (isConverted !== true) {
          this._needIR = true;
        }
        let normalizedURIs;
        if (uris === void 0) {
          normalizedURIs = [new urijs_1.default(name)];
        } else {
          normalizedURIs = uris.map((uri) => {
            const normalizedURI = normalizeURI(uri);
            if (normalizedURI.clone().hash("").toString() === "") {
              normalizedURI.path(name);
            }
            return normalizedURI;
          });
        }
        if (schema4 === void 0) {
          (0, Support_1.assert)(uris !== void 0, "URIs must be given if schema source is not specified");
        } else {
          for (let i = 0; i < normalizedURIs.length; i++) {
            const normalizedURI = normalizedURIs[i];
            const uri = normalizedURI.clone().hash("");
            const path = uri.path();
            let suffix = 0;
            do {
              if (suffix > 0) {
                uri.path(`${path}-${suffix}`);
              }
              suffix++;
            } while (this._schemaInputs.has(uri.toString()));
            this._schemaInputs.set(uri.toString(), schema4);
            normalizedURIs[i] = uri.hash(normalizedURI.hash());
          }
        }
        for (const normalizedURI of normalizedURIs) {
          this._schemaSources.push([normalizedURI, schemaSource]);
        }
      }
      singleStringSchemaSource() {
        if (!this._schemaSources.every(([_, { schema: schema4 }]) => typeof schema4 === "string")) {
          return void 0;
        }
        const set2 = new Set(this._schemaSources.map(([_, { schema: schema4 }]) => schema4));
        if (set2.size === 1) {
          return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(set2));
        }
        return void 0;
      }
    };
    exports.JSONSchemaInput = JSONSchemaInput;
  }
});

// node_modules/quicktype-core/dist/attributes/Description.js
var require_Description = __commonJS({
  "node_modules/quicktype-core/dist/attributes/Description.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.descriptionAttributeProducer = exports.propertyDescriptionsTypeAttributeKind = exports.descriptionTypeAttributeKind = exports.addDescriptionToSchema = void 0;
    var collection_utils_1 = require_dist();
    var JSONSchemaInput_1 = require_JSONSchemaInput();
    var TypeAttributes_1 = require_TypeAttributes();
    function addDescriptionToSchema(schema4, description) {
      if (description === void 0)
        return;
      schema4.description = Array.from(description).join("\n");
    }
    exports.addDescriptionToSchema = addDescriptionToSchema;
    var DescriptionTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("description");
      }
      combine(attrs) {
        return (0, collection_utils_1.setUnionManyInto)(/* @__PURE__ */ new Set(), attrs);
      }
      makeInferred(_) {
        return void 0;
      }
      addToSchema(schema4, _t, attrs) {
        addDescriptionToSchema(schema4, attrs);
      }
      stringify(descriptions) {
        let result = (0, collection_utils_1.iterableFirst)(descriptions);
        if (result === void 0)
          return void 0;
        if (result.length > 5 + 3) {
          result = `${result.slice(0, 5)}...`;
        }
        if (descriptions.size > 1) {
          result = `${result}, ...`;
        }
        return result;
      }
    };
    exports.descriptionTypeAttributeKind = new DescriptionTypeAttributeKind();
    var PropertyDescriptionsTypeAttributeKind = class extends TypeAttributes_1.TypeAttributeKind {
      constructor() {
        super("propertyDescriptions");
      }
      combine(attrs) {
        const result = /* @__PURE__ */ new Map();
        for (const attr of attrs) {
          (0, collection_utils_1.mapMergeWithInto)(result, (sa, sb) => (0, collection_utils_1.setUnion)(sa, sb), attr);
        }
        return result;
      }
      makeInferred(_) {
        return void 0;
      }
      stringify(propertyDescriptions) {
        if (propertyDescriptions.size === 0)
          return void 0;
        return `prop descs: ${propertyDescriptions.size}`;
      }
    };
    exports.propertyDescriptionsTypeAttributeKind = new PropertyDescriptionsTypeAttributeKind();
    function isPropertiesKey(el) {
      return el.kind === JSONSchemaInput_1.PathElementKind.KeyOrIndex && el.key === "properties";
    }
    function descriptionAttributeProducer(schema4, ref, types) {
      if (!(typeof schema4 === "object"))
        return void 0;
      let description = TypeAttributes_1.emptyTypeAttributes;
      let propertyDescription = TypeAttributes_1.emptyTypeAttributes;
      const pathLength = ref.path.length;
      if (types.has("object") || (0, collection_utils_1.setSubtract)(types, ["null"]).size > 1 || schema4.enum !== void 0 || pathLength < 2 || !isPropertiesKey(ref.path[pathLength - 2])) {
        const maybeDescription = schema4.description;
        if (typeof maybeDescription === "string") {
          description = exports.descriptionTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([maybeDescription]));
        }
      }
      if (types.has("object") && typeof schema4.properties === "object") {
        const propertyDescriptions = (0, collection_utils_1.mapFilterMap)((0, collection_utils_1.mapFromObject)(schema4.properties), (propSchema) => {
          if (propSchema && typeof propSchema === "object" && "description" in propSchema) {
            const desc = propSchema.description;
            if (typeof desc === "string") {
              return /* @__PURE__ */ new Set([desc]);
            }
          }
          return void 0;
        });
        if (propertyDescriptions.size > 0) {
          propertyDescription = exports.propertyDescriptionsTypeAttributeKind.makeAttributes(propertyDescriptions);
        }
      }
      return { forType: description, forObject: propertyDescription };
    }
    exports.descriptionAttributeProducer = descriptionAttributeProducer;
  }
});

// node_modules/wordwrap/index.js
var require_wordwrap = __commonJS({
  "node_modules/wordwrap/index.js"(exports, module) {
    var wordwrap = module.exports = function(start, stop, params) {
      if (typeof start === "object") {
        params = start;
        start = params.start;
        stop = params.stop;
      }
      if (typeof stop === "object") {
        params = stop;
        start = start || params.start;
        stop = void 0;
      }
      if (!stop) {
        stop = start;
        start = 0;
      }
      if (!params)
        params = {};
      var mode = params.mode || "soft";
      var re = mode === "hard" ? /\b/ : /(\S+\s+)/;
      return function(text) {
        var chunks = text.toString().split(re).reduce(function(acc, x) {
          if (mode === "hard") {
            for (var i = 0; i < x.length; i += stop - start) {
              acc.push(x.slice(i, i + stop - start));
            }
          } else
            acc.push(x);
          return acc;
        }, []);
        return chunks.reduce(function(lines, rawChunk) {
          if (rawChunk === "")
            return lines;
          var chunk = rawChunk.replace(/\t/g, "    ");
          var i = lines.length - 1;
          if (lines[i].length + chunk.length > stop) {
            lines[i] = lines[i].replace(/\s+$/, "");
            chunk.split(/\n/).forEach(function(c) {
              lines.push(
                new Array(start + 1).join(" ") + c.replace(/^\s+/, "")
              );
            });
          } else if (chunk.match(/\n/)) {
            var xs = chunk.split(/\n/);
            lines[i] += xs.shift();
            xs.forEach(function(c) {
              lines.push(
                new Array(start + 1).join(" ") + c.replace(/^\s+/, "")
              );
            });
          } else {
            lines[i] += chunk;
          }
          return lines;
        }, [new Array(start + 1).join(" ")]).join("\n");
      };
    };
    wordwrap.soft = wordwrap;
    wordwrap.hard = function(start, stop) {
      return wordwrap(start, stop, { mode: "hard" });
    };
  }
});

// node_modules/quicktype-core/dist/DeclarationIR.js
var require_DeclarationIR = __commonJS({
  "node_modules/quicktype-core/dist/DeclarationIR.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.declarationsForGraph = exports.cycleBreakerTypesForGraph = exports.DeclarationIR = void 0;
    var collection_utils_1 = require_dist();
    var Graph_1 = require_Graph();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var DeclarationIR = class {
      constructor(declarations, forwardedTypes) {
        this.forwardedTypes = forwardedTypes;
        this.declarations = Array.from(declarations);
      }
    };
    exports.DeclarationIR = DeclarationIR;
    function findBreaker(t, path, canBreak) {
      const index = path.indexOf(t);
      if (index < 0)
        return void 0;
      if (canBreak === void 0) {
        return path[index];
      }
      const potentialBreakers = path.slice(0, index + 1).reverse();
      const maybeBreaker = potentialBreakers.find(canBreak);
      if (maybeBreaker === void 0) {
        return (0, Support_1.panic)("Found a cycle that cannot be broken");
      }
      return maybeBreaker;
    }
    function cycleBreakerTypesForGraph(graph, isImplicitCycleBreaker, canBreakCycles) {
      const visitedTypes = /* @__PURE__ */ new Set();
      const cycleBreakerTypes = /* @__PURE__ */ new Set();
      const queue = Array.from(graph.topLevels.values());
      function visit3(t, path) {
        if (visitedTypes.has(t))
          return;
        if (isImplicitCycleBreaker(t)) {
          for (const c of t.getChildren()) {
            queue.push(c);
          }
        } else {
          const maybeBreaker = findBreaker(t, path, canBreakCycles);
          if (maybeBreaker !== void 0) {
            cycleBreakerTypes.add(maybeBreaker);
            return;
          }
          for (const c of t.getChildren()) {
            path.unshift(t);
            visit3(c, path);
            path.shift();
          }
        }
        visitedTypes.add(t);
      }
      for (; ; ) {
        const maybeType = queue.pop();
        if (maybeType === void 0)
          break;
        const path = [];
        visit3(maybeType, path);
        (0, Support_1.assert)(path.length === 0);
      }
      return cycleBreakerTypes;
    }
    exports.cycleBreakerTypesForGraph = cycleBreakerTypesForGraph;
    function declarationsForGraph(typeGraph, canBeForwardDeclared, childrenOfType, needsDeclaration) {
      const topDown = canBeForwardDeclared === void 0;
      const declarations = [];
      const forwardedTypes = /* @__PURE__ */ new Set();
      const visitedComponents = /* @__PURE__ */ new Set();
      function processGraph(graph, _writeComponents) {
        const componentsGraph = graph.stronglyConnectedComponents();
        function visitComponent(component) {
          if (visitedComponents.has(component))
            return;
          visitedComponents.add(component);
          const declarationNeeded = (0, collection_utils_1.setFilter)(component, needsDeclaration);
          if (declarationNeeded.size === 1) {
            declarations.push({ kind: "define", type: (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(declarationNeeded)) });
            return;
          }
          if (declarationNeeded.size === 0 && component.size === 1) {
            return;
          }
          if (declarationNeeded.size === 0) {
            declarations.push({ kind: "define", type: (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(component)) });
            return;
          }
          if (canBeForwardDeclared === void 0) {
            for (const t of declarationNeeded) {
              declarations.push({ kind: "define", type: t });
            }
            return;
          }
          const forwardDeclarable = (0, collection_utils_1.setFilter)(component, canBeForwardDeclared);
          if (forwardDeclarable.size === 0) {
            return (0, Messages_1.messageError)("IRNoForwardDeclarableTypeInCycle", {});
          }
          for (const t of forwardDeclarable) {
            declarations.push({ kind: "forward", type: t });
          }
          (0, collection_utils_1.setUnionInto)(forwardedTypes, forwardDeclarable);
          const rest = (0, collection_utils_1.setSubtract)(component, forwardDeclarable);
          const restGraph = new Graph_1.Graph(rest, true, (t) => (0, collection_utils_1.setIntersect)(childrenOfType(t), rest));
          processGraph(restGraph, false);
          for (const t of forwardDeclarable) {
            declarations.push({ kind: "define", type: t });
          }
          return;
        }
        const rootsUnordered = componentsGraph.findRoots();
        const roots = rootsUnordered;
        for (const component of roots) {
          componentsGraph.dfsTraversal(component, topDown, visitComponent);
        }
      }
      const fullGraph = typeGraph.makeGraph(false, childrenOfType);
      processGraph(fullGraph, true);
      return new DeclarationIR(declarations, forwardedTypes);
    }
    exports.declarationsForGraph = declarationsForGraph;
  }
});

// node_modules/quicktype-core/dist/Naming.js
var require_Naming = __commonJS({
  "node_modules/quicktype-core/dist/Naming.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignNames = exports.keywordNamespace = exports.DependencyName = exports.AssociatedName = exports.SimpleName = exports.FixedName = exports.Name = exports.funPrefixNamer = exports.Namer = exports.Namespace = void 0;
    var collection_utils_1 = require_dist();
    var Support_1 = require_Support();
    var Namespace = class {
      constructor(_name, parent, forbiddenNamespaces, additionalForbidden) {
        this._children = /* @__PURE__ */ new Set();
        this._members = /* @__PURE__ */ new Set();
        this.forbiddenNamespaces = new Set(forbiddenNamespaces);
        this.additionalForbidden = new Set(additionalForbidden);
        if (parent !== void 0) {
          parent.addChild(this);
        }
      }
      addChild(child) {
        this._children.add(child);
      }
      get children() {
        return this._children;
      }
      get members() {
        return this._members;
      }
      get forbiddenNameds() {
        return (0, collection_utils_1.setUnion)(this.additionalForbidden, ...Array.from(this.forbiddenNamespaces).map((ns) => ns.members));
      }
      add(named) {
        this._members.add(named);
        return named;
      }
    };
    exports.Namespace = Namespace;
    var Namer = class {
      constructor(name, nameStyle, prefixes) {
        this.name = name;
        this.nameStyle = nameStyle;
        this.prefixes = prefixes;
        this._prefixes = new Set(prefixes);
      }
      // The namesIterable comes directly out of the context and will
      // be modified if we assign
      assignNames(names, forbiddenNamesIterable, namesToAssignIterable) {
        const forbiddenNames = new Set(forbiddenNamesIterable);
        const namesToAssign = Array.from(namesToAssignIterable);
        (0, Support_1.assert)(namesToAssign.length > 0, "Number of names can't be less than 1");
        const allAssignedNames = /* @__PURE__ */ new Map();
        let namesToPrefix = [];
        for (const name of namesToAssign) {
          const proposedNames = name.proposeUnstyledNames(names);
          const namingFunction = name.namingFunction;
          const maybeUniqueName = (0, collection_utils_1.iterableFind)(proposedNames, (proposed) => !forbiddenNames.has(namingFunction.nameStyle(proposed)) && namesToAssign.every((n) => n === name || !n.proposeUnstyledNames(names).has(proposed)));
          if (maybeUniqueName !== void 0) {
            const styledName = namingFunction.nameStyle(maybeUniqueName);
            const assigned = name.nameAssignments(forbiddenNames, styledName);
            if (assigned !== null) {
              (0, collection_utils_1.mapMergeInto)(allAssignedNames, assigned);
              (0, collection_utils_1.setUnionInto)(forbiddenNames, assigned.values());
              continue;
            }
          }
          namesToPrefix.push(name);
        }
        let prefixes = this._prefixes.values();
        let suffixNumber = 1;
        for (const name of namesToPrefix) {
          const originalName = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(name.proposeUnstyledNames(names)));
          for (; ; ) {
            let nameToTry;
            const { done, value: prefix } = prefixes.next();
            if (!done) {
              nameToTry = `${prefix}_${originalName}`;
            } else {
              nameToTry = `${originalName}_${suffixNumber.toString()}`;
              suffixNumber++;
            }
            const styledName = name.namingFunction.nameStyle(nameToTry);
            const assigned = name.nameAssignments(forbiddenNames, styledName);
            if (assigned === null)
              continue;
            (0, collection_utils_1.mapMergeInto)(allAssignedNames, assigned);
            (0, collection_utils_1.setUnionInto)(forbiddenNames, assigned.values());
            break;
          }
        }
        return allAssignedNames;
      }
    };
    exports.Namer = Namer;
    var funPrefixes = [
      "Purple",
      "Fluffy",
      "Tentacled",
      "Sticky",
      "Indigo",
      "Indecent",
      "Hilarious",
      "Ambitious",
      "Cunning",
      "Magenta",
      "Frisky",
      "Mischievous",
      "Braggadocious"
    ];
    function funPrefixNamer(name, nameStyle) {
      return new Namer(name, nameStyle, funPrefixes);
    }
    exports.funPrefixNamer = funPrefixNamer;
    var Name = class {
      // If a Named is fixed, the namingFunction is undefined.
      constructor(_namingFunction, order) {
        this._namingFunction = _namingFunction;
        this.order = order;
        this._associates = /* @__PURE__ */ new Set();
      }
      addAssociate(associate) {
        this._associates.add(associate);
      }
      isFixed() {
        return this instanceof FixedName;
      }
      get namingFunction() {
        return (0, Support_1.defined)(this._namingFunction);
      }
      firstProposedName(names) {
        return (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(this.proposeUnstyledNames(names)));
      }
      nameAssignments(forbiddenNames, assignedName) {
        if (forbiddenNames.has(assignedName))
          return null;
        const assignments = /* @__PURE__ */ new Map([[this, assignedName]]);
        for (const an of this._associates) {
          const associatedAssignedName = an.getName(assignedName);
          if (forbiddenNames.has(associatedAssignedName)) {
            return null;
          }
          assignments.set(an, associatedAssignedName);
        }
        return assignments;
      }
    };
    exports.Name = Name;
    var FixedName = class extends Name {
      constructor(_fixedName) {
        super(void 0, 0);
        this._fixedName = _fixedName;
      }
      get dependencies() {
        return [];
      }
      addAssociate(_) {
        return (0, Support_1.panic)("Cannot add associates to fixed names");
      }
      get fixedName() {
        return this._fixedName;
      }
      proposeUnstyledNames(_) {
        return (0, Support_1.panic)("Only fixedName should be called on FixedName.");
      }
    };
    exports.FixedName = FixedName;
    var SimpleName = class extends Name {
      constructor(unstyledNames, namingFunction, order) {
        super(namingFunction, order);
        this._unstyledNames = new Set(unstyledNames);
      }
      get dependencies() {
        return [];
      }
      proposeUnstyledNames(_) {
        return this._unstyledNames;
      }
    };
    exports.SimpleName = SimpleName;
    var AssociatedName = class extends Name {
      constructor(_sponsor, order, getName) {
        super(void 0, order);
        this._sponsor = _sponsor;
        this.getName = getName;
      }
      get dependencies() {
        return [this._sponsor];
      }
      proposeUnstyledNames(_) {
        return (0, Support_1.panic)("AssociatedName must be assigned via its sponsor");
      }
    };
    exports.AssociatedName = AssociatedName;
    var DependencyName = class extends Name {
      constructor(namingFunction, order, _proposeUnstyledName) {
        super(namingFunction, order);
        this._proposeUnstyledName = _proposeUnstyledName;
        const dependencies = [];
        _proposeUnstyledName((n) => {
          dependencies.push(n);
          return "0xDEADBEEF";
        });
        this._dependencies = new Set(dependencies);
      }
      get dependencies() {
        return Array.from(this._dependencies);
      }
      proposeUnstyledNames(names) {
        return /* @__PURE__ */ new Set([
          this._proposeUnstyledName((n) => {
            (0, Support_1.assert)(this._dependencies.has(n), "DependencyName proposer is not pure");
            return (0, Support_1.defined)(names.get(n));
          })
        ]);
      }
    };
    exports.DependencyName = DependencyName;
    function keywordNamespace(name, keywords) {
      const ns = new Namespace(name, void 0, [], []);
      for (const kw of keywords) {
        ns.add(new FixedName(kw));
      }
      return ns;
    }
    exports.keywordNamespace = keywordNamespace;
    function allNamespacesRecursively(namespaces) {
      return (0, collection_utils_1.setUnion)(namespaces, ...Array.from((0, collection_utils_1.setMap)(namespaces, (ns) => allNamespacesRecursively(ns.children))));
    }
    var NamingContext = class {
      constructor(rootNamespaces) {
        this._names = /* @__PURE__ */ new Map();
        this._namedsForName = /* @__PURE__ */ new Map();
        this.namespaces = allNamespacesRecursively(rootNamespaces);
      }
      get names() {
        return this._names;
      }
      isReadyToBeNamed(named) {
        if (this._names.has(named))
          return false;
        return named.dependencies.every((n) => this._names.has(n));
      }
      areForbiddensFullyNamed(namespace) {
        return (0, collection_utils_1.iterableEvery)(namespace.forbiddenNameds, (n) => this._names.has(n));
      }
      isConflicting(namedNamespace, proposed) {
        const namedsForProposed = this._namedsForName.get(proposed);
        if (namedsForProposed === void 0)
          return false;
        for (const n of namedsForProposed) {
          if (namedNamespace.members.has(n) || namedNamespace.forbiddenNameds.has(n)) {
            return true;
          }
        }
        return false;
      }
      assign(named, namedNamespace, name) {
        (0, Support_1.assert)(!this.names.has(named), `Name "${name}" assigned twice`);
        (0, Support_1.assert)(!this.isConflicting(namedNamespace, name), `Assigned name "${name}" conflicts`);
        this._names.set(named, name);
        let namedsForName = this._namedsForName.get(name);
        if (namedsForName === void 0) {
          namedsForName = /* @__PURE__ */ new Set();
          this._namedsForName.set(name, namedsForName);
        }
        namedsForName.add(named);
      }
    };
    function assignNames(rootNamespaces) {
      const ctx = new NamingContext(rootNamespaces);
      for (const ns of ctx.namespaces) {
        for (const n of ns.members) {
          if (!n.isFixed())
            continue;
          ctx.assign(n, ns, n.fixedName);
        }
      }
      for (; ; ) {
        const unfinishedNamespaces = (0, collection_utils_1.setFilter)(ctx.namespaces, (ns) => ctx.areForbiddensFullyNamed(ns));
        const readyNamespace = (0, collection_utils_1.iterableFind)(unfinishedNamespaces, (ns) => (0, collection_utils_1.iterableSome)(ns.members, (member) => ctx.isReadyToBeNamed(member)));
        if (readyNamespace === void 0) {
          return ctx.names;
        }
        const allForbiddenNames = (0, collection_utils_1.setUnion)(readyNamespace.members, readyNamespace.forbiddenNameds);
        let forbiddenNames = (0, collection_utils_1.setFilterMap)(allForbiddenNames, (n) => ctx.names.get(n));
        for (; ; ) {
          const allReadyNames = (0, collection_utils_1.setFilter)(readyNamespace.members, (member) => ctx.isReadyToBeNamed(member));
          const minOrderName = (0, collection_utils_1.iterableMinBy)(allReadyNames, (n) => n.order);
          if (minOrderName === void 0)
            break;
          const minOrder = minOrderName.order;
          const readyNames = (0, collection_utils_1.setFilter)(allReadyNames, (n) => n.order === minOrder);
          const byNamingFunction = (0, collection_utils_1.setGroupBy)(readyNames, (n) => n.namingFunction);
          for (const [namer, namedsForNamingFunction] of byNamingFunction) {
            const byProposed = (0, collection_utils_1.setGroupBy)(namedsForNamingFunction, (n) => n.namingFunction.nameStyle(n.firstProposedName(ctx.names)));
            for (const [, nameds] of byProposed) {
              const names = namer.assignNames(ctx.names, forbiddenNames, nameds);
              for (const [name, assigned] of names) {
                ctx.assign(name, readyNamespace, assigned);
              }
              (0, collection_utils_1.setUnionInto)(forbiddenNames, names.values());
            }
          }
        }
      }
    }
    exports.assignNames = assignNames;
  }
});

// node_modules/quicktype-core/dist/Annotation.js
var require_Annotation = __commonJS({
  "node_modules/quicktype-core/dist/Annotation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nullTypeIssueAnnotation = exports.anyTypeIssueAnnotation = exports.IssueAnnotationData = exports.AnnotationData = void 0;
    var AnnotationData = class {
    };
    exports.AnnotationData = AnnotationData;
    var IssueAnnotationData = class extends AnnotationData {
      constructor(message) {
        super();
        this.message = message;
      }
    };
    exports.IssueAnnotationData = IssueAnnotationData;
    exports.anyTypeIssueAnnotation = new IssueAnnotationData("quicktype cannot infer this type because there is no data about it in the input.");
    exports.nullTypeIssueAnnotation = new IssueAnnotationData("The only value for this in the input is null, which means you probably need a more complete input sample.");
  }
});

// node_modules/quicktype-core/dist/Source.js
var require_Source = __commonJS({
  "node_modules/quicktype-core/dist/Source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parenIfNeeded = exports.multiWord = exports.singleWord = exports.serializeRenderResult = exports.modifySource = exports.maybeAnnotated = exports.annotated = exports.sourcelikeToSource = exports.newline = void 0;
    var collection_utils_1 = require_dist();
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    function newline() {
      return { kind: "newline", indentationChange: 0 };
    }
    exports.newline = newline;
    function sourcelikeToSource(sl) {
      if (sl instanceof Array) {
        return {
          kind: "sequence",
          sequence: sl.map(sourcelikeToSource)
        };
      }
      if (typeof sl === "string") {
        const lines = sl.split("\n");
        if (lines.length === 1) {
          return { kind: "text", text: sl };
        }
        return {
          kind: "sequence",
          sequence: (0, collection_utils_1.arrayIntercalate)(newline(), lines.map((l) => ({ kind: "text", text: l })))
        };
      }
      if (sl instanceof Naming_1.Name) {
        return { kind: "name", named: sl };
      }
      return sl;
    }
    exports.sourcelikeToSource = sourcelikeToSource;
    function annotated(annotation, sl) {
      return {
        kind: "annotated",
        annotation,
        source: sourcelikeToSource(sl)
      };
    }
    exports.annotated = annotated;
    function maybeAnnotated(doAnnotate, annotation, sl) {
      if (!doAnnotate) {
        return sl;
      }
      return annotated(annotation, sl);
    }
    exports.maybeAnnotated = maybeAnnotated;
    function modifySource(modifier, sl) {
      return {
        kind: "modified",
        modifier,
        source: sourcelikeToSource(sl)
      };
    }
    exports.modifySource = modifySource;
    function sourceLineLength(source, names) {
      switch (source.kind) {
        case "text":
          return source.text.length;
        case "newline":
          return (0, Support_1.panic)("Newline must not occur within a line.");
        case "sequence":
          return source.sequence.map((s) => sourceLineLength(s, names)).reduce((a, b) => a + b, 0);
        case "table":
          return (0, Support_1.panic)("Table must not occur within a  line.");
        case "annotated":
          return sourceLineLength(source.source, names);
        case "name":
          return (0, Support_1.defined)(names.get(source.named)).length;
        case "modified":
          return serializeRenderResult(source, names, "").lines.join("\n").length;
        default:
          return (0, Support_1.assertNever)(source);
      }
    }
    function serializeRenderResult(rootSource, names, indentation) {
      let indent = 0;
      let indentNeeded = 0;
      const lines = [];
      let currentLine = [];
      const annotations = [];
      function indentIfNeeded() {
        if (indentNeeded === 0)
          return;
        currentLine.push((0, Strings_1.repeatString)(indentation, indentNeeded));
        indentNeeded = 0;
      }
      function flattenCurrentLine() {
        const str = currentLine.join("");
        currentLine = [str];
        return str;
      }
      function currentLocation() {
        return { line: lines.length, column: flattenCurrentLine().length };
      }
      function finishLine() {
        lines.push(flattenCurrentLine());
        currentLine = [];
      }
      function serializeToStringArray(source) {
        switch (source.kind) {
          case "text":
            indentIfNeeded();
            currentLine.push(source.text);
            break;
          case "newline":
            finishLine();
            indent += source.indentationChange;
            indentNeeded = indent;
            break;
          case "sequence":
            for (const s of source.sequence) {
              serializeToStringArray(s);
            }
            break;
          case "table":
            const t = source.table;
            const numRows = t.length;
            if (numRows === 0)
              break;
            const widths = t.map((l) => l.map((s) => sourceLineLength(s, names)));
            const numColumns = (0, Support_1.defined)((0, collection_utils_1.iterableMax)(t.map((l) => l.length)));
            if (numColumns === 0)
              break;
            const columnWidths = [];
            for (let i = 0; i < numColumns; i++) {
              columnWidths.push((0, Support_1.defined)((0, collection_utils_1.iterableMax)(widths.map((l) => (0, collection_utils_1.withDefault)(l[i], 0)))));
            }
            for (let y = 0; y < numRows; y++) {
              indentIfNeeded();
              const row = (0, Support_1.defined)(t[y]);
              const rowWidths = (0, Support_1.defined)(widths[y]);
              for (let x = 0; x < numColumns; x++) {
                const colWidth = columnWidths[x];
                const src = (0, collection_utils_1.withDefault)(row[x], { kind: "text", text: "" });
                const srcWidth = (0, collection_utils_1.withDefault)(rowWidths[x], 0);
                serializeToStringArray(src);
                if (x < numColumns - 1 && srcWidth < colWidth) {
                  currentLine.push((0, Strings_1.repeatString)(" ", colWidth - srcWidth));
                }
              }
              if (y < numRows - 1) {
                finishLine();
                indentNeeded = indent;
              }
            }
            break;
          case "annotated":
            const start = currentLocation();
            serializeToStringArray(source.source);
            const end = currentLocation();
            annotations.push({ annotation: source.annotation, span: { start, end } });
            break;
          case "name":
            (0, Support_1.assert)(names.has(source.named), "No name for Named");
            indentIfNeeded();
            currentLine.push((0, Support_1.defined)(names.get(source.named)));
            break;
          case "modified":
            indentIfNeeded();
            const serialized = serializeRenderResult(source.source, names, indentation).lines;
            (0, Support_1.assert)(serialized.length === 1, "Cannot modify more than one line.");
            currentLine.push(source.modifier(serialized[0]));
            break;
          default:
            return (0, Support_1.assertNever)(source);
        }
      }
      serializeToStringArray(rootSource);
      finishLine();
      return { lines, annotations };
    }
    exports.serializeRenderResult = serializeRenderResult;
    function singleWord(...source) {
      return { source, needsParens: false };
    }
    exports.singleWord = singleWord;
    function multiWord(separator, ...words) {
      (0, Support_1.assert)(words.length > 0, "Zero words is not multiple");
      if (words.length === 1) {
        return singleWord(words[0]);
      }
      const items = [];
      for (let i = 0; i < words.length; i++) {
        if (i > 0)
          items.push(separator);
        items.push(words[i]);
      }
      return { source: items, needsParens: true };
    }
    exports.multiWord = multiWord;
    function parenIfNeeded({ source, needsParens }) {
      if (needsParens) {
        return ["(", source, ")"];
      }
      return source;
    }
    exports.parenIfNeeded = parenIfNeeded;
  }
});

// node_modules/quicktype-core/dist/Renderer.js
var require_Renderer = __commonJS({
  "node_modules/quicktype-core/dist/Renderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Renderer = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Support_1 = require_Support();
    function getBlankLineConfig(cfg) {
      if (Array.isArray(cfg)) {
        return { position: cfg[0], count: cfg[1] };
      }
      return { position: cfg, count: 1 };
    }
    function lineIndentation(line) {
      const len = line.length;
      let indent = 0;
      for (let i = 0; i < len; i++) {
        const c = line.charAt(i);
        if (c === " ") {
          indent += 1;
        } else if (c === "	") {
          indent = (indent / 4 + 1) * 4;
        } else {
          return { indent, text: line.substring(i) };
        }
      }
      return { indent: 0, text: null };
    }
    var EmitContext = class {
      constructor() {
        this._currentEmitTarget = this._emitted = [];
        this._numBlankLinesNeeded = 0;
        this._preventBlankLine = true;
      }
      get isEmpty() {
        return this._emitted.length === 0;
      }
      get isNested() {
        return this._emitted !== this._currentEmitTarget;
      }
      get source() {
        return this._emitted;
      }
      pushItem(item) {
        this._currentEmitTarget.push(item);
        this._preventBlankLine = false;
      }
      emitNewline() {
        const nl = (0, Source_1.newline)();
        this.pushItem(nl);
        this._lastNewline = nl;
      }
      emitItem(item) {
        if (!this.isEmpty) {
          for (let i = 0; i < this._numBlankLinesNeeded; i++) {
            this.emitNewline();
          }
        }
        this._numBlankLinesNeeded = 0;
        this.pushItem(item);
      }
      containsItem(item) {
        const existingItem = this._currentEmitTarget.find((value) => item === value);
        return existingItem !== void 0;
      }
      ensureBlankLine(numBlankLines) {
        if (this._preventBlankLine)
          return;
        this._numBlankLinesNeeded = Math.max(this._numBlankLinesNeeded, numBlankLines);
      }
      preventBlankLine() {
        this._numBlankLinesNeeded = 0;
        this._preventBlankLine = true;
      }
      changeIndent(offset) {
        if (this._lastNewline === void 0) {
          return (0, Support_1.panic)("Cannot change indent for the first line");
        }
        this._lastNewline.indentationChange += offset;
      }
    };
    var Renderer = class {
      constructor(targetLanguage, renderContext) {
        this.targetLanguage = targetLanguage;
        this.emitTable = (tableArray) => {
          if (tableArray.length === 0)
            return;
          const table = tableArray.map((r) => r.map((sl) => (0, Source_1.sourcelikeToSource)(sl)));
          this._emitContext.emitItem({ kind: "table", table });
          this._emitContext.emitNewline();
        };
        this.typeGraph = renderContext.typeGraph;
        this.leadingComments = renderContext.leadingComments;
        this._finishedFiles = /* @__PURE__ */ new Map();
        this._finishedEmitContexts = /* @__PURE__ */ new Map();
        this._emitContext = new EmitContext();
      }
      // FIXME: make protected once JavaDateTimeRenderer is refactored
      ensureBlankLine(numBlankLines = 1) {
        this._emitContext.ensureBlankLine(numBlankLines);
      }
      preventBlankLine() {
        this._emitContext.preventBlankLine();
      }
      emitItem(item) {
        this._emitContext.emitItem(item);
      }
      emitItemOnce(item) {
        if (this._emitContext.containsItem(item)) {
          return false;
        }
        this.emitItem(item);
        return true;
      }
      emitLineOnce(...lineParts) {
        let lineEmitted = true;
        if (lineParts.length === 1) {
          lineEmitted = this.emitItemOnce(lineParts[0]);
        } else if (lineParts.length > 1) {
          lineEmitted = this.emitItemOnce(lineParts);
        }
        if (lineEmitted) {
          this._emitContext.emitNewline();
        }
      }
      // FIXME: make protected once JavaDateTimeRenderer is refactored
      emitLine(...lineParts) {
        if (lineParts.length === 1) {
          this._emitContext.emitItem(lineParts[0]);
        } else if (lineParts.length > 1) {
          this._emitContext.emitItem(lineParts);
        }
        this._emitContext.emitNewline();
      }
      emitMultiline(linesString) {
        const lines = linesString.split("\n");
        const numLines = lines.length;
        if (numLines === 0)
          return;
        this.emitLine(lines[0]);
        let currentIndent = 0;
        for (let i = 1; i < numLines; i++) {
          const line = lines[i];
          const { indent, text } = lineIndentation(line);
          (0, Support_1.assert)(indent % 4 === 0, "Indentation is not a multiple of 4.");
          if (text !== null) {
            const newIndent = indent / 4;
            this.changeIndent(newIndent - currentIndent);
            currentIndent = newIndent;
            this.emitLine(text);
          } else {
            this._emitContext.emitNewline();
          }
        }
        if (currentIndent !== 0) {
          this.changeIndent(-currentIndent);
        }
      }
      gatherSource(emitter) {
        const oldEmitContext = this._emitContext;
        this._emitContext = new EmitContext();
        emitter();
        (0, Support_1.assert)(!this._emitContext.isNested, "emit context not restored correctly");
        const source = this._emitContext.source;
        this._emitContext = oldEmitContext;
        return source;
      }
      emitGatheredSource(items) {
        for (const item of items) {
          this._emitContext.emitItem(item);
        }
      }
      emitAnnotated(annotation, emitter) {
        const lines = this.gatherSource(emitter);
        const source = (0, Source_1.sourcelikeToSource)(lines);
        this._emitContext.emitItem((0, Source_1.annotated)(annotation, source));
      }
      emitIssue(message, emitter) {
        this.emitAnnotated(new Annotation_1.IssueAnnotationData(message), emitter);
      }
      changeIndent(offset) {
        this._emitContext.changeIndent(offset);
      }
      iterableForEach(iterable, emitter) {
        const items = Array.from(iterable);
        let onFirst = true;
        for (const [i, v] of (0, collection_utils_1.iterableEnumerate)(items)) {
          const position = items.length === 1 ? "only" : onFirst ? "first" : i === items.length - 1 ? "last" : "middle";
          emitter(v, position);
          onFirst = false;
        }
      }
      forEach(iterable, interposedBlankLines, leadingBlankLines, emitter) {
        let didEmit = false;
        this.iterableForEach(iterable, ([k, v], position) => {
          if (position === "only" || position === "first") {
            this.ensureBlankLine(leadingBlankLines);
          } else {
            this.ensureBlankLine(interposedBlankLines);
          }
          emitter(v, k, position);
          didEmit = true;
        });
        return didEmit;
      }
      forEachWithBlankLines(iterable, blankLineConfig, emitter) {
        const { position, count } = getBlankLineConfig(blankLineConfig);
        const interposing = ["interposing", "leading-and-interposing"].includes(position);
        const leading = ["leading", "leading-and-interposing"].includes(position);
        return this.forEach(iterable, interposing ? count : 0, leading ? count : 0, emitter);
      }
      // FIXME: make protected once JavaDateTimeRenderer is refactored
      indent(fn) {
        this.changeIndent(1);
        fn();
        this.changeIndent(-1);
      }
      assignNames() {
        return (0, Naming_1.assignNames)(this.setUpNaming());
      }
      initializeEmitContextForFilename(filename) {
        if (this._finishedEmitContexts.has(filename.toLowerCase())) {
          const existingEmitContext = this._finishedEmitContexts.get(filename.toLowerCase());
          if (existingEmitContext !== void 0) {
            this._emitContext = existingEmitContext;
          }
        }
      }
      finishFile(filename) {
        if (this._finishedFiles.has(filename)) {
          console.log(`[WARNING] Tried to emit file ${filename} more than once. If performing multi-file output this warning can be safely ignored.`);
        }
        const source = (0, Source_1.sourcelikeToSource)(this._emitContext.source);
        this._finishedFiles.set(filename, source);
        this._finishedEmitContexts.set(filename.toLowerCase(), this._emitContext);
        this._emitContext = new EmitContext();
      }
      render(givenOutputFilename) {
        this._names = this.assignNames();
        this.emitSource(givenOutputFilename);
        if (!this._emitContext.isEmpty) {
          this.finishFile(givenOutputFilename);
        }
        return { sources: this._finishedFiles, names: this._names };
      }
      get names() {
        if (this._names === void 0) {
          return (0, Support_1.panic)("Names accessed before they were assigned");
        }
        return this._names;
      }
    };
    exports.Renderer = Renderer;
  }
});

// node_modules/quicktype-core/dist/support/Comments.js
var require_Comments = __commonJS({
  "node_modules/quicktype-core/dist/support/Comments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isStringComment = void 0;
    var isStringComment = (comment) => {
      return typeof comment === "string";
    };
    exports.isStringComment = isStringComment;
  }
});

// node_modules/quicktype-core/dist/ConvenienceRenderer.js
var require_ConvenienceRenderer = __commonJS({
  "node_modules/quicktype-core/dist/ConvenienceRenderer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConvenienceRenderer = exports.inferredNameOrder = exports.topLevelNameOrder = void 0;
    var collection_utils_1 = require_dist();
    var wordwrap_1 = __importDefault(require_wordwrap());
    var AccessorNames_1 = require_AccessorNames();
    var Description_1 = require_Description();
    var TypeAttributes_1 = require_TypeAttributes();
    var DeclarationIR_1 = require_DeclarationIR();
    var Naming_1 = require_Naming();
    var Renderer_1 = require_Renderer();
    var Source_1 = require_Source();
    var Comments_1 = require_Comments();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type();
    var TypeGraph_1 = require_TypeGraph();
    var TypeUtils_1 = require_TypeUtils();
    var wordWrap = (0, wordwrap_1.default)(90);
    exports.topLevelNameOrder = 1;
    var givenNameOrder = 10;
    exports.inferredNameOrder = 30;
    var classPropertyNameOrder = 20;
    var assignedClassPropertyNameOrder = 10;
    var enumCaseNameOrder = 20;
    var assignedEnumCaseNameOrder = 10;
    var unionMemberNameOrder = 40;
    function splitDescription(descriptions) {
      if (descriptions === void 0)
        return void 0;
      const description = Array.from(descriptions).join("\n\n").trim();
      if (description === "")
        return void 0;
      return wordWrap(description).split("\n").map((l) => l.trim());
    }
    var assignedNameAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedName");
    var assignedPropertyNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedPropertyNames");
    var assignedMemberNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedMemberNames");
    var assignedCaseNamesAttributeKind = new TypeAttributes_1.TypeAttributeKind("assignedCaseNames");
    var ConvenienceRenderer = class extends Renderer_1.Renderer {
      constructor(targetLanguage, renderContext) {
        super(targetLanguage, renderContext);
        this._alphabetizeProperties = false;
      }
      get topLevels() {
        return this.typeGraph.topLevels;
      }
      /**
       * Return an array of strings which are not allowed as names in the global
       * namespace.  Since names of generated types are in the global namespace,
       * this will include anything built into the language or default libraries
       * that can conflict with that, such as reserved keywords or common type
       * names.
       */
      forbiddenNamesForGlobalNamespace() {
        return [];
      }
      /**
       * Returns which names are forbidden for the property names of an object
       * type.  `names` can contain strings as well as `Name`s.  In some
       * languages, the class name can't be used as the name for a property, for
       * example, in which case `_className` would have to be return in `names`.
       * If `includeGlobalForbidden` is set, then all names that are forbidden
       * in the global namespace will also be forbidden for the properties.
       * Note: That doesn't mean that the names in the global namespace will be
       * forbidden, too!
       */
      forbiddenForObjectProperties(_o, _className) {
        return { names: [], includeGlobalForbidden: false };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: false };
      }
      makeTopLevelDependencyNames(_t, _topLevelName) {
        return [];
      }
      makeNamedTypeDependencyNames(_t, _name) {
        return [];
      }
      makeNameForTransformation(_xf, _typeName) {
        return void 0;
      }
      namedTypeToNameForTopLevel(type) {
        if ((0, TypeUtils_1.isNamedType)(type)) {
          return type;
        }
        return void 0;
      }
      get unionMembersInGlobalNamespace() {
        return false;
      }
      get enumCasesInGlobalNamespace() {
        return false;
      }
      get needsTypeDeclarationBeforeUse() {
        return false;
      }
      canBeForwardDeclared(_t) {
        return (0, Support_1.panic)("If needsTypeDeclarationBeforeUse returns true, canBeForwardDeclared must be implemented");
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      get globalNamespace() {
        return (0, Support_1.defined)(this._globalNamespace);
      }
      get nameStoreView() {
        return (0, Support_1.defined)(this._nameStoreView);
      }
      descriptionForType(t) {
        let description = this.typeGraph.attributeStore.tryGet(Description_1.descriptionTypeAttributeKind, t);
        return splitDescription(description);
      }
      descriptionForClassProperty(o, name) {
        const descriptions = this.typeGraph.attributeStore.tryGet(Description_1.propertyDescriptionsTypeAttributeKind, o);
        if (descriptions === void 0)
          return void 0;
        return splitDescription(descriptions.get(name));
      }
      setUpNaming() {
        this._nameStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedNameAttributeKind);
        this._propertyNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedPropertyNamesAttributeKind);
        this._memberNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedMemberNamesAttributeKind);
        this._caseNamesStoreView = new TypeGraph_1.TypeAttributeStoreView(this.typeGraph.attributeStore, assignedCaseNamesAttributeKind);
        this._namesForTransformations = /* @__PURE__ */ new Map();
        this._namedTypeNamer = this.makeNamedTypeNamer();
        this._unionMemberNamer = this.makeUnionMemberNamer();
        this._enumCaseNamer = this.makeEnumCaseNamer();
        this._globalForbiddenNamespace = (0, Naming_1.keywordNamespace)("forbidden", this.forbiddenNamesForGlobalNamespace());
        this._otherForbiddenNamespaces = /* @__PURE__ */ new Map();
        this._globalNamespace = new Naming_1.Namespace("global", void 0, [this._globalForbiddenNamespace], []);
        const { objects, enums, unions } = this.typeGraph.allNamedTypesSeparated();
        const namedUnions = (0, collection_utils_1.setFilter)(unions, (u) => this.unionNeedsName(u));
        for (const [name, t] of this.topLevels) {
          this.nameStoreView.setForTopLevel(name, this.addNameForTopLevel(t, name));
        }
        for (const o of objects) {
          const name = this.addNameForNamedType(o);
          this.addPropertyNames(o, name);
        }
        for (const e of enums) {
          const name = this.addNameForNamedType(e);
          this.addEnumCaseNames(e, name);
        }
        for (const u of namedUnions) {
          const name = this.addNameForNamedType(u);
          this.addUnionMemberNames(u, name);
        }
        for (const t of this.typeGraph.allTypesUnordered()) {
          this.addNameForTransformation(t);
        }
        return (0, collection_utils_1.setUnion)([this._globalForbiddenNamespace, this._globalNamespace], this._otherForbiddenNamespaces.values());
      }
      addDependenciesForNamedType(type, named) {
        const dependencyNames = this.makeNamedTypeDependencyNames(type, named);
        for (const dn of dependencyNames) {
          this.globalNamespace.add(dn);
        }
      }
      makeNameForTopLevel(_t, givenName, _maybeNamedType) {
        return new Naming_1.SimpleName([givenName], (0, Support_1.defined)(this._namedTypeNamer), exports.topLevelNameOrder);
      }
      addNameForTopLevel(type, givenName) {
        const maybeNamedType = this.namedTypeToNameForTopLevel(type);
        const name = this.makeNameForTopLevel(type, givenName, maybeNamedType);
        this.globalNamespace.add(name);
        const dependencyNames = this.makeTopLevelDependencyNames(type, name);
        for (const dn of dependencyNames) {
          this.globalNamespace.add(dn);
        }
        if (maybeNamedType !== void 0) {
          this.addDependenciesForNamedType(maybeNamedType, name);
          this.nameStoreView.set(maybeNamedType, name);
        }
        return name;
      }
      makeNameForType(t, namer, givenOrder, inferredOrder) {
        const names = t.getNames();
        const order = names.areInferred ? inferredOrder : givenOrder;
        return new Naming_1.SimpleName(names.proposedNames, namer, order);
      }
      makeNameForNamedType(t) {
        return this.makeNameForType(t, (0, Support_1.defined)(this._namedTypeNamer), givenNameOrder, exports.inferredNameOrder);
      }
      addNameForNamedType(type) {
        const existing = this.nameStoreView.tryGet(type);
        if (existing !== void 0)
          return existing;
        const name = this.globalNamespace.add(this.makeNameForNamedType(type));
        this.addDependenciesForNamedType(type, name);
        this.nameStoreView.set(type, name);
        return name;
      }
      get typesWithNamedTransformations() {
        return (0, Support_1.defined)(this._namesForTransformations);
      }
      nameForTransformation(t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0)
          return void 0;
        const name = (0, Support_1.defined)(this._namesForTransformations).get(t);
        if (name === void 0) {
          return (0, Support_1.panic)("No name for transformation");
        }
        return name;
      }
      addNameForTransformation(t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0)
          return;
        (0, Support_1.assert)((0, Support_1.defined)(this._namesForTransformations).get(t) === void 0, "Tried to give two names to the same transformation");
        const name = this.makeNameForTransformation(xf, this.nameStoreView.tryGet(xf.targetType));
        if (name === void 0)
          return;
        this.globalNamespace.add(name);
        (0, Support_1.defined)(this._namesForTransformations).set(t, name);
      }
      processForbiddenWordsInfo(info, namespaceName) {
        const forbiddenNames = [];
        const forbiddenStrings = [];
        for (const nameOrString of info.names) {
          if (typeof nameOrString === "string") {
            forbiddenStrings.push(nameOrString);
          } else {
            forbiddenNames.push(nameOrString);
          }
        }
        let namespace = (0, Support_1.defined)(this._otherForbiddenNamespaces).get(namespaceName);
        if (forbiddenStrings.length > 0 && namespace === void 0) {
          namespace = (0, Naming_1.keywordNamespace)(namespaceName, forbiddenStrings);
          this._otherForbiddenNamespaces = (0, Support_1.defined)(this._otherForbiddenNamespaces).set(namespaceName, namespace);
        }
        let forbiddenNamespaces = /* @__PURE__ */ new Set();
        if (info.includeGlobalForbidden) {
          forbiddenNamespaces = forbiddenNamespaces.add((0, Support_1.defined)(this._globalForbiddenNamespace));
        }
        if (namespace !== void 0) {
          forbiddenNamespaces = forbiddenNamespaces.add(namespace);
        }
        return { forbiddenNames: new Set(forbiddenNames), forbiddenNamespaces };
      }
      makeNameForProperty(o, _className, p, jsonName, assignedName) {
        const namer = this.namerForObjectProperty(o, p);
        if (namer === null)
          return void 0;
        const alternative = `${o.getCombinedName()}_${jsonName}`;
        const order = assignedName === void 0 ? classPropertyNameOrder : assignedClassPropertyNameOrder;
        const names = assignedName === void 0 ? [jsonName, alternative] : [assignedName];
        return new Naming_1.SimpleName(names, namer, order);
      }
      makePropertyDependencyNames(_o, _className, _p, _jsonName, _name) {
        return [];
      }
      addPropertyNames(o, className) {
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForObjectProperties(o, className), "forbidden-for-properties");
        let ns;
        const accessorNames = (0, AccessorNames_1.objectPropertyNames)(o, this.targetLanguage.name);
        const names = (0, collection_utils_1.mapFilterMap)(o.getSortedProperties(), (p, jsonName) => {
          const [assignedName, isFixed] = (0, AccessorNames_1.getAccessorName)(accessorNames, jsonName);
          let name;
          if (isFixed) {
            name = new Naming_1.FixedName((0, Support_1.defined)(assignedName));
          } else {
            name = this.makeNameForProperty(o, className, p, jsonName, assignedName);
          }
          if (name === void 0)
            return void 0;
          if (ns === void 0) {
            ns = new Naming_1.Namespace(o.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
          }
          ns.add(name);
          for (const depName of this.makePropertyDependencyNames(o, className, p, jsonName, name)) {
            ns.add(depName);
          }
          return name;
        });
        (0, Support_1.defined)(this._propertyNamesStoreView).set(o, names);
      }
      makeNameForUnionMember(u, unionName, t) {
        const [assignedName, isFixed] = (0, AccessorNames_1.unionMemberName)(u, t, this.targetLanguage.name);
        if (isFixed) {
          return new Naming_1.FixedName((0, Support_1.defined)(assignedName));
        }
        return new Naming_1.DependencyName((0, Support_1.nonNull)(this._unionMemberNamer), unionMemberNameOrder, (lookup) => {
          if (assignedName !== void 0)
            return assignedName;
          return this.proposeUnionMemberName(u, unionName, t, lookup);
        });
      }
      addUnionMemberNames(u, unionName) {
        const memberNamer = this._unionMemberNamer;
        if (memberNamer === null)
          return;
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForUnionMembers(u, unionName), "forbidden-for-union-members");
        let ns;
        if (this.unionMembersInGlobalNamespace) {
          ns = this.globalNamespace;
        } else {
          ns = new Naming_1.Namespace(u.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
        }
        let names = /* @__PURE__ */ new Map();
        for (const t of u.members) {
          const name = this.makeNameForUnionMember(u, unionName, (0, Transformers_1.followTargetType)(t));
          names.set(t, ns.add(name));
        }
        (0, Support_1.defined)(this._memberNamesStoreView).set(u, names);
      }
      makeNameForEnumCase(e, _enumName, caseName, assignedName) {
        const alternative = `${e.getCombinedName()}_${caseName}`;
        const order = assignedName === void 0 ? enumCaseNameOrder : assignedEnumCaseNameOrder;
        const names = assignedName === void 0 ? [caseName, alternative] : [assignedName];
        return new Naming_1.SimpleName(names, (0, Support_1.nonNull)(this._enumCaseNamer), order);
      }
      // FIXME: this is very similar to addPropertyNameds and addUnionMemberNames
      addEnumCaseNames(e, enumName) {
        if (this._enumCaseNamer === null)
          return;
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForEnumCases(e, enumName), "forbidden-for-enum-cases");
        let ns;
        if (this.enumCasesInGlobalNamespace) {
          ns = this.globalNamespace;
        } else {
          ns = new Naming_1.Namespace(e.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
        }
        let names = /* @__PURE__ */ new Map();
        const accessorNames = (0, AccessorNames_1.enumCaseNames)(e, this.targetLanguage.name);
        for (const caseName of e.cases) {
          const [assignedName, isFixed] = (0, AccessorNames_1.getAccessorName)(accessorNames, caseName);
          let name;
          if (isFixed) {
            name = new Naming_1.FixedName((0, Support_1.defined)(assignedName));
          } else {
            name = this.makeNameForEnumCase(e, enumName, caseName, assignedName);
          }
          names.set(caseName, ns.add(name));
        }
        (0, Support_1.defined)(this._caseNamesStoreView).set(e, names);
      }
      childrenOfType(t) {
        const names = this.names;
        if (t instanceof Type_1.ClassType) {
          const propertyNameds = (0, Support_1.defined)(this._propertyNamesStoreView).get(t);
          const filteredMap = (0, collection_utils_1.mapFilterMap)(t.getProperties(), (p, n) => {
            if (propertyNameds.get(n) === void 0)
              return void 0;
            return p.type;
          });
          const sortedMap = (0, collection_utils_1.mapSortBy)(filteredMap, (_, n) => (0, Support_1.defined)(names.get((0, Support_1.defined)(propertyNameds.get(n)))));
          return new Set(sortedMap.values());
        }
        return t.getChildren();
      }
      get namedUnions() {
        return (0, Support_1.defined)(this._namedUnions);
      }
      get haveNamedUnions() {
        return this.namedUnions.size > 0;
      }
      get haveNamedTypes() {
        return (0, Support_1.defined)(this._namedTypes).length > 0;
      }
      get haveUnions() {
        return (0, Support_1.defined)(this._haveUnions);
      }
      get haveMaps() {
        return (0, Support_1.defined)(this._haveMaps);
      }
      get haveOptionalProperties() {
        return (0, Support_1.defined)(this._haveOptionalProperties);
      }
      // FIXME: Inconsistently named, though technically correct.  Right now all enums are named,
      // but this should really be called `namedEnums`.
      get enums() {
        return (0, Support_1.defined)(this._namedEnums);
      }
      get haveEnums() {
        return this.enums.size > 0;
      }
      proposedUnionMemberNameForTypeKind(_kind) {
        return null;
      }
      proposeUnionMemberName(_u, _unionName, fieldType, lookup) {
        const simpleName = this.proposedUnionMemberNameForTypeKind(fieldType.kind);
        if (simpleName !== null) {
          return simpleName;
        }
        const typeNameForUnionMember = (t) => (0, TypeUtils_1.matchTypeExhaustive)(t, (_noneType) => {
          return (0, Support_1.panic)("none type should have been replaced");
        }, (_anyType) => "anything", (_nullType) => "null", (_boolType) => "bool", (_integerType) => "integer", (_doubleType) => "double", (_stringType) => "string", (arrayType) => typeNameForUnionMember(arrayType.items) + "_array", (classType) => lookup(this.nameForNamedType(classType)), (mapType) => typeNameForUnionMember(mapType.values) + "_map", (objectType) => {
          (0, Support_1.assert)(this.targetLanguage.supportsFullObjectType, "Object type should have been replaced in `replaceObjectType`");
          return lookup(this.nameForNamedType(objectType));
        }, (_enumType) => "enum", (_unionType) => "union", (transformedType) => transformedType.kind.replace("-", "_"));
        return typeNameForUnionMember(fieldType);
      }
      nameForNamedType(t) {
        return this.nameStoreView.get(t);
      }
      isForwardDeclaredType(t) {
        return (0, Support_1.defined)(this._declarationIR).forwardedTypes.has(t);
      }
      isImplicitCycleBreaker(_t) {
        return (0, Support_1.panic)("A renderer that invokes isCycleBreakerType must implement isImplicitCycleBreaker");
      }
      canBreakCycles(_t) {
        return true;
      }
      isCycleBreakerType(t) {
        if (this._cycleBreakerTypes === void 0) {
          this._cycleBreakerTypes = (0, DeclarationIR_1.cycleBreakerTypesForGraph)(this.typeGraph, (s) => this.isImplicitCycleBreaker(s), (s) => this.canBreakCycles(s));
        }
        return this._cycleBreakerTypes.has(t);
      }
      forEachTopLevel(blankLocations, f, predicate) {
        let topLevels;
        if (predicate !== void 0) {
          topLevels = (0, collection_utils_1.mapFilter)(this.topLevels, predicate);
        } else {
          topLevels = this.topLevels;
        }
        return this.forEachWithBlankLines(topLevels, blankLocations, (t, name, pos) => f(t, this.nameStoreView.getForTopLevel(name), pos));
      }
      forEachDeclaration(blankLocations, f) {
        this.forEachWithBlankLines((0, collection_utils_1.iterableEnumerate)((0, Support_1.defined)(this._declarationIR).declarations), blankLocations, (decl, _, pos) => f(decl, pos));
      }
      setAlphabetizeProperties(value) {
        this._alphabetizeProperties = value;
      }
      getAlphabetizeProperties() {
        return this._alphabetizeProperties;
      }
      // Returns the number of properties defined for the specified object type.
      propertyCount(o) {
        const propertyNames = (0, Support_1.defined)(this._propertyNamesStoreView).get(o);
        return propertyNames.size;
      }
      sortClassProperties(properties, propertyNames) {
        if (this._alphabetizeProperties) {
          return (0, collection_utils_1.mapSortBy)(properties, (_p, jsonName) => {
            const name = (0, Support_1.defined)(propertyNames.get(jsonName));
            return (0, Support_1.defined)(this.names.get(name));
          });
        } else {
          return properties;
        }
      }
      forEachClassProperty(o, blankLocations, f) {
        const propertyNames = (0, Support_1.defined)(this._propertyNamesStoreView).get(o);
        const sortedProperties = this.sortClassProperties(o.getProperties(), propertyNames);
        this.forEachWithBlankLines(sortedProperties, blankLocations, (p, jsonName, pos) => {
          const name = (0, Support_1.defined)(propertyNames.get(jsonName));
          f(name, jsonName, p, pos);
        });
      }
      nameForUnionMember(u, t) {
        return (0, Support_1.defined)((0, Support_1.defined)(this._memberNamesStoreView).get(u).get(t));
      }
      nameForEnumCase(e, caseName) {
        const caseNames = (0, Support_1.defined)(this._caseNamesStoreView).get(e);
        return (0, Support_1.defined)(caseNames.get(caseName));
      }
      forEachUnionMember(u, members, blankLocations, sortOrder, f) {
        const iterateMembers = members !== null && members !== void 0 ? members : u.members;
        if (sortOrder === null) {
          sortOrder = (n) => (0, Support_1.defined)(this.names.get(n));
        }
        const memberNames = (0, collection_utils_1.mapFilter)((0, Support_1.defined)(this._memberNamesStoreView).get(u), (_, t) => iterateMembers.has(t));
        const sortedMemberNames = (0, collection_utils_1.mapSortBy)(memberNames, sortOrder);
        this.forEachWithBlankLines(sortedMemberNames, blankLocations, f);
      }
      forEachEnumCase(e, blankLocations, f) {
        const caseNames = (0, Support_1.defined)(this._caseNamesStoreView).get(e);
        const sortedCaseNames = (0, collection_utils_1.mapSortBy)(caseNames, (n) => (0, Support_1.defined)(this.names.get(n)));
        this.forEachWithBlankLines(sortedCaseNames, blankLocations, f);
      }
      forEachTransformation(blankLocations, f) {
        this.forEachWithBlankLines((0, Support_1.defined)(this._namesForTransformations), blankLocations, f);
      }
      forEachSpecificNamedType(blankLocations, types, f) {
        this.forEachWithBlankLines(types, blankLocations, (t, _, pos) => f(t, this.nameForNamedType(t), pos));
      }
      forEachObject(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, (0, Support_1.defined)(this._namedObjects).entries(), f);
      }
      forEachEnum(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, this.enums.entries(), f);
      }
      forEachUnion(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, this.namedUnions.entries(), f);
      }
      forEachUniqueUnion(blankLocations, uniqueValue, f) {
        const firstUnionByValue = /* @__PURE__ */ new Map();
        for (const u of this.namedUnions) {
          const v = uniqueValue(u);
          if (!firstUnionByValue.has(v)) {
            firstUnionByValue.set(v, u);
          }
        }
        this.forEachWithBlankLines(firstUnionByValue, blankLocations, f);
      }
      forEachNamedType(blankLocations, objectFunc, enumFunc, unionFunc) {
        this.forEachWithBlankLines((0, Support_1.defined)(this._namedTypes).entries(), blankLocations, (t, _, pos) => {
          const name = this.nameForNamedType(t);
          if (t instanceof Type_1.ObjectType) {
            objectFunc(t, name, pos);
          } else if (t instanceof Type_1.EnumType) {
            enumFunc(t, name, pos);
          } else if (t instanceof Type_1.UnionType) {
            unionFunc(t, name, pos);
          } else {
            return (0, Support_1.panic)("Named type that's neither a class nor union");
          }
        });
      }
      // You should never have to use this to produce parts of your generated
      // code.  If you need to modify a Name, for example to change its casing,
      // use `modifySource`.
      sourcelikeToString(src) {
        return (0, Source_1.serializeRenderResult)((0, Source_1.sourcelikeToSource)(src), this.names, "").lines.join("\n");
      }
      get commentLineStart() {
        return "// ";
      }
      emitComments(comments) {
        comments.forEach((comment) => {
          if ((0, Comments_1.isStringComment)(comment)) {
            this.emitCommentLines([comment]);
          } else if ("lines" in comment) {
            this.emitCommentLines(comment.lines);
          } else if ("descriptionBlock" in comment) {
            this.emitDescriptionBlock(comment.descriptionBlock);
          } else {
            this.emitCommentLines(comment.customLines, comment);
          }
          this.ensureBlankLine();
        });
      }
      emitCommentLines(lines, { lineStart = this.commentLineStart, firstLineStart = lineStart, lineEnd, beforeComment, afterComment } = {}) {
        if (beforeComment !== void 0) {
          this.emitLine(beforeComment);
        }
        let first = true;
        for (const line of lines) {
          let start = first ? firstLineStart : lineStart;
          first = false;
          if (this.sourcelikeToString(line) === "") {
            start = (0, Strings_1.trimEnd)(start);
          }
          if (lineEnd) {
            this.emitLine(start, line, lineEnd);
          } else {
            this.emitLine(start, line);
          }
        }
        if (afterComment !== void 0) {
          this.emitLine(afterComment);
        }
      }
      emitDescription(description) {
        if (description === void 0)
          return;
        this.emitDescriptionBlock(description);
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines);
      }
      emitPropertyTable(c, makePropertyRow) {
        let table = [];
        const emitTable = () => {
          if (table.length === 0)
            return;
          this.emitTable(table);
          table = [];
        };
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const description = this.descriptionForClassProperty(c, jsonName);
          if (description !== void 0) {
            emitTable();
            this.emitDescription(description);
          }
          table.push(makePropertyRow(name, jsonName, p));
        });
        emitTable();
      }
      processGraph() {
        this._declarationIR = (0, DeclarationIR_1.declarationsForGraph)(this.typeGraph, this.needsTypeDeclarationBeforeUse ? (t) => this.canBeForwardDeclared(t) : void 0, (t) => this.childrenOfType(t), (t) => {
          if (t instanceof Type_1.UnionType) {
            return this.unionNeedsName(t);
          }
          return (0, TypeUtils_1.isNamedType)(t);
        });
        const types = this.typeGraph.allTypesUnordered();
        this._haveUnions = (0, collection_utils_1.iterableSome)(types, (t) => t instanceof Type_1.UnionType);
        this._haveMaps = (0, collection_utils_1.iterableSome)(types, (t) => t instanceof Type_1.MapType);
        const classTypes = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.ClassType);
        this._haveOptionalProperties = (0, collection_utils_1.iterableSome)(classTypes, (c) => (0, collection_utils_1.mapSome)(c.getProperties(), (p) => p.isOptional));
        this._namedTypes = this._declarationIR.declarations.filter((d) => d.kind === "define").map((d) => d.type);
        const { objects, enums, unions } = (0, TypeUtils_1.separateNamedTypes)(this._namedTypes);
        this._namedObjects = new Set(objects);
        this._namedEnums = new Set(enums);
        this._namedUnions = new Set(unions);
      }
      emitSource(givenOutputFilename) {
        this.processGraph();
        this.emitSourceStructure(givenOutputFilename);
      }
      forEachType(process2) {
        const visitedTypes = /* @__PURE__ */ new Set();
        const processed = /* @__PURE__ */ new Set();
        const queue = Array.from(this.typeGraph.topLevels.values());
        function visit3(t) {
          if (visitedTypes.has(t))
            return;
          for (const c of t.getChildren()) {
            queue.push(c);
          }
          visitedTypes.add(t);
          processed.add(process2(t));
        }
        for (; ; ) {
          const maybeType = queue.pop();
          if (maybeType === void 0) {
            break;
          }
          visit3(maybeType);
        }
        return processed;
      }
    };
    exports.ConvenienceRenderer = ConvenienceRenderer;
  }
});

// node_modules/quicktype-core/dist/DateTime.js
var require_DateTime = __commonJS({
  "node_modules/quicktype-core/dist/DateTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultDateTimeRecognizer = void 0;
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
    var DATE_TIME_SEPARATOR = /t|\s/i;
    var DefaultDateTimeRecognizer = class {
      isDate(str) {
        const matches = DATE.exec(str);
        if (matches === null)
          return false;
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
      }
      isTime(str) {
        const matches = TIME.exec(str);
        if (matches === null)
          return false;
        const hour = +matches[1];
        const minute = +matches[2];
        const second = +matches[3];
        return hour <= 23 && minute <= 59 && second <= 59;
      }
      isDateTime(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && this.isDate(dateTime[0]) && this.isTime(dateTime[1]);
      }
    };
    exports.DefaultDateTimeRecognizer = DefaultDateTimeRecognizer;
  }
});

// node_modules/quicktype-core/dist/TargetLanguage.js
var require_TargetLanguage = __commonJS({
  "node_modules/quicktype-core/dist/TargetLanguage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TargetLanguage = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var DateTime_1 = require_DateTime();
    var Source_1 = require_Source();
    var Support_1 = require_Support();
    var TargetLanguage = class {
      constructor(displayName, names, extension) {
        this.displayName = displayName;
        this.names = names;
        this.extension = extension;
      }
      get optionDefinitions() {
        return this.getOptions().map((o) => o.definition);
      }
      get cliOptionDefinitions() {
        let actual = [];
        let display = [];
        for (const { cliDefinitions } of this.getOptions()) {
          actual = actual.concat(cliDefinitions.actual);
          display = display.concat(cliDefinitions.display);
        }
        return { actual, display };
      }
      get name() {
        return (0, Support_1.defined)(this.names[0]);
      }
      renderGraphAndSerialize(typeGraph, givenOutputFilename, alphabetizeProperties, leadingComments, rendererOptions, indentation) {
        if (indentation === void 0) {
          indentation = this.defaultIndentation;
        }
        const renderContext = { typeGraph, leadingComments };
        const renderer = this.makeRenderer(renderContext, rendererOptions);
        if (renderer instanceof ConvenienceRenderer_1.ConvenienceRenderer) {
          renderer.setAlphabetizeProperties(alphabetizeProperties);
        }
        const renderResult = renderer.render(givenOutputFilename);
        return (0, collection_utils_1.mapMap)(renderResult.sources, (s) => (0, Source_1.serializeRenderResult)(s, renderResult.names, (0, Support_1.defined)(indentation)));
      }
      get defaultIndentation() {
        return "    ";
      }
      get stringTypeMapping() {
        return /* @__PURE__ */ new Map();
      }
      get supportsOptionalClassProperties() {
        return false;
      }
      get supportsUnionsWithBothNumberTypes() {
        return false;
      }
      get supportsFullObjectType() {
        return false;
      }
      needsTransformerForType(_t) {
        return false;
      }
      get dateTimeRecognizer() {
        return new DateTime_1.DefaultDateTimeRecognizer();
      }
    };
    exports.TargetLanguage = TargetLanguage;
  }
});

// node_modules/quicktype-core/dist/language/CJSON.js
var require_CJSON = __commonJS({
  "node_modules/quicktype-core/dist/language/CJSON.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CJSONRenderer = exports.IncludeKind = exports.GlobalNames = exports.CJSONTargetLanguage = exports.cJSONOptions = void 0;
    var AccessorNames_1 = require_AccessorNames();
    var EnumValues_1 = require_EnumValues();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var pascalValue = ["pascal-case", "pascal"];
    var underscoreValue = ["underscore-case", "underscore"];
    var camelValue = ["camel-case", "camel"];
    var upperUnderscoreValue = ["upper-underscore-case", "upper-underscore"];
    var pascalUpperAcronymsValue = ["pascal-case-upper-acronyms", "pascal-upper-acronyms"];
    var camelUpperAcronymsValue = ["camel-case-upper-acronyms", "camel-upper-acronyms"];
    exports.cJSONOptions = {
      typeSourceStyle: new RendererOptions_1.EnumOption("source-style", "Source code generation type, whether to generate single or multiple source files", [
        ["single-source", true],
        ["multi-source", false]
      ], "single-source", "secondary"),
      typeIntegerSize: new RendererOptions_1.EnumOption("integer-size", "Integer code generation type (int64_t by default)", [
        ["int8_t", "int8_t"],
        ["int16_t", "int16_t"],
        ["int32_t", "int32_t"],
        ["int64_t", "int64_t"]
      ], "int64_t", "secondary"),
      hashtableSize: new RendererOptions_1.StringOption("hashtable-size", "Hashtable size, used when maps are created (64 by default)", "SIZE", "64"),
      addTypedefAlias: new RendererOptions_1.EnumOption("typedef-alias", "Add typedef alias to unions, structs, and enums (no typedef by default)", [
        ["no-typedef", false],
        ["add-typedef", true]
      ], "no-typedef", "secondary"),
      printStyle: new RendererOptions_1.EnumOption("print-style", "Which cJSON print should be used (formatted by default)", [
        ["print-formatted", false],
        ["print-unformatted", true]
      ], "print-formatted", "secondary"),
      typeNamingStyle: new RendererOptions_1.EnumOption("type-style", "Naming style for types", [
        pascalValue,
        underscoreValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
      ]),
      memberNamingStyle: new RendererOptions_1.EnumOption("member-style", "Naming style for members", [
        underscoreValue,
        pascalValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
      ]),
      enumeratorNamingStyle: new RendererOptions_1.EnumOption("enumerator-style", "Naming style for enumerators", [
        upperUnderscoreValue,
        underscoreValue,
        pascalValue,
        camelValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
      ])
    };
    var CJSONTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      /**
       * Constructor
       * @param displayName: display name
       * @params names: names
       * @param extension: extension of files
       */
      constructor(displayName = "C (cJSON)", names = ["cjson", "cJSON"], extension = "h") {
        super(displayName, names, extension);
      }
      /**
       * Return cJSON generator options
       * @return cJSON generator options array
       */
      getOptions() {
        return [
          exports.cJSONOptions.typeSourceStyle,
          exports.cJSONOptions.typeIntegerSize,
          exports.cJSONOptions.addTypedefAlias,
          exports.cJSONOptions.printStyle,
          exports.cJSONOptions.hashtableSize,
          exports.cJSONOptions.typeNamingStyle,
          exports.cJSONOptions.memberNamingStyle,
          exports.cJSONOptions.enumeratorNamingStyle
        ];
      }
      /**
       * Indicate if language support union with both number types
       * @return true
       */
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      /**
       * Indicate if language support optional class properties
       * @return true
       */
      get supportsOptionalClassProperties() {
        return true;
      }
      /**
       * Create renderer
       * @param renderContext: render context
       * @param untypedOptionValues
       * @return cJSON renderer
       */
      makeRenderer(renderContext, untypedOptionValues) {
        return new CJSONRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.cJSONOptions, untypedOptionValues));
      }
    };
    exports.CJSONTargetLanguage = CJSONTargetLanguage;
    var legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    var keywords = [
      /* C and C++ keywords */
      "alignas",
      "alignof",
      "and",
      "and_eq",
      "asm",
      "atomic_cancel",
      "atomic_commit",
      "atomic_noexcept",
      "auto",
      "bitand",
      "bitor",
      "bool",
      "break",
      "case",
      "catch",
      "char",
      "char16_t",
      "char32_t",
      "class",
      "compl",
      "concept",
      "const",
      "constexpr",
      "const_cast",
      "continue",
      "co_await",
      "co_return",
      "co_yield",
      "decltype",
      "default",
      "delete",
      "do",
      "double",
      "dynamic_cast",
      "else",
      "enum",
      "explicit",
      "export",
      "extern",
      "false",
      "float",
      "for",
      "friend",
      "goto",
      "if",
      "import",
      "inline",
      "int",
      "long",
      "module",
      "mutable",
      "namespace",
      "new",
      "noexcept",
      "not",
      "not_eq",
      "nullptr",
      "operator",
      "or",
      "or_eq",
      "private",
      "protected",
      "public",
      "register",
      "reinterpret_cast",
      "requires",
      "restrict",
      "return",
      "short",
      "signed",
      "sizeof",
      "static",
      "static_assert",
      "static_cast",
      "struct",
      "switch",
      "synchronized",
      "template",
      "this",
      "thread_local",
      "throw",
      "true",
      "try",
      "typedef",
      "typeid",
      "typename",
      "typeof",
      "union",
      "unsigned",
      "using",
      "virtual",
      "void",
      "volatile",
      "wchar_t",
      "while",
      "xor",
      "xor_eq",
      "override",
      "final",
      "transaction_safe",
      "transaction_safe_dynamic",
      "NULL",
      /* cJSON keywords */
      "Array",
      "ArrayReference",
      "Bool",
      "DoubleArray",
      "False",
      "FloatArray",
      "IntArray",
      "Object",
      "Null",
      "Number",
      "Raw",
      "String",
      "StringArray",
      "StringReference",
      "True"
    ];
    var GlobalNames;
    (function(GlobalNames2) {
      GlobalNames2[GlobalNames2["ClassMemberConstraints"] = 1] = "ClassMemberConstraints";
      GlobalNames2[GlobalNames2["ClassMemberConstraintException"] = 2] = "ClassMemberConstraintException";
      GlobalNames2[GlobalNames2["ValueTooLowException"] = 3] = "ValueTooLowException";
      GlobalNames2[GlobalNames2["ValueTooHighException"] = 4] = "ValueTooHighException";
      GlobalNames2[GlobalNames2["ValueTooShortException"] = 5] = "ValueTooShortException";
      GlobalNames2[GlobalNames2["ValueTooLongException"] = 6] = "ValueTooLongException";
      GlobalNames2[GlobalNames2["InvalidPatternException"] = 7] = "InvalidPatternException";
      GlobalNames2[GlobalNames2["CheckConstraint"] = 8] = "CheckConstraint";
    })(GlobalNames = exports.GlobalNames || (exports.GlobalNames = {}));
    var IncludeKind;
    (function(IncludeKind2) {
      IncludeKind2["ForwardDeclare"] = "ForwardDeclare";
      IncludeKind2["Include"] = "Include";
    })(IncludeKind = exports.IncludeKind || (exports.IncludeKind = {}));
    var CJSONRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      /**
       * Constructor
       * @param targetLanguage: target language
       * @param renderContext: render context
       * @param _options: renderer options
       */
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this.typeIntegerSize = _options.typeIntegerSize;
        this.hashtableSize = _options.hashtableSize;
        this.typeNamingStyle = _options.typeNamingStyle;
        this.namedTypeNameStyle = (0, Strings_1.makeNameStyle)(this.typeNamingStyle, legalizeName);
        this.enumeratorNamingStyle = _options.enumeratorNamingStyle;
        this.memberNameStyle = (0, Strings_1.makeNameStyle)(_options.memberNamingStyle, legalizeName);
        this.forbiddenGlobalNames = [];
        for (const type of (0, Support_1.numberEnumValues)(GlobalNames)) {
          const genName = this.namedTypeNameStyle(GlobalNames[type]);
          this.forbiddenGlobalNames.push(genName);
        }
      }
      /**
       * Build forbidden names for namespace
       * @return Forbidden names for namespace
       */
      forbiddenNamesForGlobalNamespace() {
        return [...keywords, ...this.forbiddenGlobalNames];
      }
      /**
       * Build forbidden names for enums
       * @return Forbidden names for enums
       */
      forbiddenForEnumCases(_enumType, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      /**
       * Build forbidden names for unions members
       * @return Forbidden names for unions members
       */
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
      }
      /**
       * Build forbidden names for objects
       * @return Forbidden names for objects
       */
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      /**
       * Build types member names
       * @return types member namer
       */
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", this.namedTypeNameStyle);
      }
      /**
       * Build object properties member names
       * @return object properties member namer
       */
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("members", this.memberNameStyle);
      }
      /**
       * Build union member names
       * @return union member namer
       */
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("members", this.memberNameStyle);
      }
      /**
       * Build enum member names
       * @return enum member namer
       */
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enumerators", (0, Strings_1.makeNameStyle)(this.enumeratorNamingStyle, legalizeName));
      }
      /**
       * Override of super proposeUnionMemberName function
       * @param unionType: union type
       * @param unionName: union name
       * @param fieldType: field type
       * @param lookup: Lookup function
       * @return Proposed union member name
       */
      proposeUnionMemberName(unionType, unionName, fieldType, lookup) {
        let fieldName = super.proposeUnionMemberName(unionType, unionName, fieldType, lookup);
        if ("bool" === fieldName) {
          fieldName = "boolean";
        } else if ("double" === fieldName) {
          fieldName = "number";
        }
        return fieldName;
      }
      /**
       * Function called to emit typedef alias for a a given type
       * @param fieldType: the variable type
       * @param fieldName: name of the variable
       */
      emitTypedefAlias(fieldType, fieldName) {
        if (this._options.addTypedefAlias) {
          this.emitLine("typedef ", this.quicktypeTypeToCJSON(fieldType, false).cType, " ", fieldName, ";");
          this.ensureBlankLine();
        }
      }
      /**
       * Function called to create header file(s)
       * @param proposedFilename: source filename provided from stdin
       */
      emitSourceStructure(proposedFilename) {
        if (this._options.typeSourceStyle) {
          this.emitSingleSourceStructure(proposedFilename);
        } else {
          this.emitMultiSourceStructure();
        }
      }
      /**
       * Function called to create a single header file with types and generators
       * @param proposedFilename: source filename provided from stdin
       */
      emitSingleSourceStructure(proposedFilename) {
        this.startFile(proposedFilename);
        this.forEachDeclaration("leading-and-interposing", (decl) => {
          if (decl.kind === "forward") {
            this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
          } else if (decl.kind === "define") {
            const type = decl.type;
            if (type instanceof Type_1.ClassType) {
              this.emitClassTypedef(type);
            } else if (type instanceof Type_1.EnumType) {
              this.emitEnumTypedef(type);
            } else if (type instanceof Type_1.UnionType) {
              this.emitUnionTypedef(type);
            } else {
              (0, Support_1.panic)("Cannot declare type");
            }
          } else {
            (0, Support_1.assertNever)(decl.kind);
          }
        });
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelTypedef(type, className), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
        this.forEachEnum("leading-and-interposing", (enumType, _enumName) => this.emitEnumPrototypes(enumType));
        this.forEachUnion("leading-and-interposing", (unionType) => this.emitUnionPrototypes(unionType));
        this.forEachObject("leading-and-interposing", (classType, _className) => this.emitClassPrototypes(classType));
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelPrototypes(type, className), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
        this.forEachEnum("leading-and-interposing", (enumType, _enumName) => this.emitEnumFunctions(enumType));
        this.forEachUnion("leading-and-interposing", (unionType) => this.emitUnionFunctions(unionType));
        this.forEachObject("leading-and-interposing", (classType, _className) => this.emitClassFunctions(classType));
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelFunctions(type, className), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
        this.finishFile();
      }
      /**
       * Function called to create a multiple header files with types and generators
       */
      emitMultiSourceStructure() {
        let includes;
        this.forEachNamedType("leading-and-interposing", (classType, _name) => {
          this.emitClass(classType, includes);
        }, (enumType, _name) => {
          this.emitEnum(enumType, includes);
        }, (unionType, _name) => {
          this.emitUnion(unionType, includes);
        });
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevel(type, className, includes), (type) => this.namedTypeToNameForTopLevel(type) === void 0);
      }
      /**
       * Function called to create an enum header files with types and generators
       * @param enumType: enum type
       * @param includes: Array of includes
       */
      emitEnum(enumType, includes) {
        const enumName = this.nameForNamedType(enumType);
        const filename = this.sourcelikeToString(enumName).concat(".h");
        includes.push(filename);
        this.startFile(filename);
        this.emitIncludes(enumType, this.sourcelikeToString(filename));
        this.emitEnumTypedef(enumType);
        this.emitEnumPrototypes(enumType);
        this.emitEnumFunctions(enumType);
        this.finishFile();
      }
      /**
       * Function called to create enum typedef
       * @param enumType: enum type
       */
      emitEnumTypedef(enumType) {
        const enumName = this.nameForNamedType(enumType);
        const enumValues = (0, EnumValues_1.enumCaseValues)(enumType, this.targetLanguage.name);
        this.emitDescription(this.descriptionForType(enumType));
        this.emitBlock(["enum ", enumName], () => {
          const combinedName = (0, Strings_1.allUpperWordStyle)(this.sourcelikeToString(enumName));
          this.forEachEnumCase(enumType, "none", (name, jsonName) => {
            if (enumValues !== void 0) {
              const [enumValue] = (0, AccessorNames_1.getAccessorName)(enumValues, jsonName);
              if (enumValue !== void 0) {
                this.emitLine(combinedName, "_", name, " = ", enumValue.toString(), ",");
              } else {
                this.emitLine(combinedName, "_", name, ",");
              }
            } else {
              this.emitLine(combinedName, "_", name, ",");
            }
          });
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(enumType, enumName);
      }
      /**
       * Function called to create enum prototypes
       * @param enumType: enum type
       */
      emitEnumPrototypes(enumType) {
        const enumName = this.nameForNamedType(enumType);
        this.emitLine("enum ", enumName, " cJSON_Get", enumName, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", enumName, "(", this.withConst(["enum ", enumName]), " x);");
        this.ensureBlankLine();
      }
      /**
       * Function called to create enum functions
       * @param enumType: enum type
       */
      emitEnumFunctions(enumType) {
        const enumName = this.nameForNamedType(enumType);
        this.emitBlock(["enum ", enumName, " cJSON_Get", enumName, "Value(", this.withConst("cJSON"), " * j)"], () => {
          this.emitLine("enum ", enumName, " x = 0;");
          this.emitBlock(["if (NULL != j)"], () => {
            let onFirst = true;
            const combinedName = (0, Strings_1.allUpperWordStyle)(this.sourcelikeToString(enumName));
            this.forEachEnumCase(enumType, "none", (name, jsonName) => {
              this.emitLine(onFirst ? "" : "else ", 'if (!strcmp(cJSON_GetStringValue(j), "', jsonName, '")) x = ', combinedName, "_", name, ";");
              onFirst = false;
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock(["cJSON * cJSON_Create", enumName, "(", this.withConst(["enum ", enumName]), " x)"], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock(["switch (x)"], () => {
            const combinedName = (0, Strings_1.allUpperWordStyle)(this.sourcelikeToString(enumName));
            this.forEachEnumCase(enumType, "none", (name, jsonName) => {
              this.emitLine("case ", combinedName, "_", name, ': j = cJSON_CreateString("', jsonName, '"); break;');
            });
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
      }
      /**
       * Function called to create a union header files with types and generators
       * @param unionType: union type
       * @param includes: Array of includes
       */
      emitUnion(unionType, includes) {
        const unionName = this.nameForNamedType(unionType);
        const filename = this.sourcelikeToString(unionName).concat(".h");
        includes.push(filename);
        this.startFile(filename);
        this.emitIncludes(unionType, this.sourcelikeToString(filename));
        this.emitUnionTypedef(unionType);
        this.emitUnionPrototypes(unionType);
        this.emitUnionFunctions(unionType);
        this.finishFile();
      }
      /**
       * Function called to create union typedef
       * @param unionType: union type
       */
      emitUnionTypedef(unionType) {
        const [_hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
        const unionName = this.nameForNamedType(unionType);
        this.emitDescription(this.descriptionForType(unionType));
        this.emitBlock(["struct ", unionName], () => {
          this.emitLine("int type;");
          this.emitBlock(["union"], () => {
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " ", this.nameForUnionMember(unionType, type), ";");
            }
          }, "value", true);
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(unionType, unionName);
      }
      /**
       * Function called to create union prototypes
       * @param unionType: union type
       */
      emitUnionPrototypes(unionType) {
        const unionName = this.nameForNamedType(unionType);
        this.emitLine("struct ", unionName, " * cJSON_Get", unionName, "Value(const cJSON * j);");
        this.emitLine("cJSON * cJSON_Create", unionName, "(", this.withConst(["struct ", unionName]), " * x);");
        this.emitLine("void cJSON_Delete", unionName, "(struct ", unionName, " * x);");
        this.ensureBlankLine();
      }
      /**
       * Function called to create union functions
       * @param unionType: union type
       */
      emitUnionFunctions(unionType) {
        const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
        const unionName = this.nameForNamedType(unionType);
        this.emitBlock(["struct ", unionName, " * cJSON_Get", unionName, "Value(const cJSON * j)"], () => {
          let onFirst = true;
          this.emitLine("struct ", unionName, " * x = cJSON_malloc(sizeof(struct ", unionName, "));");
          this.emitBlock(["if (NULL != x)"], () => {
            this.emitLine("memset(x, 0, sizeof(struct ", unionName, "));");
            if (hasNull !== null) {
              this.emitBlock(["if (cJSON_IsNull(j))"], () => {
                this.emitLine("x->type = cJSON_NULL;");
              });
              onFirst = false;
            }
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitBlock([onFirst === true ? "if (" : "else if (", cJSON.isType, "(j))"], () => {
                this.emitLine("x->type = ", cJSON.cjsonType, ";");
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_create(false, NULL);");
                  this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                    this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                    this.emitBlock([
                      "cJSON_ArrayForEach(e",
                      child_level.toString(),
                      ", j",
                      level > 0 ? level.toString() : "",
                      ")"
                    ], () => {
                      var _a;
                      const add = (cJSON2, level2, child_level2) => {
                        var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                        if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                        } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine("list_add_tail(x", child_level2.toString(), ", (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                        } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                          this.emitLine("list_add_tail(x", child_level2.toString(), ", strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e", child_level2.toString(), ")), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                        } else if (((_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cjsonType) === "cJSON_Object" || ((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Union") {
                          this.emitLine("list_add_tail(x", child_level2.toString(), ", ", (_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.getValue, "(e", child_level2.toString(), "), sizeof(", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.cType, " *));");
                        } else {
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType,
                            " * tmp",
                            level2 > 0 ? level2.toString() : "",
                            " = cJSON_malloc(sizeof(",
                            (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                            "));"
                          );
                          this.emitBlock(["if (NULL != tmp", level2 > 0 ? level2.toString() : "", ")"], () => {
                            var _a3, _b2;
                            this.emitLine(
                              "* tmp",
                              level2 > 0 ? level2.toString() : "",
                              " = ",
                              // @ts-expect-error awaiting refactor
                              (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                              "(e",
                              child_level2.toString(),
                              ");"
                            );
                            this.emitLine(
                              "list_add_tail(x",
                              child_level2.toString(),
                              ", tmp",
                              level2 > 0 ? level2.toString() : "",
                              ", sizeof(",
                              // @ts-expect-error awaiting refactor
                              (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                              " *));"
                            );
                          });
                        }
                      };
                      if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                        this.emitBlock(["if (!cJSON_IsNull(e", child_level.toString(), "))"], () => {
                          add(cJSON, level, child_level);
                        });
                        this.emitBlock(["else"], () => {
                          this.emitLine("list_add_tail(x", child_level.toString(), ", (void *)0xDEADBEEF, sizeof(void *));");
                        });
                      } else {
                        add(cJSON, level, child_level);
                      }
                    });
                    this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = x", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine(cJSON.cType, " * x", child_level.toString(), " = hashtable_create(", this.hashtableSize, ", false);");
                  this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                    this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                    this.emitBlock([
                      "cJSON_ArrayForEach(e",
                      child_level.toString(),
                      ", j",
                      level > 0 ? level.toString() : "",
                      ")"
                    ], () => {
                      var _a;
                      const add = (cJSON2, level2, child_level2) => {
                        var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                        if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                        } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                        } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                          this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e", child_level2.toString(), ")), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                        } else if (((_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cjsonType) === "cJSON_Object" || ((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Union") {
                          this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, ", (_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.getValue, "(e", child_level2.toString(), "), sizeof(", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.cType, " *));");
                        } else {
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType,
                            " * tmp",
                            level2 > 0 ? level2.toString() : "",
                            " = cJSON_malloc(sizeof(",
                            (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                            "));"
                          );
                          this.emitBlock(["if (NULL != tmp", level2 > 0 ? level2.toString() : "", ")"], () => {
                            var _a3, _b2;
                            this.emitLine(
                              "* tmp",
                              level2 > 0 ? level2.toString() : "",
                              " = ",
                              // @ts-expect-error awaiting refactor
                              (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                              "(e",
                              child_level2.toString(),
                              ");"
                            );
                            this.emitLine(
                              "hashtable_add(x",
                              child_level2.toString(),
                              ", e",
                              child_level2.toString(),
                              "->string, tmp",
                              level2 > 0 ? level2.toString() : "",
                              ", sizeof(",
                              // @ts-expect-error awaiting refactor
                              (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                              " *));"
                            );
                          });
                        }
                      };
                      if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                        this.emitBlock(["if (!cJSON_IsNull(e", child_level.toString(), "))"], () => {
                          add(cJSON, level, child_level);
                        });
                        this.emitBlock(["else"], () => {
                          this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (void *)0xDEADBEEF, sizeof(void *));");
                        });
                      } else {
                        add(cJSON, level, child_level);
                      }
                    });
                    this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = x", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                  this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = (", cJSON.cType, " *)0xDEADBEEF;");
                } else if (cJSON.cjsonType === "cJSON_String") {
                  this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = strdup(", cJSON.getValue, "(j));");
                } else {
                  this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = ", cJSON.getValue, "(j);");
                }
              });
              onFirst = false;
            }
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock(["cJSON * cJSON_Create", unionName, "(", this.withConst(["struct ", unionName]), " * x)"], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock(["if (NULL != x)"], () => {
            let onFirst = true;
            if (hasNull !== null) {
              this.emitBlock(["if (cJSON_NULL == x->type)"], () => {
                this.emitLine("j = cJSON_CreateNull();");
              });
              onFirst = false;
            }
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitBlock([onFirst === true ? "if (" : "else if (", cJSON.cjsonType, " == x->type)"], () => {
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                  this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                    var _a;
                    this.emitLine(
                      // @ts-expect-error awaiting refactor
                      (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                      " * x",
                      child_level.toString(),
                      " = list_get_head(x",
                      level > 0 ? level.toString() : "",
                      "->value.",
                      this.nameForUnionMember(unionType, type),
                      ");"
                    );
                    this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                      var _a2;
                      const add = (cJSON2, child_level2) => {
                        var _a3, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                        if (((_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.cjsonType) === "cJSON_Array") {
                        } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                        } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                        } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                          this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                        } else {
                          this.emitLine(
                            "cJSON_AddItemToArray(j",
                            child_level2.toString(),
                            ", ",
                            // @ts-expect-error awaiting refactor
                            (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                            "(*x",
                            child_level2.toString(),
                            "));"
                          );
                        }
                      };
                      if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                        this.emitBlock(["if ((void *)0xDEADBEEF != x", child_level.toString(), ")"], () => {
                          add(cJSON, child_level);
                        });
                        this.emitBlock(["else"], () => {
                          this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", cJSON_CreateNull());");
                        });
                      } else {
                        add(cJSON, child_level);
                      }
                      this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                    });
                    this.emitLine("j = j", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                  this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                    this.emitLine("char **keys", child_level.toString(), " = NULL;");
                    this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ", &keys", child_level.toString(), ");");
                    this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                      this.emitBlock([
                        "for (size_t index",
                        child_level.toString(),
                        " = 0; index",
                        child_level.toString(),
                        " < count",
                        child_level.toString(),
                        "; index",
                        child_level.toString(),
                        "++)"
                      ], () => {
                        var _a, _b;
                        this.emitLine(
                          // @ts-expect-error awaiting refactor
                          (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                          " *x",
                          child_level.toString(),
                          " = hashtable_lookup(x",
                          level > 0 ? level.toString() : "",
                          "->value.",
                          this.nameForUnionMember(unionType, type),
                          ", keys",
                          child_level.toString(),
                          "[index",
                          child_level.toString(),
                          "]);"
                        );
                        const add = (cJSON2, child_level2) => {
                          var _a2, _b2, _d, _e, _f, _g, _h, _j, _k, _l;
                          if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                          } else if (((_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cjsonType) === "cJSON_Map") {
                          } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                          } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                            this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                          } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                            this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                          } else {
                            this.emitLine(
                              cJSON2.addToObject,
                              "(j",
                              child_level2.toString(),
                              ", keys",
                              child_level2.toString(),
                              "[index",
                              child_level2.toString(),
                              "], ",
                              // @ts-expect-error awaiting refactor
                              (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                              "(*x",
                              child_level2.toString(),
                              "));"
                            );
                          }
                        };
                        if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                          this.emitBlock([
                            "if ((void *)0xDEADBEEF != x",
                            child_level.toString(),
                            ")"
                          ], () => {
                            add(cJSON, child_level);
                          });
                          this.emitBlock(["else"], () => {
                            this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], cJSON_CreateNull());");
                          });
                        } else {
                          add(cJSON, child_level);
                        }
                      });
                      this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                    });
                    this.emitLine("j = j", child_level.toString(), ";");
                  });
                } else if (cJSON.cjsonType === "cJSON_Invalid") {
                } else if (cJSON.cjsonType === "cJSON_NULL") {
                  this.emitLine("j = ", cJSON.createObject, "();");
                } else {
                  this.emitLine("j = ", cJSON.createObject, "(x->value.", this.nameForUnionMember(unionType, type), ");");
                }
              });
              onFirst = false;
            }
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
        this.emitBlock(["void cJSON_Delete", unionName, "(struct ", unionName, " * x)"], () => {
          this.emitBlock(["if (NULL != x)"], () => {
            let onFirst = true;
            for (const type of nonNulls) {
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              this.emitBlock([onFirst === true ? "if (" : "else if (", cJSON.cjsonType, " == x->type)"], () => {
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitBlock([
                    "if (NULL != x",
                    level > 0 ? level.toString() : "",
                    "->value.",
                    this.nameForUnionMember(unionType, type),
                    ")"
                  ], () => {
                    var _a;
                    this.emitLine(
                      // @ts-expect-error awaiting refactor
                      (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                      " * x",
                      child_level.toString(),
                      " = list_get_head(x",
                      level > 0 ? level.toString() : "",
                      "->value.",
                      this.nameForUnionMember(unionType, type),
                      ");"
                    );
                    this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                      var _a2, _b, _d, _e, _f, _g;
                      if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                      } else {
                        if ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.isNullable) {
                          this.emitBlock(["if ((void *)0xDEADBEEF != x", child_level.toString(), ")"], () => {
                            var _a3;
                            this.emitLine(
                              // @ts-expect-error awaiting refactor
                              (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                              "(x",
                              child_level.toString(),
                              ");"
                            );
                          });
                        } else {
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.deleteType,
                            "(x",
                            child_level.toString(),
                            ");"
                          );
                        }
                      }
                      this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                    });
                    this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                  });
                } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                  const level = 0;
                  const child_level = 1;
                  this.emitBlock([
                    "if (NULL != x",
                    level > 0 ? level.toString() : "",
                    "->value.",
                    this.nameForUnionMember(unionType, type),
                    ")"
                  ], () => {
                    this.emitLine("char **keys", child_level.toString(), " = NULL;");
                    this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ", &keys", child_level.toString(), ");");
                    this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                      this.emitBlock([
                        "for (size_t index",
                        child_level.toString(),
                        " = 0; index",
                        child_level.toString(),
                        " < count",
                        child_level.toString(),
                        "; index",
                        child_level.toString(),
                        "++)"
                      ], () => {
                        var _a;
                        this.emitLine(
                          // @ts-expect-error awaiting refactor
                          (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                          " *x",
                          child_level.toString(),
                          " = hashtable_lookup(x",
                          level > 0 ? level.toString() : "",
                          "->value.",
                          this.nameForUnionMember(unionType, type),
                          ", keys",
                          child_level.toString(),
                          "[index",
                          child_level.toString(),
                          "]);"
                        );
                        this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                          var _a2, _b, _d, _e, _f, _g;
                          if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                          } else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                          } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          } else {
                            if ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.isNullable) {
                              this.emitBlock([
                                "if ((void *)0xDEADBEEF != x",
                                child_level.toString(),
                                ")"
                              ], () => {
                                var _a3;
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                                  "(x",
                                  child_level.toString(),
                                  ");"
                                );
                              });
                            } else {
                              this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.deleteType,
                                "(x",
                                child_level.toString(),
                                ");"
                              );
                            }
                          }
                        });
                      });
                      this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                    });
                    this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->value.", this.nameForUnionMember(unionType, type), ");");
                  });
                } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                  this.emitLine(cJSON.deleteType, "(x->value.", this.nameForUnionMember(unionType, type), ");");
                } else {
                }
              });
              onFirst = false;
            }
            this.emitLine("cJSON_free(x);");
          });
        });
        this.ensureBlankLine();
      }
      /**
       * Function called to create a class header files with types and generators
       * @param classType: class type
       * @param includes: Array of includes
       */
      emitClass(classType, includes) {
        const className = this.nameForNamedType(classType);
        const filename = this.sourcelikeToString(className).concat(".h");
        includes.push(filename);
        this.startFile(filename);
        this.emitIncludes(classType, this.sourcelikeToString(filename));
        this.emitClassTypedef(classType);
        this.emitClassPrototypes(classType);
        this.emitClassFunctions(classType);
        this.finishFile();
      }
      /**
       * Function called to create class typedef
       * @param classType: class type
       */
      emitClassTypedef(classType) {
        const className = this.nameForNamedType(classType);
        this.emitDescription(this.descriptionForType(classType));
        this.emitBlock(["struct ", className], () => {
          this.forEachClassProperty(classType, "none", (name, jsonName, property) => {
            this.emitDescription(this.descriptionForClassProperty(classType, jsonName));
            const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
            this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " ", name, ";");
          });
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(classType, className);
      }
      /**
       * Function called to create class prototypes
       * @param classType: class type
       */
      emitClassPrototypes(classType) {
        const className = this.nameForNamedType(classType);
        this.emitLine("struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s);");
        this.emitLine("struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("void cJSON_Delete", className, "(struct ", className, " * x);");
        this.ensureBlankLine();
      }
      /**
       * Function called to create class functions
       * @param classType: class type
       */
      emitClassFunctions(classType) {
        const className = this.nameForNamedType(classType);
        this.emitBlock(["struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s)"], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock(["if (NULL != s)"], () => {
            this.emitLine("cJSON * j = cJSON_Parse(s);");
            this.emitBlock(["if (NULL != j)"], () => {
              this.emitLine("x = cJSON_Get", className, "Value(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock(["struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j)"], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock(["if (NULL != j)"], () => {
            this.emitBlock(["if (NULL != (x = cJSON_malloc(sizeof(struct ", className, "))))"], () => {
              this.emitLine("memset(x, 0, sizeof(struct ", className, "));");
              const recur = (type, level) => {
                if (type instanceof Type_1.ArrayType) {
                  const child_level = level + 1;
                  const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                  this.emitLine("list_t * x", child_level.toString(), " = list_create(false, NULL);");
                  this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                    this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                    this.emitBlock(["cJSON_ArrayForEach(e", child_level.toString(), ", e", level.toString(), ")"], () => {
                      var _a;
                      if (cJSON.cjsonType === "cJSON_Array") {
                        const child_level2 = child_level + 1;
                        recur(type.items, child_level);
                        this.emitLine(
                          "list_add_tail(x",
                          child_level.toString(),
                          ", x",
                          child_level2.toString(),
                          ", sizeof(",
                          // @ts-expect-error awaiting refactor
                          (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                          " *));"
                        );
                      } else if (cJSON.cjsonType === "cJSON_Map") {
                      } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                        this.emitLine("list_add_tail(x", child_level.toString(), ", (", cJSON.cType, " *)0xDEADBEEF, sizeof(", cJSON.cType, " *));");
                      } else if (cJSON.cjsonType === "cJSON_String") {
                        this.emitLine("list_add_tail(x", child_level.toString(), ", strdup(", cJSON.getValue, "(e", child_level.toString(), ")), sizeof(", cJSON.cType, " *));");
                      } else if (cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                        this.emitLine("list_add_tail(x", child_level.toString(), ", ", cJSON.getValue, "(e", child_level.toString(), "), sizeof(", cJSON.cType, " *));");
                      } else {
                        this.emitLine(cJSON.cType, " * tmp", level > 0 ? level.toString() : "", " = cJSON_malloc(sizeof(", cJSON.cType, "));");
                        this.emitBlock(["if (NULL != tmp", level > 0 ? level.toString() : "", ")"], () => {
                          this.emitLine("* tmp", level > 0 ? level.toString() : "", " = ", cJSON.getValue, "(e", child_level.toString(), ");");
                          this.emitLine("list_add_tail(x", child_level.toString(), ", tmp", level > 0 ? level.toString() : "", ", sizeof(", cJSON.cType, " *));");
                        });
                      }
                    });
                  });
                } else if (type instanceof Type_1.ClassType) {
                  this.forEachClassProperty(type, "none", (name, jsonName, property) => {
                    const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                    this.emitBlock(!cJSON.isNullable ? [
                      "if (cJSON_HasObjectItem(j",
                      level > 0 ? level.toString() : "",
                      ', "',
                      jsonName,
                      '"))'
                    ] : [
                      "if ((cJSON_HasObjectItem(j",
                      level > 0 ? level.toString() : "",
                      ', "',
                      jsonName,
                      '")) && (!cJSON_IsNull(cJSON_GetObjectItemCaseSensitive(j',
                      level > 0 ? level.toString() : "",
                      ', "',
                      jsonName,
                      '"))))'
                    ], () => {
                      if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                        const child_level = level + 1;
                        this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_create(false, NULL);");
                        this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                          this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                          this.emitLine("cJSON * j", child_level.toString(), " = cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                          this.emitBlock([
                            "cJSON_ArrayForEach(e",
                            child_level.toString(),
                            ", j",
                            child_level.toString(),
                            ")"
                          ], () => {
                            var _a;
                            const add = (type2, cJSON2, level2, child_level2) => {
                              var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                              if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                                if (type2 instanceof Type_1.ArrayType) {
                                  const child_level22 = child_level2 + 1;
                                  recur(type2.items, child_level2);
                                  this.emitLine("list_add_tail(x", child_level2.toString(), ", x", child_level22.toString(), ", sizeof(", (_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                } else {
                                  (0, Support_1.panic)("Invalid type");
                                }
                              } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                              } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                                this.emitLine("list_add_tail(x", child_level2.toString(), ", (", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *)0xDEADBEEF, sizeof(", (_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cType, " *));");
                              } else if (((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_String") {
                                this.emitLine("list_add_tail(x", child_level2.toString(), ", strdup(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.getValue, "(e", child_level2.toString(), ")), sizeof(", (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cType, " *));");
                              } else if (((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Object" || ((_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.cjsonType) === "cJSON_Union") {
                                this.emitLine("list_add_tail(x", child_level2.toString(), ", ", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.getValue, "(e", child_level2.toString(), "), sizeof(", (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType, " *));");
                              } else {
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                                  " * tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  " = cJSON_malloc(sizeof(",
                                  (_s = cJSON2.items) === null || _s === void 0 ? void 0 : _s.cType,
                                  "));"
                                );
                                this.emitBlock([
                                  "if (NULL != tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  ")"
                                ], () => {
                                  var _a3, _b2;
                                  this.emitLine(
                                    "* tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    " = ",
                                    // @ts-expect-error awaiting refactor
                                    (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                                    "(e",
                                    child_level2.toString(),
                                    ");"
                                  );
                                  this.emitLine(
                                    "list_add_tail(x",
                                    child_level2.toString(),
                                    ", tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    ", sizeof(",
                                    // @ts-expect-error awaiting refactor
                                    (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                                    " *));"
                                  );
                                });
                              }
                            };
                            if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                              this.emitBlock([
                                "if (!cJSON_IsNull(e",
                                child_level.toString(),
                                "))"
                              ], () => {
                                add(property.type, cJSON, level, child_level);
                              });
                              this.emitBlock(["else"], () => {
                                this.emitLine("list_add_tail(x", child_level.toString(), ", (void *)0xDEADBEEF, sizeof(void *));");
                              });
                            } else {
                              add(property.type, cJSON, level, child_level);
                            }
                          });
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = x", child_level.toString(), ";");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                        const child_level = level + 1;
                        this.emitLine(cJSON.cType, " * x", child_level.toString(), " = hashtable_create(", this.hashtableSize, ", false);");
                        this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                          this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                          this.emitLine("cJSON * j", child_level.toString(), " = cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                          this.emitBlock([
                            "cJSON_ArrayForEach(e",
                            child_level.toString(),
                            ", j",
                            child_level.toString(),
                            ")"
                          ], () => {
                            var _a;
                            const add = (type2, cJSON2, level2, child_level2) => {
                              var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                              if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                                if (type2 instanceof Type_1.MapType) {
                                  const child_level22 = child_level2 + 1;
                                  recur(type2.values, child_level2);
                                  this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, x", child_level22.toString(), ", sizeof(", (_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                } else {
                                  (0, Support_1.panic)("Invalid type");
                                }
                              } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                              } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                                this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, (", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *)0xDEADBEEF, sizeof(", (_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cType, " *));");
                              } else if (((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_String") {
                                this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, strdup(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.getValue, "(e", child_level2.toString(), ")), sizeof(", (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.cType, " *));");
                              } else if (((_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Object" || ((_o = cJSON2.items) === null || _o === void 0 ? void 0 : _o.cjsonType) === "cJSON_Union") {
                                this.emitLine("hashtable_add(x", child_level2.toString(), ", e", child_level2.toString(), "->string, ", (_p = cJSON2.items) === null || _p === void 0 ? void 0 : _p.getValue, "(e", child_level2.toString(), "), sizeof(", (_q = cJSON2.items) === null || _q === void 0 ? void 0 : _q.cType, " *));");
                              } else {
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_r = cJSON2.items) === null || _r === void 0 ? void 0 : _r.cType,
                                  " * tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  " = cJSON_malloc(sizeof(",
                                  (_s = cJSON2.items) === null || _s === void 0 ? void 0 : _s.cType,
                                  "));"
                                );
                                this.emitBlock([
                                  "if (NULL != tmp",
                                  level2 > 0 ? level2.toString() : "",
                                  ")"
                                ], () => {
                                  var _a3, _b2;
                                  this.emitLine(
                                    "* tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    " = ",
                                    // @ts-expect-error awaiting refactor
                                    (_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.getValue,
                                    "(e",
                                    child_level2.toString(),
                                    ");"
                                  );
                                  this.emitLine(
                                    "hashtable_add(x",
                                    child_level2.toString(),
                                    ", e",
                                    child_level2.toString(),
                                    "->string, tmp",
                                    level2 > 0 ? level2.toString() : "",
                                    ", sizeof(",
                                    // @ts-expect-error awaiting refactor
                                    (_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cType,
                                    " *));"
                                  );
                                });
                              }
                            };
                            if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                              this.emitBlock([
                                "if (!cJSON_IsNull(e",
                                child_level.toString(),
                                "))"
                              ], () => {
                                add(property.type, cJSON, level, child_level);
                              });
                              this.emitBlock(["else"], () => {
                                this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (void *)0xDEADBEEF, sizeof(void *));");
                              });
                            } else {
                              add(property.type, cJSON, level, child_level);
                            }
                          });
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = x", child_level.toString(), ";");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = (", cJSON.cType, " *)0xDEADBEEF;");
                      } else if (cJSON.cjsonType === "cJSON_String") {
                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = strdup(", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '")));');
                      } else if (cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                      } else {
                        if (property.isOptional || cJSON.isNullable) {
                          this.emitBlock([
                            "if (NULL != (x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            " = cJSON_malloc(sizeof(",
                            cJSON.cType,
                            "))))"
                          ], () => {
                            this.emitLine("*x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                          });
                        } else {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                        }
                      }
                    });
                    if (!property.isOptional && !cJSON.isNullable) {
                      if (cJSON.cjsonType === "cJSON_Array") {
                        this.emitBlock(["else"], () => {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = list_create(false, NULL);");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Map") {
                        this.emitBlock(["else"], () => {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = hashtable_create(", this.hashtableSize, ", false);");
                        });
                      } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                        this.emitBlock(["else"], () => {
                          this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = (", cJSON.cType, " *)0xDEADBEEF;");
                        });
                      } else if (cJSON.cjsonType === "cJSON_String") {
                        this.emitBlock(["else"], () => {
                          this.emitBlock([
                            "if (NULL != (x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            " = cJSON_malloc(sizeof(",
                            cJSON.cType,
                            "))))"
                          ], () => {
                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, "[0] = '\\0';");
                          });
                        });
                      } else {
                      }
                    }
                  });
                }
              };
              recur(classType, 0);
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock(["cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock(["if (NULL != x)"], () => {
            this.emitBlock(["if (NULL != (j = cJSON_CreateObject()))"], () => {
              const recur = (type, level) => {
                if (type instanceof Type_1.ArrayType) {
                  const child_level = level + 1;
                  const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                  this.emitLine("cJSON * j", child_level.toString(), " = cJSON_CreateArray();");
                  this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                    this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_get_head(x", level.toString(), ");");
                    this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                      if (cJSON.cjsonType === "cJSON_Array") {
                        const child_level2 = child_level + 1;
                        recur(type.items, child_level);
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", j", child_level2.toString(), ");");
                      } else if (cJSON.cjsonType === "cJSON_Map") {
                      } else if (cJSON.cjsonType === "cJSON_Invalid") {
                      } else if (cJSON.cjsonType === "cJSON_NULL") {
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "());");
                      } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "(x", child_level.toString(), "));");
                      } else {
                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "(*x", child_level.toString(), "));");
                      }
                      this.emitLine("x", child_level.toString(), " = list_get_next(x", level.toString(), ");");
                    });
                  });
                } else if (type instanceof Type_1.ClassType) {
                  this.forEachClassProperty(type, "none", (name, jsonName, property) => {
                    const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                    if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                      const child_level = level + 1;
                      this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                        this.emitLine("cJSON * j", child_level.toString(), " = cJSON_AddArrayToObject(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                        this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                          var _a;
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                            " * x",
                            child_level.toString(),
                            " = list_get_head(x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            ");"
                          );
                          this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                            var _a2;
                            const add = (type2, cJSON2, child_level2) => {
                              var _a3, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                              if (((_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.cjsonType) === "cJSON_Array") {
                                if (type2 instanceof Type_1.ArrayType) {
                                  const child_level22 = child_level2 + 1;
                                  recur(type2.items, child_level2);
                                  this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", j", child_level22.toString(), ");");
                                } else {
                                  (0, Support_1.panic)("Invalid type");
                                }
                              } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                              } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                              } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                              } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                this.emitLine("cJSON_AddItemToArray(j", child_level2.toString(), ", ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                              } else {
                                this.emitLine(
                                  "cJSON_AddItemToArray(j",
                                  child_level2.toString(),
                                  ", ",
                                  // @ts-expect-error awaiting refactor
                                  (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                                  "(*x",
                                  child_level2.toString(),
                                  "));"
                                );
                              }
                            };
                            if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                              this.emitBlock([
                                "if ((void *)0xDEADBEEF != x",
                                child_level.toString(),
                                ")"
                              ], () => {
                                add(property.type, cJSON, child_level);
                              });
                              this.emitBlock(["else"], () => {
                                this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", cJSON_CreateNull());");
                              });
                            } else {
                              add(property.type, cJSON, child_level);
                            }
                            this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->", name, ");");
                          });
                        });
                      });
                    } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                      const child_level = level + 1;
                      this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                        this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                        this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                          this.emitLine("char **keys", child_level.toString(), " = NULL;");
                          this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->", name, ", &keys", child_level.toString(), ");");
                          this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                            this.emitBlock([
                              "for (size_t index",
                              child_level.toString(),
                              " = 0; index",
                              child_level.toString(),
                              " < count",
                              child_level.toString(),
                              "; index",
                              child_level.toString(),
                              "++)"
                            ], () => {
                              var _a, _b;
                              this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                                " *x",
                                child_level.toString(),
                                " = hashtable_lookup(x",
                                level > 0 ? level.toString() : "",
                                "->",
                                name,
                                ", keys",
                                child_level.toString(),
                                "[index",
                                child_level.toString(),
                                "]);"
                              );
                              const add = (type2, cJSON2, child_level2) => {
                                var _a2, _b2, _d, _e, _f, _g, _h, _j, _k, _l;
                                if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                                  if (type2 instanceof Type_1.MapType) {
                                    const child_level22 = child_level2 + 1;
                                    recur(type2.values, child_level2);
                                    this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], j", child_level22.toString(), ");");
                                  } else {
                                    (0, Support_1.panic)("Invalid type");
                                  }
                                } else if (((_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cjsonType) === "cJSON_Map") {
                                } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                                } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                  this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                  this.emitLine(cJSON2.addToObject, "(j", child_level2.toString(), ", keys", child_level2.toString(), "[index", child_level2.toString(), "], ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level2.toString(), "));");
                                } else {
                                  this.emitLine(
                                    cJSON2.addToObject,
                                    "(j",
                                    child_level2.toString(),
                                    ", keys",
                                    child_level2.toString(),
                                    "[index",
                                    child_level2.toString(),
                                    "], ",
                                    // @ts-expect-error awaiting refactor
                                    (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                                    "(*x",
                                    child_level2.toString(),
                                    "));"
                                  );
                                }
                              };
                              if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                                this.emitBlock([
                                  "if ((void *)0xDEADBEEF != x",
                                  child_level.toString(),
                                  ")"
                                ], () => {
                                  add(property.type, cJSON, child_level);
                                });
                                this.emitBlock(["else"], () => {
                                  this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], cJSON_CreateNull());");
                                });
                              } else {
                                add(property.type, cJSON, child_level);
                              }
                            });
                            this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                          });
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", j', child_level.toString(), ");");
                        });
                      });
                    } else if (cJSON.cjsonType === "cJSON_Invalid") {
                    } else if (cJSON.cjsonType === "cJSON_NULL") {
                      if (property.isOptional) {
                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                      }
                    } else if (cJSON.cjsonType === "cJSON_String") {
                      this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", x', level > 0 ? level.toString() : "", "->", name, ");");
                      });
                      if (!property.isOptional && !cJSON.isNullable) {
                        this.emitBlock(["else"], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", "");');
                        });
                      }
                    } else if (cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                      if (property.isOptional || cJSON.isNullable) {
                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                      }
                    } else if (cJSON.cjsonType === "cJSON_Enum") {
                      if (property.isOptional || cJSON.isNullable) {
                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(*x", level > 0 ? level.toString() : "", "->", name, "));");
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                      }
                    } else {
                      if (property.isOptional || cJSON.isNullable) {
                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                          this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", *x', level > 0 ? level.toString() : "", "->", name, ");");
                        });
                      } else {
                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", x', level > 0 ? level.toString() : "", "->", name, ");");
                      }
                    }
                    if (cJSON.isNullable) {
                      this.emitBlock(["else"], () => {
                        this.emitLine("cJSON_AddNullToObject(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                      });
                    }
                  });
                }
              };
              recur(classType, 0);
            });
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
        this.emitBlock(["char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
          this.emitLine("char * s = NULL;");
          this.emitBlock(["if (NULL != x)"], () => {
            this.emitLine("cJSON * j = cJSON_Create", className, "(x);");
            this.emitBlock(["if (NULL != j)"], () => {
              this.emitLine(this._options.printStyle ? "s = cJSON_PrintUnformatted(j);" : "s = cJSON_Print(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return s;");
        });
        this.ensureBlankLine();
        this.emitBlock(["void cJSON_Delete", className, "(struct ", className, " * x)"], () => {
          this.emitBlock(["if (NULL != x)"], () => {
            const recur = (type, level) => {
              if (type instanceof Type_1.ArrayType) {
                const child_level = level + 1;
                const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_get_head(x", level.toString(), ");");
                this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                  if (cJSON.cjsonType === "cJSON_Array") {
                    recur(type.items, child_level);
                    this.emitLine(cJSON.deleteType, "(x", child_level.toString(), ");");
                  } else if (cJSON.cjsonType === "cJSON_Map") {
                  } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                  } else {
                    this.emitLine(cJSON.deleteType, "(x", child_level.toString(), ");");
                  }
                  this.emitLine("x", child_level.toString(), " = list_get_next(x", level.toString(), ");");
                });
              } else if (type instanceof Type_1.ClassType) {
                this.forEachClassProperty(type, "none", (name, _jsonName, property) => {
                  const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                  if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                    const child_level = level + 1;
                    this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                      var _a;
                      this.emitLine(
                        // @ts-expect-error awaiting refactor
                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                        " * x",
                        child_level.toString(),
                        " = list_get_head(x",
                        level > 0 ? level.toString() : "",
                        "->",
                        name,
                        ");"
                      );
                      this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                        var _a2, _b, _d, _e, _f, _g, _h;
                        if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                          if (property.type instanceof Type_1.ArrayType) {
                            recur(property.type.items, child_level);
                            this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x", child_level.toString(), ");");
                          } else {
                            (0, Support_1.panic)("Invalid type");
                          }
                        } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                        } else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                        } else {
                          if ((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.isNullable) {
                            this.emitBlock(["if ((void *)0xDEADBEEF != x", child_level.toString(), ")"], () => {
                              var _a3;
                              this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                                "(x",
                                child_level.toString(),
                                ");"
                              );
                            });
                          } else {
                            this.emitLine(
                              // @ts-expect-error awaiting refactor
                              (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.deleteType,
                              "(x",
                              child_level.toString(),
                              ");"
                            );
                          }
                        }
                        this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->", name, ");");
                      });
                      this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                    });
                  } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                    const child_level = level + 1;
                    this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                      this.emitLine("char **keys", child_level.toString(), " = NULL;");
                      this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->", name, ", &keys", child_level.toString(), ");");
                      this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                        this.emitBlock([
                          "for (size_t index",
                          child_level.toString(),
                          " = 0; index",
                          child_level.toString(),
                          " < count",
                          child_level.toString(),
                          "; index",
                          child_level.toString(),
                          "++)"
                        ], () => {
                          var _a;
                          this.emitLine(
                            // @ts-expect-error awaiting refactor
                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                            " *x",
                            child_level.toString(),
                            " = hashtable_lookup(x",
                            level > 0 ? level.toString() : "",
                            "->",
                            name,
                            ", keys",
                            child_level.toString(),
                            "[index",
                            child_level.toString(),
                            "]);"
                          );
                          this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                            var _a2, _b, _d, _e, _f, _g, _h;
                            if (((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                              if (property.type instanceof Type_1.MapType) {
                                recur(property.type.values, child_level);
                                this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x", child_level.toString(), ");");
                              } else {
                                (0, Support_1.panic)("Invalid type");
                              }
                            } else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") {
                            } else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" || ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                            } else {
                              if ((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.isNullable) {
                                this.emitBlock([
                                  "if ((void *)0xDEADBEEF != x",
                                  child_level.toString(),
                                  ")"
                                ], () => {
                                  var _a3;
                                  this.emitLine(
                                    // @ts-expect-error awaiting refactor
                                    (_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType,
                                    "(x",
                                    child_level.toString(),
                                    ");"
                                  );
                                });
                              } else {
                                this.emitLine(
                                  // @ts-expect-error awaiting refactor
                                  (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.deleteType,
                                  "(x",
                                  child_level.toString(),
                                  ");"
                                );
                              }
                            }
                          });
                        });
                        this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                      });
                      this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                    });
                  } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                  } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
                    this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                      this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                    });
                  } else {
                    if (property.isOptional || cJSON.isNullable) {
                      this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                        this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                      });
                    }
                  }
                });
              }
            };
            recur(classType, 0);
            this.emitLine("cJSON_free(x);");
          });
        });
        this.ensureBlankLine();
      }
      /**
       * Function called to create a top level header files with types and generators
       * @param type: type of the top level element
       * @param className: top level class name
       * @param includes: Array of includes
       */
      emitTopLevel(type, className, includes) {
        const filename = this.sourcelikeToString(className).concat(".h");
        this.startFile(filename);
        includes.forEach((name) => {
          this.emitIncludeLine(name);
        });
        this.ensureBlankLine();
        this.emitTopLevelTypedef(type, className);
        this.emitTopLevelPrototypes(type, className);
        this.emitTopLevelFunctions(type, className);
        this.finishFile();
      }
      /**
       * Function called to create top level typedef
       * @param type: type of the top level element
       * @param className: top level class name
       */
      emitTopLevelTypedef(type, className) {
        this.emitBlock(["struct ", className], () => {
          const cJSON = this.quicktypeTypeToCJSON(type, false);
          this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " value;");
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(type, className);
      }
      /**
       * Function called to create top level prototypes
       * @param type: type of the top level element
       * @param className: top level class name
       */
      emitTopLevelPrototypes(_type, className) {
        this.emitLine("struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s);");
        this.emitLine("struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("void cJSON_Delete", className, "(struct ", className, " * x);");
        this.ensureBlankLine();
      }
      /**
       * Function called to create top level functions
       * @param type: type of the top level element
       * @param className: top level class name
       */
      emitTopLevelFunctions(type, className) {
        this.emitBlock(["struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s)"], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock(["if (NULL != s)"], () => {
            this.emitLine("cJSON * j = cJSON_Parse(s);");
            this.emitBlock(["if (NULL != j)"], () => {
              this.emitLine("x = cJSON_Get", className, "Value(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock(["struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j)"], () => {
          this.emitLine("struct ", className, " * x = NULL;");
          this.emitBlock(["if (NULL != j)"], () => {
            this.emitBlock(["if (NULL != (x = cJSON_malloc(sizeof(struct ", className, "))))"], () => {
              this.emitLine("memset(x, 0, sizeof(struct ", className, "));");
              const cJSON = this.quicktypeTypeToCJSON(type, false);
              if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
                this.emitLine("x->value = list_create(false, NULL);");
                this.emitBlock(["if (NULL != x->value)"], () => {
                  this.emitLine("cJSON * e = NULL;");
                  this.emitBlock(["cJSON_ArrayForEach(e, j)"], () => {
                    var _a;
                    const add = (cJSON2) => {
                      var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                      if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                        this.emitLine("list_add_tail(x->value, (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEAF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                      } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                        this.emitLine("list_add_tail(x->value, strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e)), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                      } else {
                        this.emitLine(
                          "list_add_tail(x->value, ",
                          // @ts-expect-error awaiting refactor
                          (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.getValue,
                          "(e), sizeof(",
                          (_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cType,
                          " *));"
                        );
                      }
                    };
                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                      this.emitBlock(["if (!cJSON_IsNull(e))"], () => {
                        add(cJSON);
                      });
                      this.emitBlock(["else"], () => {
                        this.emitLine("list_add_tail(x->value, (void *)0xDEADBEEF, sizeof(void *));");
                      });
                    } else {
                      add(cJSON);
                    }
                  });
                });
              } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
                this.emitLine("x->value = hashtable_create(", this.hashtableSize, ", false);");
                this.emitBlock(["if (NULL != x->value)"], () => {
                  this.emitLine("cJSON * e = NULL;");
                  this.emitBlock(["cJSON_ArrayForEach(e, j)"], () => {
                    var _a;
                    const add = (cJSON2) => {
                      var _a2, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                      if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" || ((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                        this.emitLine("hashtable_add(x->value, e->string, (", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                      } else if (((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                        this.emitLine("hashtable_add(x->value, e->string, strdup(", (_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e)), sizeof(", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                      } else {
                        this.emitLine(
                          "hashtable_add(x->value, e->string, ",
                          // @ts-expect-error awaiting refactor
                          (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.getValue,
                          "(e), sizeof(",
                          (_m = cJSON2.items) === null || _m === void 0 ? void 0 : _m.cType,
                          " *));"
                        );
                      }
                    };
                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                      this.emitBlock(["if (!cJSON_IsNull(e))"], () => {
                        add(cJSON);
                      });
                      this.emitBlock(["else"], () => {
                        this.emitLine("hashtable_add(x->value, e->string, (void *)0xDEADBEEF, sizeof(void *));");
                      });
                    } else {
                      add(cJSON);
                    }
                  });
                });
              } else if (cJSON.cjsonType === "cJSON_Invalid") {
              } else if (cJSON.cjsonType === "cJSON_NULL") {
                this.emitLine("x->value = (", cJSON.cType, " *)0xDEADBEEF;");
              } else if (cJSON.cjsonType === "cJSON_String") {
                this.emitLine("x->value = strdup(", cJSON.getValue, "(j));");
              } else {
                this.emitLine("x->value = ", cJSON.getValue, "(j);");
              }
            });
          });
          this.emitLine("return x;");
        });
        this.ensureBlankLine();
        this.emitBlock(["cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
          this.emitLine("cJSON * j = NULL;");
          this.emitBlock(["if (NULL != x)"], () => {
            const cJSON = this.quicktypeTypeToCJSON(type, false);
            if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
              this.emitBlock(["if (NULL != x->value)"], () => {
                this.emitLine("j = ", cJSON.createObject, "();");
                this.emitBlock(["if (NULL != j)"], () => {
                  var _a;
                  this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x1 = list_get_head(x->value);");
                  this.emitBlock(["while (NULL != x1)"], () => {
                    var _a2;
                    const add = (cJSON2) => {
                      var _a3, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                      if (((_a3 = cJSON2.items) === null || _a3 === void 0 ? void 0 : _a3.cjsonType) === "cJSON_Array") {
                      } else if (((_b = cJSON2.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") {
                      } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                      } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                        this.emitLine("cJSON_AddItemToArray(j, ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                      } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                        this.emitLine("cJSON_AddItemToArray(j, ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x1));");
                      } else {
                        this.emitLine(
                          "cJSON_AddItemToArray(j, ",
                          // @ts-expect-error awaiting refactor
                          (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                          "(*x1));"
                        );
                      }
                    };
                    if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                      this.emitBlock(["if ((void *)0xDEADBEEF != x1)"], () => {
                        add(cJSON);
                      });
                      this.emitBlock(["else"], () => {
                        this.emitLine("cJSON_AddItemToArray(j, cJSON_CreateNull());");
                      });
                    } else {
                      add(cJSON);
                    }
                    this.emitLine("x1 = list_get_next(x->value);");
                  });
                });
              });
            } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
              this.emitBlock(["if (NULL != x->value)"], () => {
                this.emitLine("j = ", cJSON.createObject, "();");
                this.emitBlock(["if (NULL != j)"], () => {
                  this.emitLine("char **keys = NULL;");
                  this.emitLine("size_t count = hashtable_get_keys(x->value, &keys);");
                  this.emitBlock(["if (NULL != keys)"], () => {
                    this.emitBlock(["for (size_t index = 0; index < count; index++)"], () => {
                      var _a, _b;
                      this.emitLine(
                        // @ts-expect-error awaiting refactor
                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType,
                        " *x2 = hashtable_lookup(x->value, keys[index]);"
                      );
                      const add = (cJSON2) => {
                        var _a2, _b2, _d, _e, _f, _g, _h, _j, _k, _l;
                        if (((_a2 = cJSON2.items) === null || _a2 === void 0 ? void 0 : _a2.cjsonType) === "cJSON_Array") {
                        } else if (((_b2 = cJSON2.items) === null || _b2 === void 0 ? void 0 : _b2.cjsonType) === "cJSON_Map") {
                        } else if (((_d = cJSON2.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") {
                        } else if (((_e = cJSON2.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                          this.emitLine(cJSON2.addToObject, "(j, keys[index], ", (_f = cJSON2.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                        } else if (((_g = cJSON2.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" || ((_h = cJSON2.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" || ((_j = cJSON2.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                          this.emitLine(cJSON2.addToObject, "(j, keys[index], ", (_k = cJSON2.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x2));");
                        } else {
                          this.emitLine(
                            cJSON2.addToObject,
                            "(j, keys[index], ",
                            // @ts-expect-error awaiting refactor
                            (_l = cJSON2.items) === null || _l === void 0 ? void 0 : _l.createObject,
                            "(*x2));"
                          );
                        }
                      };
                      if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                        this.emitBlock(["if ((void *)0xDEADBEEF != x2)"], () => {
                          add(cJSON);
                        });
                        this.emitBlock(["else"], () => {
                          this.emitLine(cJSON.addToObject, "(j, keys[index], cJSON_CreateNull());");
                        });
                      } else {
                        add(cJSON);
                      }
                    });
                    this.emitLine("cJSON_free(keys);");
                  });
                });
              });
            } else if (cJSON.cjsonType === "cJSON_Invalid") {
            } else if (cJSON.cjsonType === "cJSON_NULL") {
              this.emitLine("j = ", cJSON.createObject, "();");
            } else {
              this.emitLine("j = ", cJSON.createObject, "(x->value);");
            }
          });
          this.emitLine("return j;");
        });
        this.ensureBlankLine();
        this.emitBlock(["char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
          this.emitLine("char * s = NULL;");
          this.emitBlock(["if (NULL != x)"], () => {
            this.emitLine("cJSON * j = cJSON_Create", className, "(x);");
            this.emitBlock(["if (NULL != j)"], () => {
              this.emitLine("s = cJSON_Print(j);");
              this.emitLine("cJSON_Delete(j);");
            });
          });
          this.emitLine("return s;");
        });
        this.ensureBlankLine();
        this.emitBlock(["void cJSON_Delete", className, "(struct ", className, " * x)"], () => {
          this.emitBlock(["if (NULL != x)"], () => {
            const cJSON = this.quicktypeTypeToCJSON(type, false);
            if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== void 0) {
              this.emitBlock(["if (NULL != x->value)"], () => {
                var _a;
                this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x1 = list_get_head(x->value);");
                this.emitBlock(["while (NULL != x1)"], () => {
                  var _a2, _b;
                  if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                    this.emitBlock(["if ((void *)0xDEADBEEF != x1)"], () => {
                      var _a3;
                      this.emitLine((_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType, "(x1);");
                    });
                  } else {
                    this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x1);");
                  }
                  this.emitLine("x1 = list_get_next(x->value);");
                });
                this.emitLine(cJSON.deleteType, "(x->value);");
              });
            } else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== void 0) {
              this.emitBlock(["if (NULL != x->value)"], () => {
                this.emitLine("char **keys = NULL;");
                this.emitLine("size_t count = hashtable_get_keys(x->value, &keys);");
                this.emitBlock(["if (NULL != keys)"], () => {
                  this.emitBlock(["for (size_t index = 0; index < count; index++)"], () => {
                    var _a;
                    this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *x2 = hashtable_lookup(x->value, keys[index]);");
                    this.emitBlock(["if (NULL != x2)"], () => {
                      var _a2, _b, _d;
                      if ((_a2 = cJSON.items) === null || _a2 === void 0 ? void 0 : _a2.isNullable) {
                        this.emitBlock(["if ((", (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *)0xDEADBEEF != x2)"], () => {
                          var _a3;
                          this.emitLine((_a3 = cJSON.items) === null || _a3 === void 0 ? void 0 : _a3.deleteType, "(x2);");
                        });
                      } else {
                        this.emitLine((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.deleteType, "(x2);");
                      }
                    });
                  });
                  this.emitLine("cJSON_free(keys);");
                });
                this.emitLine(cJSON.deleteType, "(x->value);");
              });
            } else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
            } else if (cJSON.cjsonType === "cJSON_String" || cJSON.cjsonType === "cJSON_Object" || cJSON.cjsonType === "cJSON_Union") {
              this.emitLine(cJSON.deleteType, "(x->value);");
            } else {
            }
            this.emitLine("cJSON_free(x);");
          });
        });
        this.ensureBlankLine();
      }
      /**
       * Convert quicktype type to cJSON type
       * @param t: quicktype type
       * @param isOptional: true if the field is optional
       * @param isNullable: true if the field is nullable
       * @return cJSON type
       */
      quicktypeTypeToCJSON(t, isOptional, isNullable = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return {
            cType: "void",
            optionalQualifier: "*",
            cjsonType: "cJSON_Invalid",
            isType: "cJSON_IsInvalid",
            getValue: "",
            addToObject: "",
            createObject: "",
            deleteType: "",
            items: void 0,
            isNullable
          };
        }, (_nullType) => {
          return {
            cType: "void",
            optionalQualifier: "*",
            cjsonType: "cJSON_NULL",
            isType: "cJSON_IsNull",
            getValue: "",
            addToObject: "cJSON_AddNullToObject",
            createObject: "cJSON_CreateNull",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_boolType) => {
          return {
            cType: "bool",
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Bool",
            isType: "cJSON_IsBool",
            getValue: "cJSON_IsTrue",
            addToObject: "cJSON_AddBoolToObject",
            createObject: "cJSON_CreateBool",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_integerType) => {
          return {
            cType: this.typeIntegerSize,
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Number",
            isType: "cJSON_IsNumber",
            getValue: "cJSON_GetNumberValue",
            addToObject: "cJSON_AddNumberToObject",
            createObject: "cJSON_CreateNumber",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_doubleType) => {
          return {
            cType: "double",
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Number",
            isType: "cJSON_IsNumber",
            getValue: "cJSON_GetNumberValue",
            addToObject: "cJSON_AddNumberToObject",
            createObject: "cJSON_CreateNumber",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (_stringType) => {
          return {
            cType: "char",
            optionalQualifier: "*",
            cjsonType: "cJSON_String",
            isType: "cJSON_IsString",
            getValue: "cJSON_GetStringValue",
            addToObject: "cJSON_AddStringToObject",
            createObject: "cJSON_CreateString",
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (arrayType) => {
          const items = this.quicktypeTypeToCJSON(arrayType.items, false);
          return {
            cType: "list_t",
            optionalQualifier: "*",
            cjsonType: "cJSON_Array",
            isType: "cJSON_IsArray",
            getValue: "cJSON_GetArrayItem",
            addToObject: "cJSON_AddItemToObject",
            createObject: "cJSON_CreateArray",
            deleteType: "list_release",
            items,
            isNullable
          };
        }, (classType) => {
          return {
            cType: ["struct ", this.nameForNamedType(classType)],
            optionalQualifier: "*",
            cjsonType: "cJSON_Object",
            isType: "cJSON_IsObject",
            getValue: ["cJSON_Get", this.nameForNamedType(classType), "Value"],
            addToObject: "cJSON_AddItemToObject",
            createObject: ["cJSON_Create", this.nameForNamedType(classType)],
            deleteType: ["cJSON_Delete", this.nameForNamedType(classType)],
            items: void 0,
            isNullable
          };
        }, (mapType) => {
          const items = this.quicktypeTypeToCJSON(mapType.values, false);
          return {
            cType: "hashtable_t",
            optionalQualifier: "*",
            cjsonType: "cJSON_Map",
            isType: "cJSON_IsObject",
            getValue: "",
            addToObject: "cJSON_AddItemToObject",
            createObject: "cJSON_CreateObject",
            deleteType: "hashtable_release",
            items,
            isNullable
          };
        }, (enumType) => {
          return {
            cType: ["enum ", this.nameForNamedType(enumType)],
            optionalQualifier: isOptional === true ? "*" : "",
            cjsonType: "cJSON_Enum",
            isType: "cJSON_IsString",
            getValue: ["cJSON_Get", this.nameForNamedType(enumType), "Value"],
            addToObject: "cJSON_AddItemToObject",
            createObject: ["cJSON_Create", this.nameForNamedType(enumType)],
            deleteType: "cJSON_free",
            items: void 0,
            isNullable
          };
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.quicktypeTypeToCJSON(nullable, true, true);
          } else {
            return {
              cType: ["struct ", this.nameForNamedType(unionType)],
              optionalQualifier: "*",
              cjsonType: "cJSON_Union",
              isType: "",
              getValue: ["cJSON_Get", this.nameForNamedType(unionType), "Value"],
              addToObject: "cJSON_AddItemToObject",
              createObject: ["cJSON_Create", this.nameForNamedType(unionType)],
              deleteType: ["cJSON_Delete", this.nameForNamedType(unionType)],
              items: void 0,
              isNullable
            };
          }
        });
      }
      /**
       * Function called to create a file
       * @param proposedFilename: source filename provided from stdin
       */
      startFile(proposedFilename) {
        (0, Support_1.assert)(this.currentFilename === void 0, "Previous file wasn't finished");
        if (proposedFilename !== void 0) {
          this.currentFilename = this.sourcelikeToString(proposedFilename);
        }
        if (this.currentFilename !== void 0) {
          this.emitDescriptionBlock([
            this.currentFilename,
            "This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT",
            "This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable",
            "To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);",
            "To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);",
            "To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);",
            "To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);",
            "To delete json data use the following: cJSON_Delete<type>(<data>);"
          ]);
          this.ensureBlankLine();
          this.emitLine("#ifndef __", (0, Strings_1.allUpperWordStyle)(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__");
          this.emitLine("#define __", (0, Strings_1.allUpperWordStyle)(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__");
          this.ensureBlankLine();
          this.emitLine("#ifdef __cplusplus");
          this.emitLine('extern "C" {');
          this.emitLine("#endif");
          this.ensureBlankLine();
          this.emitIncludeLine("stdint.h", true);
          this.emitIncludeLine("stdbool.h", true);
          this.emitIncludeLine("stdlib.h", true);
          this.emitIncludeLine("string.h", true);
          this.emitIncludeLine("cJSON.h", true);
          this.emitIncludeLine("hashtable.h", true);
          this.emitIncludeLine("list.h", true);
          this.ensureBlankLine();
          this.emitLine("#ifndef cJSON_Bool");
          this.emitLine("#define cJSON_Bool (cJSON_True | cJSON_False)");
          this.emitLine("#endif");
          this.emitLine("#ifndef cJSON_Map");
          this.emitLine("#define cJSON_Map (1 << 16)");
          this.emitLine("#endif");
          this.emitLine("#ifndef cJSON_Enum");
          this.emitLine("#define cJSON_Enum (1 << 17)");
          this.emitLine("#endif");
          this.ensureBlankLine();
        }
      }
      /**
       * Function called to close current file
       */
      finishFile() {
        if (this.currentFilename !== void 0) {
          this.emitLine("#ifdef __cplusplus");
          this.emitLine("}");
          this.emitLine("#endif");
          this.ensureBlankLine();
          this.emitLine("#endif /* __", (0, Strings_1.allUpperWordStyle)(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__ */");
          this.ensureBlankLine();
          super.finishFile((0, Support_1.defined)(this.currentFilename));
          this.currentFilename = void 0;
        }
      }
      /**
       * Check if type need declaration before use
       * @note If returning true, canBeForwardDeclared must be declared
       * @return Always returns true
       */
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      /**
       * Check if type can be forward declared
       * @return true for classes, false otherwise
       */
      canBeForwardDeclared(type) {
        return type.kind === "class";
      }
      /**
       * Add const to wanted Sourcelike
       * @return Const Sourcelike
       */
      withConst(s) {
        return ["const ", s];
      }
      /**
       * Emit include line
       * @param name: filename to include
       * @pram global: true if global include, false otherwise (default)
       */
      emitIncludeLine(name, global2 = false) {
        this.emitLine("#include ", global2 ? "<" : '"', name, global2 ? ">" : '"');
      }
      /**
       * Emit description block
       * @param lines: description block lines
       */
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      /**
       * Emit code block
       * @param line: code block line
       * @param f: callback function
       * @param withName: name of the block as string
       * @param withSemicolon: true to add semicolon at the end of the block, false otherwise
       * @param withIndent: true to indent the block (default), false otherwise
       */
      emitBlock(line, f, withName = "", withSemicolon = false, withIndent = true) {
        this.emitLine(line, " {");
        this.preventBlankLine();
        if (withIndent) {
          this.indent(f);
        } else {
          f();
        }
        this.preventBlankLine();
        if (withSemicolon) {
          if (withName !== "") {
            this.emitLine("} ", withName, ";");
          } else {
            this.emitLine("};");
          }
        } else {
          if (withName !== "") {
            this.emitLine("} ", withName);
          } else {
            this.emitLine("}");
          }
        }
      }
      /**
       * Emit includes
       * @param type: class, union or enum type
       * @param filename: current file name
       */
      emitIncludes(type, filename) {
        const includes = /* @__PURE__ */ new Map();
        if (type instanceof Type_1.UnionType) {
          this.updateIncludes(false, includes, type);
        } else if (type instanceof Type_1.ClassType) {
          this.forEachClassProperty(type, "none", (_name, _jsonName, property) => {
            this.updateIncludes(true, includes, property.type);
          });
        }
        if (includes.size !== 0) {
          includes.forEach((_rec, name) => {
            name = name.concat(".h");
            if (name !== filename) {
              this.emitIncludeLine(name);
            }
          });
        }
        this.ensureBlankLine();
      }
      /**
       * Compute includes
       * @param isClassMender: true if class, false otherwise
       * @param includes: include map
       * @param propertyType: property type
       */
      updateIncludes(isClassMember, includes, propertyType) {
        const propTypes = this.generatedTypes(isClassMember, propertyType);
        for (const t of propTypes) {
          const typeName = this.sourcelikeToString(t.name);
          const propRecord = { kind: void 0, typeKind: void 0 };
          if (t.type instanceof Type_1.ClassType) {
            propRecord.typeKind = "class";
            propRecord.kind = t.level === 0 ? IncludeKind.Include : IncludeKind.ForwardDeclare;
            if (t.forceInclude) {
              propRecord.kind = IncludeKind.Include;
            }
          } else if (t.type instanceof Type_1.EnumType) {
            propRecord.typeKind = "enum";
            propRecord.kind = IncludeKind.ForwardDeclare;
          } else if (t.type instanceof Type_1.UnionType) {
            propRecord.typeKind = "union";
            const [maybeNull] = (0, TypeUtils_1.removeNullFromUnion)(t.type, true);
            if (maybeNull !== void 0) {
              propRecord.kind = IncludeKind.Include;
            } else {
              if (t.forceInclude) {
                propRecord.kind = IncludeKind.Include;
              } else {
                propRecord.kind = IncludeKind.ForwardDeclare;
              }
            }
          }
          if (includes.has(typeName)) {
            const incKind = includes.get(typeName);
            if (incKind !== void 0 && incKind.kind === IncludeKind.ForwardDeclare) {
              includes.set(typeName, propRecord);
            }
          } else {
            includes.set(typeName, propRecord);
          }
        }
      }
      /**
       * Compute generated types
       * @param isClassMender: true if class, false otherwise
       * @param type: type
       * @return Type record array
       */
      generatedTypes(isClassMember, type) {
        const result = [];
        const recur = (forceInclude, isVariant, l, t) => {
          if (t instanceof Type_1.ArrayType) {
            recur(forceInclude, isVariant, l + 1, t.items);
          } else if (t instanceof Type_1.ClassType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude
            });
          } else if (t instanceof Type_1.MapType) {
            recur(forceInclude, isVariant, l + 1, t.values);
          } else if (t instanceof Type_1.EnumType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude: false
            });
          } else if (t instanceof Type_1.UnionType) {
            if (this.unionNeedsName(t) && isClassMember) {
              forceInclude = true;
              result.push({
                name: this.nameForNamedType(t),
                type: t,
                level: l,
                variant: true,
                forceInclude
              });
            }
            const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(t);
            isVariant = hasNull !== null;
            for (const tt of nonNulls) {
              recur(forceInclude, isVariant, l + 1, tt);
            }
          }
        };
        recur(false, false, 0, type);
        return result;
      }
    };
    exports.CJSONRenderer = CJSONRenderer;
  }
});

// node_modules/quicktype-core/dist/language/CPlusPlus.js
var require_CPlusPlus = __commonJS({
  "node_modules/quicktype-core/dist/language/CPlusPlus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CPlusPlusRenderer = exports.MemberNames = exports.GlobalNames = exports.IncludeKind = exports.CPlusPlusTargetLanguage = exports.cPlusPlusOptions = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var AccessorNames_1 = require_AccessorNames();
    var Constraints_1 = require_Constraints();
    var EnumValues_1 = require_EnumValues();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var pascalValue = ["pascal-case", "pascal"];
    var underscoreValue = ["underscore-case", "underscore"];
    var camelValue = ["camel-case", "camel"];
    var upperUnderscoreValue = ["upper-underscore-case", "upper-underscore"];
    var pascalUpperAcronymsValue = ["pascal-case-upper-acronyms", "pascal-upper-acronyms"];
    var camelUpperAcronymsValue = ["camel-case-upper-acronyms", "camel-upper-acronyms"];
    exports.cPlusPlusOptions = {
      typeSourceStyle: new RendererOptions_1.EnumOption("source-style", "Source code generation type,  whether to generate single or multiple source files", [
        ["single-source", true],
        ["multi-source", false]
      ], "single-source", "secondary"),
      includeLocation: new RendererOptions_1.EnumOption("include-location", "Whether json.hpp is to be located globally or locally", [
        ["local-include", true],
        ["global-include", false]
      ], "local-include", "secondary"),
      codeFormat: new RendererOptions_1.EnumOption("code-format", "Generate classes with getters/setters, instead of structs", [
        ["with-struct", false],
        ["with-getter-setter", true]
      ], "with-getter-setter"),
      wstring: new RendererOptions_1.EnumOption("wstring", "Store strings using Utf-16 std::wstring, rather than Utf-8 std::string", [
        ["use-string", false],
        ["use-wstring", true]
      ], "use-string"),
      westConst: new RendererOptions_1.EnumOption("const-style", "Put const to the left/west (const T) or right/east (T const)", [
        ["west-const", true],
        ["east-const", false]
      ], "west-const"),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      namespace: new RendererOptions_1.StringOption("namespace", "Name of the generated namespace(s)", "NAME", "quicktype"),
      enumType: new RendererOptions_1.StringOption("enum-type", "Type of enum class", "NAME", "int", "secondary"),
      typeNamingStyle: new RendererOptions_1.EnumOption("type-style", "Naming style for types", [
        pascalValue,
        underscoreValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
      ]),
      memberNamingStyle: new RendererOptions_1.EnumOption("member-style", "Naming style for members", [
        underscoreValue,
        pascalValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
      ]),
      enumeratorNamingStyle: new RendererOptions_1.EnumOption("enumerator-style", "Naming style for enumerators", [
        upperUnderscoreValue,
        underscoreValue,
        pascalValue,
        camelValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
      ]),
      boost: new RendererOptions_1.BooleanOption("boost", "Require a dependency on boost. Without boost, C++17 is required", true),
      hideNullOptional: new RendererOptions_1.BooleanOption("hide-null-optional", "Hide null value for optional field", false)
    };
    var CPlusPlusTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor(displayName = "C++", names = ["c++", "cpp", "cplusplus"], extension = "cpp") {
        super(displayName, names, extension);
      }
      getOptions() {
        return [
          exports.cPlusPlusOptions.justTypes,
          exports.cPlusPlusOptions.namespace,
          exports.cPlusPlusOptions.codeFormat,
          exports.cPlusPlusOptions.wstring,
          exports.cPlusPlusOptions.westConst,
          exports.cPlusPlusOptions.typeSourceStyle,
          exports.cPlusPlusOptions.includeLocation,
          exports.cPlusPlusOptions.typeNamingStyle,
          exports.cPlusPlusOptions.memberNamingStyle,
          exports.cPlusPlusOptions.enumeratorNamingStyle,
          exports.cPlusPlusOptions.enumType,
          exports.cPlusPlusOptions.boost,
          exports.cPlusPlusOptions.hideNullOptional
        ];
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new CPlusPlusRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.cPlusPlusOptions, untypedOptionValues));
      }
    };
    exports.CPlusPlusTargetLanguage = CPlusPlusTargetLanguage;
    function constraintsForType(t) {
      const minMax = (0, Constraints_1.minMaxValueForType)(t);
      const minMaxLength = (0, Constraints_1.minMaxLengthForType)(t);
      const pattern = (0, Constraints_1.patternForType)(t);
      if (minMax === void 0 && minMaxLength === void 0 && pattern === void 0)
        return void 0;
      return { minMax, minMaxLength, pattern };
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    var keywords = [
      "alignas",
      "alignof",
      "and",
      "and_eq",
      "asm",
      "atomic_cancel",
      "atomic_commit",
      "atomic_noexcept",
      "auto",
      "bitand",
      "bitor",
      "bool",
      "break",
      "case",
      "catch",
      "char",
      "char16_t",
      "char32_t",
      "class",
      "compl",
      "concept",
      "const",
      "constexpr",
      "const_cast",
      "continue",
      "co_await",
      "co_return",
      "co_yield",
      "decltype",
      "default",
      "delete",
      "do",
      "double",
      "dynamic_cast",
      "else",
      "enum",
      "explicit",
      "export",
      "extern",
      "false",
      "float",
      "for",
      "friend",
      "goto",
      "if",
      "import",
      "inline",
      "int",
      "long",
      "module",
      "mutable",
      "namespace",
      "new",
      "noexcept",
      "not",
      "not_eq",
      "nullptr",
      "operator",
      "or",
      "or_eq",
      "private",
      "protected",
      "public",
      "register",
      "reinterpret_cast",
      "requires",
      "return",
      "short",
      "signed",
      "sizeof",
      "static",
      "static_assert",
      "static_cast",
      "struct",
      "switch",
      "synchronized",
      "template",
      "this",
      "thread_local",
      "throw",
      "true",
      "try",
      "typedef",
      "typeid",
      "typename",
      "union",
      "unsigned",
      "using",
      "virtual",
      "void",
      "volatile",
      "wchar_t",
      "while",
      "xor",
      "xor_eq",
      "override",
      "final",
      "transaction_safe",
      "transaction_safe_dynamic",
      "NULL"
    ];
    var optionalAsSharedType = "std::shared_ptr";
    var optionalFactoryAsSharedType = "std::make_shared";
    var IncludeKind;
    (function(IncludeKind2) {
      IncludeKind2["ForwardDeclare"] = "ForwardDeclare";
      IncludeKind2["Include"] = "Include";
    })(IncludeKind = exports.IncludeKind || (exports.IncludeKind = {}));
    var GlobalNames;
    (function(GlobalNames2) {
      GlobalNames2[GlobalNames2["ClassMemberConstraints"] = 1] = "ClassMemberConstraints";
      GlobalNames2[GlobalNames2["ClassMemberConstraintException"] = 2] = "ClassMemberConstraintException";
      GlobalNames2[GlobalNames2["ValueTooLowException"] = 3] = "ValueTooLowException";
      GlobalNames2[GlobalNames2["ValueTooHighException"] = 4] = "ValueTooHighException";
      GlobalNames2[GlobalNames2["ValueTooShortException"] = 5] = "ValueTooShortException";
      GlobalNames2[GlobalNames2["ValueTooLongException"] = 6] = "ValueTooLongException";
      GlobalNames2[GlobalNames2["InvalidPatternException"] = 7] = "InvalidPatternException";
      GlobalNames2[GlobalNames2["CheckConstraint"] = 8] = "CheckConstraint";
    })(GlobalNames = exports.GlobalNames || (exports.GlobalNames = {}));
    var MemberNames;
    (function(MemberNames2) {
      MemberNames2[MemberNames2["MinIntValue"] = 1] = "MinIntValue";
      MemberNames2[MemberNames2["GetMinIntValue"] = 2] = "GetMinIntValue";
      MemberNames2[MemberNames2["SetMinIntValue"] = 3] = "SetMinIntValue";
      MemberNames2[MemberNames2["MaxIntValue"] = 4] = "MaxIntValue";
      MemberNames2[MemberNames2["GetMaxIntValue"] = 5] = "GetMaxIntValue";
      MemberNames2[MemberNames2["SetMaxIntValue"] = 6] = "SetMaxIntValue";
      MemberNames2[MemberNames2["MinDoubleValue"] = 7] = "MinDoubleValue";
      MemberNames2[MemberNames2["GetMinDoubleValue"] = 8] = "GetMinDoubleValue";
      MemberNames2[MemberNames2["SetMinDoubleValue"] = 9] = "SetMinDoubleValue";
      MemberNames2[MemberNames2["MaxDoubleValue"] = 10] = "MaxDoubleValue";
      MemberNames2[MemberNames2["GetMaxDoubleValue"] = 11] = "GetMaxDoubleValue";
      MemberNames2[MemberNames2["SetMaxDoubleValue"] = 12] = "SetMaxDoubleValue";
      MemberNames2[MemberNames2["MinLength"] = 13] = "MinLength";
      MemberNames2[MemberNames2["GetMinLength"] = 14] = "GetMinLength";
      MemberNames2[MemberNames2["SetMinLength"] = 15] = "SetMinLength";
      MemberNames2[MemberNames2["MaxLength"] = 16] = "MaxLength";
      MemberNames2[MemberNames2["GetMaxLength"] = 17] = "GetMaxLength";
      MemberNames2[MemberNames2["SetMaxLength"] = 18] = "SetMaxLength";
      MemberNames2[MemberNames2["Pattern"] = 19] = "Pattern";
      MemberNames2[MemberNames2["GetPattern"] = 20] = "GetPattern";
      MemberNames2[MemberNames2["SetPattern"] = 21] = "SetPattern";
    })(MemberNames = exports.MemberNames || (exports.MemberNames = {}));
    function addQualifier(qualifier, qualified) {
      if (qualified.length === 0) {
        return [];
      }
      return [qualifier, qualified];
    }
    var WrappingCode = class {
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
      wrap(qualifier, inner) {
        return [addQualifier(qualifier, this.start), inner, this.end];
      }
    };
    var BaseString = class {
      constructor(stringType, constStringType, smatch, regex, stringLiteralPrefix, toString, encodingClass, encodingFunction) {
        this._stringType = stringType;
        this._constStringType = constStringType;
        this._smatch = smatch;
        this._regex = regex;
        this._stringLiteralPrefix = stringLiteralPrefix;
        this._toString = toString;
        this._encodingClass = encodingClass;
        this._encodingFunction = encodingFunction;
      }
      getType() {
        return this._stringType;
      }
      getConstType() {
        return this._constStringType;
      }
      getSMatch() {
        return this._smatch;
      }
      getRegex() {
        return this._regex;
      }
      createStringLiteral(inner) {
        return [this._stringLiteralPrefix, '"', inner, '"'];
      }
      wrapToString(inner) {
        return this._toString.wrap([], inner);
      }
    };
    var CPlusPlusRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this.NarrowString = new class extends BaseString {
          constructor() {
            super("std::string", "const std::string & ", "std::smatch", "std::regex", "", new WrappingCode(["std::to_string("], [")"]), "", "");
          }
          wrapEncodingChange(_qualifier, _fromType, _toType, inner) {
            return inner;
          }
          emitHelperFunctions() {
            return;
          }
        }();
        this.WideString = new class extends BaseString {
          constructor(superThis) {
            super("std::wstring", "const std::wstring & ", "std::wsmatch", "std::wregex", "L", new WrappingCode(["std::to_wstring("], [")"]), "Utf16_Utf8", "convert");
            this.superThis = superThis;
          }
          wrapEncodingChange(qualifier, fromType, toType, inner) {
            if (this.superThis.sourcelikeToString(fromType) === this.superThis.sourcelikeToString(toType)) {
              return inner;
            }
            return [
              addQualifier(qualifier, [this._encodingClass]),
              "<",
              fromType,
              ", ",
              toType,
              ">::",
              this._encodingFunction,
              "(",
              inner,
              ")"
            ];
          }
          emitHelperFunctions() {
            this.superThis.emitLine("template<typename T>");
            this.superThis.emitLine("struct tag {};");
            this.superThis.ensureBlankLine();
            this.superThis.emitLine("template<typename fromType, typename toType>");
            this.superThis.emitBlock(["class Utf16_Utf8"], true, () => {
              this.superThis.emitLine("private:");
              this.superThis.emitLine("template<typename TF, typename TT>");
              this.superThis.emitBlock(["static toType convert(tag<std::shared_ptr<TF> >, tag<std::shared_ptr<TT> >, fromType ptr)"], false, () => {
                this.superThis.emitLine("if (ptr == nullptr) return std::unique_ptr<TT>(); else return std::unique_ptr<TT>(new TT(Utf16_Utf8<TF,TT>::convert(*ptr)));");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("template<typename TF, typename TT>");
              this.superThis.emitBlock(["static toType convert(tag<std::vector<TF> >, tag<std::vector<TT> >, fromType v)"], false, () => {
                this.superThis.emitLine("auto it = v.begin();");
                this.superThis.emitLine("auto newVector = std::vector<TT>();");
                this.superThis.emitBlock(["while (it != v.end())"], false, () => {
                  this.superThis.emitLine("newVector.push_back(Utf16_Utf8<TF,TT>::convert(*it));");
                  this.superThis.emitLine("it++;");
                });
                this.superThis.emitLine("return newVector;");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("template<typename KF, typename VF, typename KT, typename VT>");
              this.superThis.emitBlock(["static toType convert(tag<std::map<KF,VF> >, tag<std::map<KT,VT> >, fromType m)"], false, () => {
                this.superThis.emitLine("auto it = m.begin();");
                this.superThis.emitLine("auto newMap = std::map<KT, VT>();");
                this.superThis.emitBlock(["while (it != m.end())"], false, () => {
                  this.superThis.emitLine("newMap.insert(std::pair<KT, VT>(Utf16_Utf8<KF, KT>::convert(it->first), Utf16_Utf8<VF, VT>::convert(it->second)));");
                  this.superThis.emitLine("it++;");
                });
                this.superThis.emitLine("return newMap;");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("template<typename TF, typename TT>");
              this.superThis.emitBlock(["static fromType convert(tag<TF>, tag<TT>, fromType from)"], false, () => {
                this.superThis.emitLine("return from;");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitBlock(["static std::wstring convert(tag<std::string>, tag<std::wstring>, std::string str)"], false, () => {
                this.superThis.emitLine("return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t, 0x10ffff, std::little_endian>, wchar_t>{}.from_bytes(str.data());");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitBlock(["static std::string convert(tag<std::wstring>, tag<std::string>, std::wstring str)"], false, () => {
                this.superThis.emitLine("return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t, 0x10ffff, std::little_endian>, wchar_t>{}.to_bytes(str.data());");
              });
              this.superThis.ensureBlankLine();
              this.superThis.emitLine("public:");
              this.superThis.emitBlock(["static toType convert(fromType in)"], false, () => {
                this.superThis.emitLine("return convert(tag<fromType>(), tag<toType>(), in);");
              });
            });
            this.superThis.ensureBlankLine();
            this.superThis.emitLine("template<typename T>");
            this.superThis.emitBlock(["std::wstring wdump(const T& j)"], false, () => {
              this.superThis.emitLine("std::ostringstream s;");
              this.superThis.emitLine("s << j;");
              this.superThis.emitLine("return ", this.superThis.ourQualifier(false), "Utf16_Utf8<std::string, std::wstring>::convert(s.str()); ");
            });
            this.superThis.ensureBlankLine();
          }
        }(this);
        this._enumType = _options.enumType;
        this._namespaceNames = _options.namespace.split("::");
        this.typeNamingStyle = _options.typeNamingStyle;
        this._namedTypeNameStyle = (0, Strings_1.makeNameStyle)(this.typeNamingStyle, legalizeName);
        this.enumeratorNamingStyle = _options.enumeratorNamingStyle;
        this._memberNameStyle = (0, Strings_1.makeNameStyle)(_options.memberNamingStyle, legalizeName);
        this._memberNamingFunction = (0, Naming_1.funPrefixNamer)("members", this._memberNameStyle);
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._allTypeNames = /* @__PURE__ */ new Set();
        this._generatedFiles = /* @__PURE__ */ new Set();
        this._generatedGlobalNames = /* @__PURE__ */ new Map();
        this._generatedMemberNames = /* @__PURE__ */ new Map();
        this._forbiddenGlobalNames = [];
        if (_options.wstring) {
          this._stringType = this.WideString;
        } else {
          this._stringType = this.NarrowString;
        }
        if (_options.boost) {
          this._optionalType = "boost::optional";
          this._optionalFactory = "boost::optional";
          this._nulloptType = "boost::none";
          this._variantType = "boost::variant";
          this._variantIndexMethodName = "which";
        } else {
          this._optionalType = "std::optional";
          this._optionalFactory = "std::make_optional";
          this._nulloptType = "std::nullopt";
          this._variantType = "std::variant";
          this._variantIndexMethodName = "index";
        }
        this.setupGlobalNames();
      }
      // union typeguard
      isUnion(t) {
        return t.kind === "union";
      }
      // Returns true if the type can be stored in
      // a stack based optional type. This requires
      // that the type does not require forward declaration.
      isOptionalAsValuePossible(t) {
        if (this.isForwardDeclaredType(t))
          return false;
        if (this.isUnion(t)) {
          const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(t);
          if (nonNulls.size === 1) {
            const tt = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(nonNulls));
            return !this.isCycleBreakerType(tt);
          }
        }
        return !this.isCycleBreakerType(t);
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      // Is likely to return std::optional or boost::optional
      optionalTypeStack() {
        return this._optionalType;
      }
      // Is likely to return std::make_optional or boost::optional
      optionalFactoryStack() {
        return this._optionalFactory;
      }
      // Is likely to return std::shared_ptr
      optionalTypeHeap() {
        return optionalAsSharedType;
      }
      // Is likely to return std::make_shared
      optionalFactoryHeap() {
        return optionalFactoryAsSharedType;
      }
      // Returns the optional type most suitable for the given type.
      // Classes that don't require forward declarations can be stored
      // in std::optional ( or boost::optional )
      optionalType(t) {
        if (this.isOptionalAsValuePossible(t))
          return this.optionalTypeStack();
        else
          return this.optionalTypeHeap();
      }
      // Returns a label that can be used to distinguish between
      // heap and stack based optional handling methods
      optionalTypeLabel(t) {
        if (this.isOptionalAsValuePossible(t))
          return "stack";
        else
          return "heap";
      }
      getConstraintMembers() {
        return [
          {
            name: MemberNames.MinIntValue,
            getter: MemberNames.GetMinIntValue,
            setter: MemberNames.SetMinIntValue,
            cppType: "int64_t"
          },
          {
            name: MemberNames.MaxIntValue,
            getter: MemberNames.GetMaxIntValue,
            setter: MemberNames.SetMaxIntValue,
            cppType: "int64_t"
          },
          {
            name: MemberNames.MinDoubleValue,
            getter: MemberNames.GetMinDoubleValue,
            setter: MemberNames.SetMinDoubleValue,
            cppType: "double"
          },
          {
            name: MemberNames.MaxDoubleValue,
            getter: MemberNames.GetMaxDoubleValue,
            setter: MemberNames.SetMaxDoubleValue,
            cppType: "double"
          },
          {
            name: MemberNames.MinLength,
            getter: MemberNames.GetMinLength,
            setter: MemberNames.SetMinLength,
            cppType: "size_t"
          },
          {
            name: MemberNames.MaxLength,
            getter: MemberNames.GetMaxLength,
            setter: MemberNames.SetMaxLength,
            cppType: "size_t"
          },
          {
            name: MemberNames.Pattern,
            getter: MemberNames.GetPattern,
            setter: MemberNames.SetPattern,
            cppType: this._stringType.getType(),
            cppConstType: this._stringType.getConstType()
          }
        ];
      }
      lookupGlobalName(type) {
        return (0, Support_1.defined)(this._generatedGlobalNames.get(type));
      }
      lookupMemberName(type) {
        return (0, Support_1.defined)(this._generatedMemberNames.get(type));
      }
      addGlobalName(type) {
        const genName = this._namedTypeNameStyle(GlobalNames[type]);
        this._generatedGlobalNames.set(type, genName);
        this._forbiddenGlobalNames.push(genName);
      }
      addMemberName(type) {
        this._generatedMemberNames.set(type, this._memberNameStyle(MemberNames[type]));
      }
      setupGlobalNames() {
        for (const v of (0, Support_1.numberEnumValues)(GlobalNames)) {
          this.addGlobalName(v);
        }
        for (const v of (0, Support_1.numberEnumValues)(MemberNames)) {
          this.addMemberName(v);
        }
      }
      forbiddenNamesForGlobalNamespace() {
        return [...keywords, ...this._forbiddenGlobalNames];
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", this._namedTypeNameStyle);
      }
      namerForObjectProperty() {
        return this._memberNamingFunction;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enumerators", (0, Strings_1.makeNameStyle)(this.enumeratorNamingStyle, legalizeName));
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(this._memberNamingFunction, name.order, (lookup) => `get_${lookup(name)}`);
        const mutableGetterName = new Naming_1.DependencyName(this._memberNamingFunction, name.order, (lookup) => `getMutable_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(this._memberNamingFunction, name.order, (lookup) => `set_${lookup(name)}`);
        return [getterName, mutableGetterName, setterName];
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
      }
      withConst(s) {
        if (this._options.westConst) {
          return ["const ", s];
        } else {
          return [s, " const"];
        }
      }
      emitInclude(global2, name) {
        this.emitLine("#include ", global2 ? "<" : '"', name, global2 ? ">" : '"');
      }
      startFile(basename, includeHelper = true) {
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished");
        if (basename !== void 0) {
          this._currentFilename = this.sourcelikeToString(basename);
        }
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitCommentLines([" To parse this JSON data, first install", ""]);
          if (this._options.boost) {
            this.emitCommentLines(["     Boost     http://www.boost.org"]);
          }
          this.emitCommentLines([
            "     json.hpp  https://github.com/nlohmann/json",
            "",
            " Then include this file, and then do",
            ""
          ]);
          if (this._options.typeSourceStyle) {
            this.forEachTopLevel("none", (_, topLevelName) => {
              this.emitLine("//     ", topLevelName, " data = nlohmann::json::parse(jsonString);");
            });
          } else {
            this.emitLine("//     ", basename, " data = nlohmann::json::parse(jsonString);");
          }
          if (this._options.wstring) {
            this.emitLine("//");
            this.emitLine("//  You can get std::wstring data back out using");
            this.emitLine("//");
            this.forEachTopLevel("none", (_, topLevelName) => {
              this.emitLine("//     std::wcout << ", "wdump((nlohmann::json) ", topLevelName, ");");
            });
          }
        }
        this.ensureBlankLine();
        this.emitLine("#pragma once");
        this.ensureBlankLine();
        if (this.haveOptionalProperties) {
          if (this._options.boost) {
            this.emitInclude(true, "boost/optional.hpp");
          } else {
            this.emitInclude(true, "optional");
          }
        }
        if (this.haveNamedUnions) {
          if (this._options.boost) {
            this.emitInclude(true, "boost/variant.hpp");
          } else {
            this.emitInclude(true, "variant");
          }
        }
        if (!this._options.justTypes) {
          if (!this._options.includeLocation) {
            this.emitInclude(true, "nlohmann/json.hpp");
          } else {
            this.emitInclude(false, "json.hpp");
          }
          if (includeHelper && !this._options.typeSourceStyle) {
            this.emitInclude(false, "helper.hpp");
          }
        }
        this.ensureBlankLine();
      }
      finishFile() {
        super.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        const kind = t.kind;
        return kind === "class";
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      emitBlock(line, withSemicolon, f, withIndent = true) {
        this.emitLine(line, " {");
        this.preventBlankLine();
        if (withIndent) {
          this.indent(f);
        } else {
          f();
        }
        this.preventBlankLine();
        if (withSemicolon) {
          this.emitLine("};");
        } else {
          this.emitLine("}");
        }
      }
      emitNamespaces(namespaceNames, f) {
        const namesArray = (0, collection_utils_1.toReadonlyArray)(namespaceNames);
        const first = namesArray[0];
        if (first === void 0) {
          f();
        } else {
          this.emitBlock(["namespace ", first], false, () => this.emitNamespaces(namesArray.slice(1), f), namesArray.length === 1);
        }
      }
      cppTypeInOptional(nonNulls, ctx, withIssues, forceNarrowString) {
        if (nonNulls.size === 1) {
          return this.cppType((0, Support_1.defined)((0, collection_utils_1.iterableFirst)(nonNulls)), ctx, withIssues, forceNarrowString, false);
        }
        const typeList = [];
        for (const t of nonNulls) {
          if (typeList.length !== 0) {
            typeList.push(", ");
          }
          typeList.push(this.cppType(t, {
            needsForwardIndirection: true,
            needsOptionalIndirection: false,
            inJsonNamespace: ctx.inJsonNamespace
          }, withIssues, false, false));
        }
        return [this._variantType, "<", typeList, ">"];
      }
      variantType(u, inJsonNamespace) {
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, true);
        (0, Support_1.assert)(nonNulls.size >= 2, "Variant not needed for less than two types.");
        const indirection = maybeNull !== null;
        const variant = this.cppTypeInOptional(nonNulls, {
          needsForwardIndirection: !indirection,
          needsOptionalIndirection: !indirection,
          inJsonNamespace
        }, true, false);
        if (!indirection) {
          return variant;
        }
        return [this.optionalType(u), "<", variant, ">"];
      }
      ourQualifier(inJsonNamespace) {
        return inJsonNamespace ? [(0, collection_utils_1.arrayIntercalate)("::", this._namespaceNames), "::"] : [];
      }
      jsonQualifier(inJsonNamespace) {
        return inJsonNamespace ? [] : "nlohmann::";
      }
      variantIndirection(type, needIndirection, typeSrc) {
        if (!needIndirection)
          return typeSrc;
        return [this.optionalType(type), "<", typeSrc, ">"];
      }
      cppType(t, ctx, withIssues, forceNarrowString, isOptional) {
        const inJsonNamespace = ctx.inJsonNamespace;
        if (isOptional && t instanceof Type_1.UnionType) {
          for (const tChild of t.getChildren()) {
            if (tChild.isNullable) {
              isOptional = false;
              break;
            }
          }
        }
        const typeSource = (0, TypeUtils_1.matchType)(t, (_anyType) => {
          isOptional = false;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, [
            this.jsonQualifier(inJsonNamespace),
            "json"
          ]);
        }, (_nullType) => {
          isOptional = false;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, [
            this.jsonQualifier(inJsonNamespace),
            "json"
          ]);
        }, (_boolType) => "bool", (_integerType) => "int64_t", (_doubleType) => "double", (_stringType) => {
          if (forceNarrowString) {
            return "std::string";
          } else {
            return this._stringType.getType();
          }
        }, (arrayType) => [
          "std::vector<",
          this.cppType(arrayType.items, {
            needsForwardIndirection: false,
            needsOptionalIndirection: true,
            inJsonNamespace
          }, withIssues, forceNarrowString, false),
          ">"
        ], (classType) => this.variantIndirection(classType, ctx.needsForwardIndirection && this.isForwardDeclaredType(classType) && !isOptional, [this.ourQualifier(inJsonNamespace), this.nameForNamedType(classType)]), (mapType) => {
          let keyType = this._stringType.getType();
          if (forceNarrowString) {
            keyType = "std::string";
          }
          return [
            "std::map<",
            keyType,
            ", ",
            this.cppType(mapType.values, {
              needsForwardIndirection: false,
              needsOptionalIndirection: true,
              inJsonNamespace
            }, withIssues, forceNarrowString, false),
            ">"
          ];
        }, (enumType) => [this.ourQualifier(inJsonNamespace), this.nameForNamedType(enumType)], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            isOptional = true;
            return this.cppType(nullable, {
              needsForwardIndirection: false,
              needsOptionalIndirection: false,
              inJsonNamespace
            }, withIssues, forceNarrowString, false);
          } else {
            return [this.ourQualifier(inJsonNamespace), this.nameForNamedType(unionType)];
          }
        });
        if (!isOptional)
          return typeSource;
        return [this.optionalType(t), "<", typeSource, ">"];
      }
      /**
       * similar to cppType, it practically gathers all the generated types within
       * 't'. It also records, whether a given sub-type is part of a variant or not.
       */
      generatedTypes(isClassMember, theType) {
        const result = [];
        const recur = (forceInclude, isVariant, l, t) => {
          if (t instanceof Type_1.ArrayType) {
            recur(true, isVariant, l + 1, t.items);
          } else if (t instanceof Type_1.ClassType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude
            });
          } else if (t instanceof Type_1.MapType) {
            recur(true, isVariant, l + 1, t.values);
          } else if (t instanceof Type_1.EnumType) {
            result.push({
              name: this.nameForNamedType(t),
              type: t,
              level: l,
              variant: isVariant,
              forceInclude: false
            });
          } else if (t instanceof Type_1.UnionType) {
            if (this.unionNeedsName(t) && isClassMember) {
              forceInclude = true;
              result.push({
                name: this.nameForNamedType(t),
                type: t,
                level: l,
                variant: true,
                forceInclude
              });
            }
            const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(t);
            isVariant = hasNull !== null;
            for (const tt of nonNulls) {
              recur(forceInclude, isVariant, l + 1, tt);
            }
          }
        };
        recur(false, false, 0, theType);
        return result;
      }
      constraintMember(jsonName) {
        return this._memberNameStyle(`${jsonName}Constraint`);
      }
      emitMember(cppType, name) {
        this.emitLine(cppType, " ", name, ";");
      }
      emitClassMembers(c, constraints) {
        if (this._options.codeFormat) {
          this.emitLine("private:");
          this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitMember(this.cppType(property.type, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, true, false, property.isOptional), name);
            if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
              const cnst = this.lookupGlobalName(GlobalNames.ClassMemberConstraints);
              this.emitMember(cnst, this.constraintMember(jsonName));
            }
          });
          this.ensureBlankLine();
          this.emitLine("public:");
        }
        this.forEachClassProperty(c, "none", (name, jsonName, property) => {
          this.emitDescription(this.descriptionForClassProperty(c, jsonName));
          if (!this._options.codeFormat) {
            this.emitMember(this.cppType(property.type, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, true, false, property.isOptional), name);
          } else {
            const [getterName, mutableGetterName, setterName] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            const rendered = this.cppType(property.type, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, true, false, property.isOptional);
            const checkConst = this.lookupGlobalName(GlobalNames.CheckConstraint);
            if (property.type instanceof Type_1.UnionType && property.type.findMember("null") !== void 0 || property.isOptional && property.type.kind !== "null" && property.type.kind !== "any") {
              this.emitLine(rendered, " ", getterName, "() const { return ", name, "; }");
              if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
                this.emitLine("void ", setterName, "(", rendered, " value) { if (value) ", checkConst, "(", this._stringType.createStringLiteral([name]), ", ", this.constraintMember(jsonName), ", *value); this->", name, " = value; }");
              } else {
                this.emitLine("void ", setterName, "(", rendered, " value) { this->", name, " = value; }");
              }
            } else {
              this.emitLine(this.withConst(rendered), " & ", getterName, "() const { return ", name, "; }");
              this.emitLine(rendered, " & ", mutableGetterName, "() { return ", name, "; }");
              if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
                this.emitLine("void ", setterName, "(", this.withConst(rendered), " & value) { ", checkConst, "(", this._stringType.createStringLiteral([name]), ", ", this.constraintMember(jsonName), ", value); this->", name, " = value; }");
              } else {
                this.emitLine("void ", setterName, "(", this.withConst(rendered), " & value) { this->", name, " = value; }");
              }
            }
            this.ensureBlankLine();
          }
        });
      }
      generateClassConstraints(c) {
        const res = /* @__PURE__ */ new Map();
        this.forEachClassProperty(c, "none", (_name, jsonName, property) => {
          const constraints = constraintsForType(property.type);
          if (constraints === void 0)
            return;
          const { minMax, minMaxLength, pattern } = constraints;
          const cppType = this.cppType(property.type, {
            needsForwardIndirection: true,
            needsOptionalIndirection: true,
            inJsonNamespace: false
          }, true, false, property.isOptional);
          res.set(jsonName, [
            this.constraintMember(jsonName),
            "(",
            (minMax === null || minMax === void 0 ? void 0 : minMax[0]) && cppType === "int64_t" ? String(minMax[0]) : this._nulloptType,
            ", ",
            (minMax === null || minMax === void 0 ? void 0 : minMax[1]) && cppType === "int64_t" ? String(minMax[1]) : this._nulloptType,
            ", ",
            (minMax === null || minMax === void 0 ? void 0 : minMax[0]) && cppType === "double" ? String(minMax[0]) : this._nulloptType,
            ", ",
            (minMax === null || minMax === void 0 ? void 0 : minMax[1]) && cppType === "double" ? String(minMax[1]) : this._nulloptType,
            ", ",
            (minMaxLength === null || minMaxLength === void 0 ? void 0 : minMaxLength[0]) ? String(minMaxLength[0]) : this._nulloptType,
            ", ",
            (minMaxLength === null || minMaxLength === void 0 ? void 0 : minMaxLength[1]) ? String(minMaxLength[1]) : this._nulloptType,
            ", ",
            pattern === void 0 ? this._nulloptType : [
              this._stringType.getType(),
              "(",
              this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(pattern)]),
              ")"
            ],
            ")"
          ]);
        });
        return res.size === 0 ? void 0 : res;
      }
      emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock([this._options.codeFormat ? "class " : "struct ", className], true, () => {
          const constraints = this.generateClassConstraints(c);
          if (this._options.codeFormat) {
            this.emitLine("public:");
            if (constraints === void 0) {
              this.emitLine(className, "() = default;");
            } else {
              this.emitLine(className, "() :");
              let numEmits = 0;
              constraints.forEach((initializer, _propName) => {
                numEmits++;
                this.indent(() => {
                  if (numEmits === constraints.size) {
                    this.emitLine(initializer);
                  } else {
                    this.emitLine(initializer, ",");
                  }
                });
              });
              this.emitLine("{}");
            }
            this.emitLine("virtual ~", className, "() = default;");
            this.ensureBlankLine();
          }
          this.emitClassMembers(c, constraints);
        });
      }
      emitTopLevelHeaders(t, className) {
        if (t instanceof Type_1.MapType && this._stringType !== this.NarrowString) {
          const ourQualifier = this.ourQualifier(true);
          this.emitBlock(["struct adl_serializer<", ourQualifier, className, ">"], true, () => {
            this.emitLine("template <>");
            this.emitLine("static void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, " & x);");
            this.emitLine("static void to_json(json & j, ", this.withConst([ourQualifier, className]), " & x);");
          });
        }
      }
      emitClassHeaders(className) {
        const ourQualifier = this.ourQualifier(false);
        this.emitLine("void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, " & x);");
        this.emitLine("void to_json(json & j, ", this.withConst([ourQualifier, className]), " & x);");
      }
      emitTopLevelFunction(t, className) {
        if (t instanceof Type_1.MapType && this._stringType !== this.NarrowString) {
          const ourQualifier = this.ourQualifier(true);
          let cppType;
          let toType;
          this.emitBlock([
            "inline void adl_serializer<",
            ourQualifier,
            className,
            ">::from_json(",
            this.withConst("json"),
            " & j, ",
            ourQualifier,
            className,
            "& x)"
          ], false, () => {
            cppType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, true, false);
            toType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, false, false);
            this.emitLine([
              "x = ",
              this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
                "j.get<",
                cppType,
                ">()"
              ]),
              ";"
            ]);
          });
          this.emitBlock([
            "inline void adl_serializer<",
            ourQualifier,
            className,
            ">::to_json(json & j, ",
            this.withConst([ourQualifier, className]),
            " & x)"
          ], false, () => {
            cppType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, false, false);
            toType = this.cppType(t, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: true
            }, false, true, false);
            this.emitLine([
              "j = ",
              this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, "x"),
              ";"
            ]);
          });
        }
      }
      emitClassFunctions(c, className) {
        const ourQualifier = this.ourQualifier(false);
        let cppType;
        let toType;
        this.emitBlock(["inline void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, "& x)"], false, () => {
          this.forEachClassProperty(c, "none", (name, json, p) => {
            const [, , setterName] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            const propType = p.type;
            let assignment;
            if (this._options.codeFormat) {
              assignment = new WrappingCode(["x.", setterName, "("], [")"]);
            } else {
              assignment = new WrappingCode(["x.", name, " = "], []);
            }
            if (propType.kind === "null" || propType.kind === "any") {
              this.emitLine(assignment.wrap([], [
                ourQualifier,
                "get_untyped(j, ",
                this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(json)])]),
                ")"
              ]), ";");
              return;
            }
            if (p.isOptional || propType instanceof Type_1.UnionType) {
              const [nullOrOptional, typeSet] = function() {
                if (propType instanceof Type_1.UnionType) {
                  const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(propType, true);
                  return [maybeNull !== null || p.isOptional, nonNulls];
                } else {
                  const set2 = /* @__PURE__ */ new Set();
                  set2.add(propType);
                  return [true, set2];
                }
              }();
              if (nullOrOptional) {
                cppType = this.cppTypeInOptional(typeSet, {
                  needsForwardIndirection: false,
                  needsOptionalIndirection: false,
                  inJsonNamespace: false
                }, false, true);
                toType = this.cppTypeInOptional(typeSet, {
                  needsForwardIndirection: false,
                  needsOptionalIndirection: false,
                  inJsonNamespace: false
                }, false, false);
                this.emitLine(assignment.wrap([], [
                  this._stringType.wrapEncodingChange([ourQualifier], [this.optionalType(propType), "<", cppType, ">"], [this.optionalType(propType), "<", toType, ">"], [
                    ourQualifier,
                    `get_${this.optionalTypeLabel(propType)}_optional<`,
                    cppType,
                    ">(j, ",
                    this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(json)])]),
                    ")"
                  ])
                ]), ";");
                return;
              }
            }
            cppType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, true, p.isOptional);
            toType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, false, p.isOptional);
            this.emitLine(assignment.wrap([], this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
              "j.at(",
              this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(json)])),
              ").get<",
              cppType,
              ">()"
            ])), ";");
          });
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void to_json(json & j, ", this.withConst([ourQualifier, className]), " & x)"], false, () => {
          this.emitLine("j = json::object();");
          this.forEachClassProperty(c, "none", (name, json, p) => {
            const propType = p.type;
            cppType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, false, p.isOptional);
            toType = this.cppType(propType, {
              needsForwardIndirection: true,
              needsOptionalIndirection: true,
              inJsonNamespace: false
            }, false, true, p.isOptional);
            const [getterName, ,] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            let getter;
            if (this._options.codeFormat) {
              getter = [getterName, "()"];
            } else {
              getter = [name];
            }
            const assignment = [
              "j[",
              this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(json)])),
              "] = ",
              this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, ["x.", getter]),
              ";"
            ];
            if (p.isOptional && this._options.hideNullOptional) {
              this.emitBlock([
                "if (",
                this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, ["x.", getter]),
                ")"
              ], false, () => {
                this.emitLine(assignment);
              });
            } else {
              this.emitLine(assignment);
            }
          });
        });
      }
      emitEnum(e, enumName) {
        const caseNames = [];
        const enumValues = (0, EnumValues_1.enumCaseValues)(e, this.targetLanguage.name);
        this.forEachEnumCase(e, "none", (name, jsonName) => {
          if (caseNames.length > 0)
            caseNames.push(", ");
          caseNames.push(name);
          if (enumValues !== void 0) {
            const [enumValue] = (0, AccessorNames_1.getAccessorName)(enumValues, jsonName);
            if (enumValue !== void 0) {
              caseNames.push(" = ", enumValue.toString());
            }
          }
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("enum class ", enumName, " : ", this._enumType, " { ", caseNames, " };");
      }
      emitUnionTypedefs(u, unionName) {
        this.emitLine("using ", unionName, " = ", this.variantType(u, false), ";");
      }
      emitUnionHeaders(u) {
        const nonNulls = (0, TypeUtils_1.removeNullFromUnion)(u, true)[1];
        const variantType = this.cppTypeInOptional(nonNulls, {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false);
        this.emitLine("template <>");
        this.emitBlock(["struct adl_serializer<", variantType, ">"], true, () => {
          this.emitLine("static void from_json(", this.withConst("json"), " & j, ", variantType, " & x);");
          this.emitLine("static void to_json(json & j, ", this.withConst(variantType), " & x);");
        });
      }
      emitUnionFunctions(u) {
        const ourQualifier = this.ourQualifier(true);
        const functionForKind = [
          ["bool", "is_boolean"],
          ["integer", "is_number_integer"],
          ["double", "is_number"],
          ["string", "is_string"],
          ["class", "is_object"],
          ["map", "is_object"],
          ["array", "is_array"],
          ["enum", "is_string"]
        ];
        const nonNulls = (0, TypeUtils_1.removeNullFromUnion)(u, true)[1];
        const variantType = this.cppTypeInOptional(nonNulls, {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false);
        this.emitBlock([
          "inline void adl_serializer<",
          variantType,
          ">::from_json(",
          this.withConst("json"),
          " & j, ",
          variantType,
          " & x)"
        ], false, () => {
          let onFirst = true;
          for (const [kind, func] of functionForKind) {
            const typeForKind = (0, collection_utils_1.iterableFind)(nonNulls, (t) => t.kind === kind);
            if (typeForKind === void 0)
              continue;
            this.emitLine(onFirst ? "if" : "else if", " (j.", func, "())");
            this.indent(() => {
              const cppType = this.cppType(typeForKind, {
                needsForwardIndirection: true,
                needsOptionalIndirection: true,
                inJsonNamespace: true
              }, false, true, false);
              const toType = this.cppType(typeForKind, {
                needsForwardIndirection: true,
                needsOptionalIndirection: true,
                inJsonNamespace: true
              }, false, false, false);
              this.emitLine("x = ", this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
                "j.get<",
                cppType,
                ">()"
              ]), ";");
            });
            onFirst = false;
          }
          this.emitLine('else throw std::runtime_error("Could not deserialise!");');
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void adl_serializer<", variantType, ">::to_json(json & j, ", this.withConst(variantType), " & x)"], false, () => {
          this.emitBlock(["switch (x.", this._variantIndexMethodName, "())"], false, () => {
            let i = 0;
            for (const t of nonNulls) {
              this.emitLine("case ", i.toString(), ":");
              this.indent(() => {
                const cppType = this.cppType(t, {
                  needsForwardIndirection: true,
                  needsOptionalIndirection: true,
                  inJsonNamespace: true
                }, false, false, false);
                const toType = this.cppType(t, {
                  needsForwardIndirection: true,
                  needsOptionalIndirection: true,
                  inJsonNamespace: true
                }, false, true, false);
                this.emitLine("j = ", this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
                  this._options.boost ? "boost::get<" : "std::get<",
                  cppType,
                  ">(x)"
                ]), ";");
                this.emitLine("break;");
              });
              i++;
            }
            this.emitLine('default: throw std::runtime_error("Input JSON does not conform to schema!");');
          });
        });
      }
      emitEnumHeaders(enumName) {
        const ourQualifier = this.ourQualifier(false);
        this.emitLine("void from_json(", this.withConst("json"), " & j, ", ourQualifier, enumName, " & x);");
        this.emitLine("void to_json(json & j, ", this.withConst([ourQualifier, enumName]), " & x);");
      }
      isLargeEnum(e) {
        return e.cases.size > 15;
      }
      emitEnumFunctions(e, enumName) {
        const ourQualifier = this.ourQualifier(false);
        this.emitBlock(["inline void from_json(", this.withConst("json"), " & j, ", ourQualifier, enumName, " & x)"], false, () => {
          if (this.isLargeEnum(e)) {
            this.emitBlock([
              "static std::unordered_map<",
              this._stringType.getType(),
              ", ",
              ourQualifier,
              enumName,
              "> enumValues"
            ], true, () => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("{", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(jsonName)])]), ", ", ourQualifier, enumName, "::", name, "},");
              });
            });
            this.emitLine(`auto iter = enumValues.find(j.get<${this._stringType.getType()}>());`);
            this.emitBlock("if (iter != enumValues.end())", false, () => {
              this.emitLine("x = iter->second;");
            });
          } else {
            let onFirst = true;
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              const maybeElse = onFirst ? "" : "else ";
              this.emitLine(maybeElse, "if (j == ", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(jsonName)])]), ") x = ", ourQualifier, enumName, "::", name, ";");
              onFirst = false;
            });
            this.emitLine('else { throw std::runtime_error("Input JSON does not conform to schema!"); }');
          }
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void to_json(json & j, ", this.withConst([ourQualifier, enumName]), " & x)"], false, () => {
          this.emitBlock("switch (x)", false, () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine("case ", ourQualifier, enumName, "::", name, ": j = ", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([(0, Strings_1.stringEscape)(jsonName)])]), "; break;");
            });
            this.emitLine(`default: throw std::runtime_error("Unexpected value in enumeration \\"${enumName}\\": " + std::to_string(static_cast<int>(x)));`);
          });
        });
      }
      emitTopLevelTypedef(t, name) {
        this.emitLine("using ", name, " = ", this.cppType(t, {
          needsForwardIndirection: true,
          needsOptionalIndirection: true,
          inJsonNamespace: false
        }, true, false, false), ";");
      }
      emitAllUnionFunctions() {
        this.forEachUniqueUnion("leading-and-interposing", (u) => this.sourcelikeToString(this.cppTypeInOptional((0, TypeUtils_1.removeNullFromUnion)(u, true)[1], {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false)), (u) => this.emitUnionFunctions(u));
      }
      emitAllUnionHeaders() {
        this.forEachUniqueUnion("interposing", (u) => this.sourcelikeToString(this.cppTypeInOptional((0, TypeUtils_1.removeNullFromUnion)(u, true)[1], {
          needsForwardIndirection: false,
          needsOptionalIndirection: false,
          inJsonNamespace: true
        }, false, false)), (u) => this.emitUnionHeaders(u));
      }
      emitOptionalHelpers() {
        this.emitLine("#ifndef NLOHMANN_OPT_HELPER");
        this.emitLine("#define NLOHMANN_OPT_HELPER");
        this.emitNamespaces(["nlohmann"], () => {
          const emitAdlStruct = (optType, factory) => {
            this.emitLine("template <typename T>");
            this.emitBlock(["struct adl_serializer<", optType, "<T>>"], true, () => {
              this.emitBlock(["static void to_json(json & j, ", this.withConst([optType, "<T>"]), " & opt)"], false, () => {
                this.emitLine("if (!opt) j = nullptr; else j = *opt;");
              });
              this.ensureBlankLine();
              this.emitBlock(["static ", optType, "<T> from_json(", this.withConst("json"), " & j)"], false, () => {
                this.emitLine(`if (j.is_null()) return ${factory}<T>(); else return ${factory}<T>(j.get<T>());`);
              });
            });
          };
          emitAdlStruct(this.optionalTypeHeap(), this.optionalFactoryHeap());
          emitAdlStruct(this.optionalTypeStack(), this.optionalFactoryStack());
        });
        this.emitLine("#endif");
      }
      emitDeclaration(decl) {
        if (decl.kind === "forward") {
          if (this._options.codeFormat) {
            this.emitLine("class ", this.nameForNamedType(decl.type), ";");
          } else {
            this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
          }
        } else if (decl.kind === "define") {
          const type = decl.type;
          const name = this.nameForNamedType(type);
          if (type instanceof Type_1.ClassType) {
            this.emitClass(type, name);
          } else if (type instanceof Type_1.EnumType) {
            this.emitEnum(type, name);
          } else if (type instanceof Type_1.UnionType) {
            this.emitUnionTypedefs(type, name);
          } else {
            (0, Support_1.panic)(`Cannot declare type ${type.kind}`);
          }
        } else {
          (0, Support_1.assertNever)(decl.kind);
        }
      }
      emitGetterSetter(t, getterName, setterName, memberName) {
        this.emitLine("void ", setterName, "(", t, " ", memberName, ") { this->", memberName, " = ", memberName, "; }");
        this.emitLine("auto ", getterName, "() const { return ", memberName, "; }");
      }
      emitNumericCheckConstraints(checkConst, classConstraint, getterMinValue, getterMaxValue, cppType) {
        this.emitBlock([
          "inline void ",
          checkConst,
          "(",
          this._stringType.getConstType(),
          " name, ",
          this.withConst(classConstraint),
          " & c, ",
          cppType,
          " value)"
        ], false, () => {
          this.emitBlock(["if (c.", getterMinValue, "() != ", this._nulloptType, " && value < *c.", getterMinValue, "())"], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooLowException), " (", this._stringType.createStringLiteral(["Value too low for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value"]), " + ", this._stringType.createStringLiteral(["<"]), " + ", this._stringType.wrapToString(["*c.", getterMinValue, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
          });
          this.ensureBlankLine();
          this.emitBlock(["if (c.", getterMaxValue, "() != ", this._nulloptType, " && value > *c.", getterMaxValue, "())"], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooHighException), " (", this._stringType.createStringLiteral(["Value too high for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value"]), " + ", this._stringType.createStringLiteral([">"]), " + ", this._stringType.wrapToString(["*c.", getterMaxValue, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
          });
          this.ensureBlankLine();
        });
        this.ensureBlankLine();
      }
      emitConstraintClasses() {
        const ourQualifier = this.ourQualifier(false);
        const getterMinIntValue = this.lookupMemberName(MemberNames.GetMinIntValue);
        const getterMaxIntValue = this.lookupMemberName(MemberNames.GetMaxIntValue);
        const getterMinDoubleValue = this.lookupMemberName(MemberNames.GetMinDoubleValue);
        const getterMaxDoubleValue = this.lookupMemberName(MemberNames.GetMaxDoubleValue);
        const getterMinLength = this.lookupMemberName(MemberNames.GetMinLength);
        const getterMaxLength = this.lookupMemberName(MemberNames.GetMaxLength);
        const getterPattern = this.lookupMemberName(MemberNames.GetPattern);
        const classConstraint = this.lookupGlobalName(GlobalNames.ClassMemberConstraints);
        this.emitBlock(["class ", classConstraint], true, () => {
          this.emitLine("private:");
          const constraintMembers = this.getConstraintMembers();
          for (const member of constraintMembers) {
            this.emitMember([this._optionalType, "<", member.cppType, ">"], this.lookupMemberName(member.name));
          }
          this.ensureBlankLine();
          this.emitLine("public:");
          this.emitLine(classConstraint, "(");
          this.indent(() => {
            this.iterableForEach(constraintMembers, ({ name, cppType }, pos) => {
              const comma = pos === "first" || pos === "middle" ? "," : [];
              this.emitLine(this._optionalType, "<", cppType, "> ", this.lookupMemberName(name), comma);
            });
          });
          const args = constraintMembers.map(({ name }) => {
            const member = this.lookupMemberName(name);
            return [member, "(", member, ")"];
          });
          this.emitLine(") : ", (0, collection_utils_1.arrayIntercalate)([", "], args), " {}");
          this.emitLine(classConstraint, "() = default;");
          this.emitLine("virtual ~", classConstraint, "() = default;");
          for (const member of constraintMembers) {
            this.ensureBlankLine();
            this.emitGetterSetter((0, collection_utils_1.withDefault)(member.cppConstType, member.cppType), this.lookupMemberName(member.getter), this.lookupMemberName(member.setter), this.lookupMemberName(member.name));
          }
        });
        this.ensureBlankLine();
        const classConstEx = this.lookupGlobalName(GlobalNames.ClassMemberConstraintException);
        this.emitBlock(["class ", classConstEx, " : public std::runtime_error"], true, () => {
          this.emitLine("public:");
          this.emitLine(classConstEx, "(", this._stringType.getConstType(), " msg) : std::runtime_error(", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), ["msg"]), ") {}");
        });
        this.ensureBlankLine();
        const exceptions = [
          GlobalNames.ValueTooLowException,
          GlobalNames.ValueTooHighException,
          GlobalNames.ValueTooShortException,
          GlobalNames.ValueTooLongException,
          GlobalNames.InvalidPatternException
        ];
        for (const ex of exceptions) {
          const name = this.lookupGlobalName(ex);
          this.emitBlock(["class ", name, " : public ", classConstEx], true, () => {
            this.emitLine("public:");
            this.emitLine(name, "(", this._stringType.getConstType(), " msg) : ", classConstEx, "(msg) {}");
          });
          this.ensureBlankLine();
        }
        const checkConst = this.lookupGlobalName(GlobalNames.CheckConstraint);
        this.emitNumericCheckConstraints(checkConst, classConstraint, getterMinIntValue, getterMaxIntValue, "int64_t");
        this.emitNumericCheckConstraints(checkConst, classConstraint, getterMinDoubleValue, getterMaxDoubleValue, "double");
        this.emitBlock([
          "inline void ",
          checkConst,
          "(",
          this._stringType.getConstType(),
          " name, ",
          this.withConst(classConstraint),
          " & c, ",
          this._stringType.getConstType(),
          " value)"
        ], false, () => {
          this.emitBlock([
            "if (c.",
            getterMinLength,
            "() != ",
            this._nulloptType,
            " && value.length() < *c.",
            getterMinLength,
            "())"
          ], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooShortException), " (", this._stringType.createStringLiteral(["Value too short for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value.length()"]), " + ", this._stringType.createStringLiteral(["<"]), " + ", this._stringType.wrapToString(["*c.", getterMinLength, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "if (c.",
            getterMaxLength,
            "() != ",
            this._nulloptType,
            " && value.length() > *c.",
            getterMaxLength,
            "())"
          ], false, () => {
            this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooLongException), " (", this._stringType.createStringLiteral(["Value too long for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value.length()"]), " + ", this._stringType.createStringLiteral([">"]), " + ", this._stringType.wrapToString(["*c.", getterMaxLength, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
          });
          this.ensureBlankLine();
          this.emitBlock(["if (c.", getterPattern, "() != ", this._nulloptType, ")"], false, () => {
            this.emitLine(this._stringType.getSMatch(), " result;");
            this.emitLine("std::regex_search(value, result, ", this._stringType.getRegex(), "( *c.", getterPattern, "() ));");
            this.emitBlock(["if (result.empty())"], false, () => {
              this.emitLine("throw ", this.lookupGlobalName(GlobalNames.InvalidPatternException), " (", this._stringType.createStringLiteral(["Value doesn't match pattern for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + value +", this._stringType.createStringLiteral([" != "]), " + *c.", getterPattern, "() + ", this._stringType.createStringLiteral([")"]), ");");
            });
          });
          this.ensureBlankLine();
        });
      }
      emitHelperFunctions() {
        this._stringType.emitHelperFunctions();
        if (this._options.codeFormat && (0, collection_utils_1.iterableSome)(this.typeGraph.allTypesUnordered(), (t) => constraintsForType(t) !== void 0)) {
          this.emitConstraintClasses();
          this.ensureBlankLine();
        }
        this.ensureBlankLine();
        let untypedMacroName = "NLOHMANN_UNTYPED_";
        let optionalMacroName = "NLOHMANN_OPTIONAL_";
        this._namespaceNames.forEach((value) => {
          untypedMacroName += value;
          untypedMacroName += "_";
          optionalMacroName += value;
          optionalMacroName += "_";
        });
        untypedMacroName += "HELPER";
        optionalMacroName += "HELPER";
        this.emitLine(`#ifndef ${untypedMacroName}`);
        this.emitLine(`#define ${untypedMacroName}`);
        this.emitBlock(["inline json get_untyped(", this.withConst("json"), " & j, ", this.withConst("char"), " * property)"], false, () => {
          this.emitBlock(["if (j.find(property) != j.end())"], false, () => {
            this.emitLine("return j.at(property).get<json>();");
          });
          this.emitLine("return json();");
        });
        this.ensureBlankLine();
        this.emitBlock(["inline json get_untyped(", this.withConst("json"), " & j, std::string property)"], false, () => {
          this.emitLine("return get_untyped(j, property.data());");
        });
        this.emitLine("#endif");
        this.ensureBlankLine();
        if (this.haveUnions || this.haveOptionalProperties) {
          this.ensureBlankLine();
          this.emitLine(`#ifndef ${optionalMacroName}`);
          this.emitLine(`#define ${optionalMacroName}`);
          const emitGetOptional = (optionalType, label) => {
            this.emitLine("template <typename T>");
            this.emitBlock([
              "inline ",
              optionalType,
              `<T> get_${label}_optional(`,
              this.withConst("json"),
              " & j, ",
              this.withConst("char"),
              " * property)"
            ], false, () => {
              this.emitLine(["auto it = j.find(property);"]);
              this.emitBlock(["if (it != j.end() && !it->is_null())"], false, () => {
                this.emitLine("return j.at(property).get<", optionalType, "<T>>();");
              });
              this.emitLine("return ", optionalType, "<T>();");
            });
            this.ensureBlankLine();
            this.emitLine("template <typename T>");
            this.emitBlock([
              "inline ",
              optionalType,
              `<T> get_${label}_optional(`,
              this.withConst("json"),
              " & j, std::string property)"
            ], false, () => {
              this.emitLine(`return get_${label}_optional<T>(j, property.data());`);
            });
          };
          emitGetOptional(this.optionalTypeHeap(), "heap");
          emitGetOptional(this.optionalTypeStack(), "stack");
          this.emitLine("#endif");
          this.ensureBlankLine();
        }
      }
      emitExtraIncludes() {
        this.ensureBlankLine();
        if (this._options.codeFormat) {
          if (this._options.boost) {
            this.emitInclude(true, "boost/optional.hpp");
          } else {
            this.emitInclude(true, "optional");
          }
          this.emitInclude(true, "stdexcept");
          this.emitInclude(true, "regex");
        }
        if (this._options.wstring) {
          this.emitInclude(true, "codecvt");
          this.emitInclude(true, "locale");
        }
        if (Array.from(this.enums).some((enumType) => this.isLargeEnum(enumType))) {
          this.emitInclude(true, "unordered_map");
        }
        this.ensureBlankLine();
      }
      emitHelper() {
        this.startFile("helper.hpp", false);
        this.emitExtraIncludes();
        this.emitInclude(true, "sstream");
        this.ensureBlankLine();
        this.emitNamespaces(this._namespaceNames, () => {
          this.emitLine("using nlohmann::json;");
          this.ensureBlankLine();
          this.emitHelperFunctions();
        });
        if (this.haveUnions || this.haveOptionalProperties) {
          this.ensureBlankLine();
          this.emitOptionalHelpers();
        }
        this.finishFile();
      }
      emitTypes() {
        if (!this._options.justTypes) {
          this.emitLine("using nlohmann::json;");
          this.ensureBlankLine();
          this.emitHelperFunctions();
        }
        this.forEachDeclaration("interposing", (decl) => this.emitDeclaration(decl));
        if (this._options.justTypes)
          return;
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelTypedef(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
      }
      gatherUserNamespaceForwardDecls() {
        return this.gatherSource(() => {
          this.forEachObject("leading-and-interposing", (_, className) => this.emitClassHeaders(className));
          this.forEachEnum("leading-and-interposing", (_, enumName) => this.emitEnumHeaders(enumName));
        });
      }
      gatherNlohmannNamespaceForwardDecls() {
        return this.gatherSource(() => {
          this.forEachTopLevel("leading-and-interposing", (t, className) => this.emitTopLevelHeaders(t, className));
          this.ensureBlankLine();
          this.emitAllUnionHeaders();
        });
      }
      emitUserNamespaceImpls() {
        this.forEachObject("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className));
        this.forEachEnum("leading-and-interposing", (e, enumName) => this.emitEnumFunctions(e, enumName));
      }
      emitNlohmannNamespaceImpls() {
        this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevelFunction(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.ensureBlankLine();
        this.emitAllUnionFunctions();
      }
      emitGenerators() {
        if (this._options.justTypes) {
          let didEmit = false;
          const gathered = this.gatherSource(() => this.emitNamespaces(this._namespaceNames, () => {
            didEmit = this.forEachTopLevel("none", (t, name) => this.emitTopLevelTypedef(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          }));
          if (didEmit) {
            this.emitGatheredSource(gathered);
            this.ensureBlankLine();
          }
        } else {
          const userNamespaceForwardDecls = this.gatherUserNamespaceForwardDecls();
          const nlohmannNamespaceForwardDecls = this.gatherNlohmannNamespaceForwardDecls();
          if (userNamespaceForwardDecls.length === 0 && nlohmannNamespaceForwardDecls.length > 0) {
            this.emitNamespaces(["nlohmann"], () => {
              this.emitGatheredSource(nlohmannNamespaceForwardDecls);
              this.emitNlohmannNamespaceImpls();
            });
          } else if (userNamespaceForwardDecls.length > 0 && nlohmannNamespaceForwardDecls.length === 0) {
            this.emitNamespaces(this._namespaceNames, () => {
              this.emitGatheredSource(userNamespaceForwardDecls);
              this.emitUserNamespaceImpls();
            });
          } else if (userNamespaceForwardDecls.length > 0 && nlohmannNamespaceForwardDecls.length > 0) {
            this.emitNamespaces(this._namespaceNames, () => {
              this.emitGatheredSource(userNamespaceForwardDecls);
            });
            this.emitNamespaces(["nlohmann"], () => {
              this.emitGatheredSource(nlohmannNamespaceForwardDecls);
            });
            this.emitNamespaces(this._namespaceNames, () => {
              this.emitUserNamespaceImpls();
            });
            this.emitNamespaces(["nlohmann"], () => {
              this.emitNlohmannNamespaceImpls();
            });
          }
        }
      }
      emitSingleSourceStructure(proposedFilename) {
        this.startFile(proposedFilename);
        this._generatedFiles.add(proposedFilename);
        this.emitExtraIncludes();
        if (this._options.justTypes) {
          this.emitTypes();
        } else {
          if (!this._options.justTypes && this.haveNamedTypes && (this.haveUnions || this.haveOptionalProperties)) {
            this.emitOptionalHelpers();
            this.ensureBlankLine();
          }
          this.emitNamespaces(this._namespaceNames, () => this.emitTypes());
        }
        this.ensureBlankLine();
        this.emitGenerators();
        this.finishFile();
      }
      updateIncludes(isClassMember, includes, propertyType, _defName) {
        const propTypes = this.generatedTypes(isClassMember, propertyType);
        for (const t of propTypes) {
          const typeName = this.sourcelikeToString(t.name);
          const propRecord = { kind: void 0, typeKind: void 0 };
          if (t.type instanceof Type_1.ClassType) {
            propRecord.typeKind = "class";
            propRecord.kind = t.level === 0 ? IncludeKind.Include : IncludeKind.ForwardDeclare;
            if (t.forceInclude) {
              propRecord.kind = IncludeKind.Include;
            }
          } else if (t.type instanceof Type_1.EnumType) {
            propRecord.typeKind = "enum";
            propRecord.kind = IncludeKind.ForwardDeclare;
          } else if (t.type instanceof Type_1.UnionType) {
            propRecord.typeKind = "union";
            const [maybeNull] = (0, TypeUtils_1.removeNullFromUnion)(t.type, true);
            if (maybeNull !== void 0) {
              propRecord.kind = IncludeKind.Include;
            } else {
              if (t.forceInclude) {
                propRecord.kind = IncludeKind.Include;
              } else {
                propRecord.kind = IncludeKind.ForwardDeclare;
              }
            }
          }
          if (includes.has(typeName)) {
            const incKind = includes.get(typeName);
            if (incKind !== void 0 && incKind.kind === IncludeKind.ForwardDeclare) {
              includes.set(typeName, propRecord);
            }
          } else {
            includes.set(typeName, propRecord);
          }
        }
      }
      emitIncludes(c, defName) {
        const includes = /* @__PURE__ */ new Map();
        if (c instanceof Type_1.UnionType) {
          this.updateIncludes(false, includes, c, defName);
        } else if (c instanceof Type_1.ClassType) {
          this.forEachClassProperty(c, "none", (_name, _jsonName, property) => {
            this.updateIncludes(true, includes, property.type, defName);
          });
        }
        if (includes.size !== 0) {
          let numForwards = 0;
          let numIncludes = 0;
          includes.forEach((rec, name) => {
            if (name === defName) {
              return;
            }
            if (rec.kind !== IncludeKind.ForwardDeclare) {
              this.emitInclude(false, [name, ".hpp"]);
              numIncludes++;
            } else {
              numForwards++;
            }
          });
          if (numIncludes > 0) {
            this.ensureBlankLine();
          }
          if (numForwards > 0) {
            this.emitNamespaces(this._namespaceNames, () => {
              includes.forEach((rec, name) => {
                if (name === defName) {
                  return;
                }
                if (rec.kind !== IncludeKind.ForwardDeclare) {
                  return;
                }
                if (rec.typeKind === "class" || rec.typeKind === "union") {
                  if (this._options.codeFormat) {
                    this.emitLine("class ", name, ";");
                  } else {
                    this.emitLine("struct ", name, ";");
                  }
                } else if (rec.typeKind === "enum") {
                  this.emitLine("enum class ", name, " : ", this._enumType, ";");
                } else {
                  (0, Support_1.panic)(`Invalid type "${rec.typeKind}" to forward declare`);
                }
              });
            });
          }
          this.ensureBlankLine();
        }
      }
      emitDefinition(d, defName) {
        const name = `${this.sourcelikeToString(defName)}.hpp`;
        this.startFile(name, true);
        this._generatedFiles.add(name);
        this.emitIncludes(d, this.sourcelikeToString(defName));
        this.emitNamespaces(this._namespaceNames, () => {
          this.emitDescription(this.descriptionForType(d));
          this.ensureBlankLine();
          this.emitLine("using nlohmann::json;");
          this.ensureBlankLine();
          if (d instanceof Type_1.ClassType) {
            this.emitClass(d, defName);
          } else if (d instanceof Type_1.EnumType) {
            this.emitEnum(d, defName);
          } else if (d instanceof Type_1.UnionType) {
            this.emitUnionTypedefs(d, defName);
          }
        });
        this.finishFile();
      }
      emitMultiSourceStructure(proposedFilename) {
        if (!this._options.justTypes && this.haveNamedTypes) {
          this.emitHelper();
          this.startFile("Generators.hpp", true);
          this._allTypeNames.forEach((t) => {
            this.emitInclude(false, [t, ".hpp"]);
          });
          this.ensureBlankLine();
          this.emitGenerators();
          this.finishFile();
        }
        this.forEachNamedType("leading-and-interposing", (c, n) => {
          this.emitDefinition(c, n);
        }, (e, n) => {
          this.emitDefinition(e, n);
        }, (u, n) => {
          this.emitDefinition(u, n);
        });
        if (!this._generatedFiles.has(proposedFilename)) {
          if (!this.haveNamedTypes) {
            this.emitHelper();
          }
          this.startFile(proposedFilename);
          this._generatedFiles.forEach((f) => {
            this.emitInclude(false, f);
          });
          this.emitNamespaces(this._namespaceNames, () => {
            this.forEachTopLevel("leading", (t, name) => this.emitTopLevelTypedef(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          });
          this.finishFile();
        }
      }
      emitSourceStructure(proposedFilename) {
        this._generatedFiles.clear();
        this._allTypeNames.clear();
        this.forEachDeclaration("none", (decl) => {
          const definedTypes = (0, TypeUtils_1.directlyReachableTypes)(decl.type, (t) => {
            if ((0, TypeUtils_1.isNamedType)(t) && (t instanceof Type_1.ClassType || t instanceof Type_1.EnumType || t instanceof Type_1.UnionType)) {
              return /* @__PURE__ */ new Set([
                this.sourcelikeToString(this.cppType(t, {
                  needsForwardIndirection: false,
                  needsOptionalIndirection: false,
                  inJsonNamespace: false
                }, true, false, false))
              ]);
            }
            return null;
          });
          this._allTypeNames = (0, collection_utils_1.setUnion)(definedTypes, this._allTypeNames);
        });
        if (this._options.typeSourceStyle) {
          this.emitSingleSourceStructure(proposedFilename);
        } else {
          this.emitMultiSourceStructure(proposedFilename);
        }
      }
      isConversionRequired(t) {
        const originalType = this.cppType(t, {
          needsForwardIndirection: true,
          needsOptionalIndirection: true,
          inJsonNamespace: true
        }, false, false, false);
        const newType = this.cppType(t, {
          needsForwardIndirection: true,
          needsOptionalIndirection: true,
          inJsonNamespace: true
        }, false, true, false);
        return originalType !== newType;
      }
    };
    exports.CPlusPlusRenderer = CPlusPlusRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Crystal.js
var require_Crystal = __commonJS({
  "node_modules/quicktype-core/dist/language/Crystal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CrystalRenderer = exports.CrystalTargetLanguage = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var TargetLanguage_1 = require_TargetLanguage();
    var TypeUtils_1 = require_TypeUtils();
    var CrystalTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      makeRenderer(renderContext) {
        return new CrystalRenderer(this, renderContext);
      }
      constructor() {
        super("Crystal", ["crystal", "cr", "crystallang"], "cr");
      }
      get defaultIndentation() {
        return "  ";
      }
      getOptions() {
        return [];
      }
    };
    exports.CrystalTargetLanguage = CrystalTargetLanguage;
    var keywords = [
      "Any",
      "Array",
      "Atomic",
      "Bool",
      "Channel",
      "Char",
      "Class",
      "Enum",
      "Enumerable",
      "Event",
      "Extern",
      "Exception",
      "File",
      "Float",
      "Float32",
      "Float64",
      "GC",
      "GZip",
      "Hash",
      "HTML",
      "HTTP",
      "Int",
      "Int128",
      "Int16",
      "Int32",
      "Int64",
      "Int8",
      "Iterable",
      "Link",
      "Logger",
      "Math",
      "Mutex",
      "Nil",
      "Number",
      "JSON",
      "IO",
      "Object",
      "Pointer",
      "Proc",
      "Process",
      "Range",
      "Random",
      "Regex",
      "Reference",
      "Set",
      "Signal",
      "Slice",
      "Spec",
      "StaticArray",
      "String",
      "Struct",
      "Symbol",
      "System",
      "TCPServer",
      "TCPSocket",
      "Socket",
      "Tempfile",
      "Termios",
      "Time",
      "Tuple",
      "ThreadLocal",
      "UDPSocket",
      "UInt128",
      "UInt16",
      "UInt32",
      "UInt64",
      "UInt8",
      "Union",
      "UNIXServer",
      "UNIXSocket",
      "UUID",
      "URI",
      "VaList",
      "Value",
      "Void",
      "WeakRef",
      "XML",
      "YAML",
      "Zip",
      "Zlib",
      "abstract",
      "alias",
      "as",
      "as?",
      "asm",
      "begin",
      "break",
      "case",
      "class",
      "def",
      "do",
      "else",
      "elsif",
      "end",
      "ensure",
      "enum",
      "extend",
      "false",
      "for",
      "fun",
      "if",
      "in",
      "include",
      "instance_sizeof",
      "is_a?",
      "lib",
      "macro",
      "module",
      "next",
      "nil",
      "nil?",
      "of",
      "out",
      "pointerof",
      "private",
      "protected",
      "require",
      "rescue",
      "return",
      "select",
      "self",
      "sizeof",
      "struct",
      "super",
      "then",
      "true",
      "type",
      "typeof",
      "uninitialized",
      "union",
      "unless",
      "until",
      "when",
      "while",
      "with",
      "yield"
    ];
    function isAsciiLetterOrUnderscoreOrDigit(codePoint) {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscoreOrDigit)(codePoint);
    }
    function isAsciiLetterOrUnderscore(codePoint) {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscore)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isAsciiLetterOrUnderscoreOrDigit);
    function crystalStyle(original, isSnakeCase) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const wordStyle = isSnakeCase ? Strings_1.allLowerWordStyle : Strings_1.firstUpperWordStyle;
      const combined = (0, Strings_1.combineWords)(words, legalizeName, wordStyle, wordStyle, wordStyle, wordStyle, isSnakeCase ? "_" : "", isAsciiLetterOrUnderscore);
      return combined === "_" ? "_underscore" : combined;
    }
    var snakeNamingFunction = (0, Naming_1.funPrefixNamer)("default", (original) => crystalStyle(original, true));
    var camelNamingFunction = (0, Naming_1.funPrefixNamer)("camel", (original) => crystalStyle(original, false));
    function standardUnicodeCrystalEscape(codePoint) {
      if (codePoint <= 65535) {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 4) + "}";
      } else {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 6) + "}";
      }
    }
    var crystalStringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, standardUnicodeCrystalEscape));
    var CrystalRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext) {
        super(targetLanguage, renderContext);
      }
      makeNamedTypeNamer() {
        return camelNamingFunction;
      }
      namerForObjectProperty() {
        return snakeNamingFunction;
      }
      makeUnionMemberNamer() {
        return camelNamingFunction;
      }
      makeEnumCaseNamer() {
        return camelNamingFunction;
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      get commentLineStart() {
        return "# ";
      }
      nullableCrystalType(t, withIssues) {
        return [this.crystalType(t, withIssues), "?"];
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      crystalType(t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "JSON::Any?"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "Nil"), (_boolType) => "Bool", (_integerType) => "Int32", (_doubleType) => "Float64", (_stringType) => "String", (arrayType) => ["Array(", this.crystalType(arrayType.items, withIssues), ")"], (classType) => this.nameForNamedType(classType), (mapType) => ["Hash(String, ", this.crystalType(mapType.values, withIssues), ")"], (_enumType) => "String", (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return this.nullableCrystalType(nullable, withIssues);
          const [hasNull] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
          const name = this.nameForNamedType(unionType);
          return hasNull !== null ? [name, "?"] : name;
        });
      }
      breakCycle(t, withIssues) {
        return this.crystalType(t, withIssues);
      }
      emitRenameAttribute(propName, jsonName) {
        const escapedName = crystalStringEscape(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        if (namesDiffer) {
          this.emitLine('@[JSON::Field(key: "', escapedName, '")]');
        }
      }
      emitStructDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        const structBody = () => this.forEachClassProperty(c, "none", (name, jsonName, prop) => {
          this.ensureBlankLine();
          this.emitDescription(this.descriptionForClassProperty(c, jsonName));
          this.emitRenameAttribute(name, jsonName);
          this.emitLine("property ", name, " : ", this.crystalType(prop.type, true));
        });
        this.emitBlock(["class ", className], structBody);
      }
      emitBlock(line, f) {
        this.emitLine(line);
        this.indent(() => {
          this.emitLine("include JSON::Serializable");
        });
        this.ensureBlankLine();
        this.indent(f);
        this.emitLine("end");
      }
      emitEnum(line, f) {
        this.emitLine(line);
        this.indent(f);
        this.emitLine("end");
      }
      emitUnion(u, unionName) {
        const isMaybeWithSingleType = (0, TypeUtils_1.nullableFromUnion)(u);
        if (isMaybeWithSingleType !== null) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        let types = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_name, t) => {
          const crystalType = this.breakCycle(t, true);
          types.push([crystalType]);
        });
        this.emitLine([
          "alias ",
          unionName,
          " = ",
          types.map((r) => r.map((sl) => this.sourcelikeToString(sl))).join(" | ")
        ]);
      }
      emitTopLevelAlias(t, name) {
        this.emitLine("alias ", name, " = ", this.crystalType(t));
      }
      emitLeadingComments() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          return;
        }
      }
      emitSourceStructure() {
        this.emitLeadingComments();
        this.ensureBlankLine();
        this.emitLine('require "json"');
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelAlias(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachObject("leading-and-interposing", (c, name) => this.emitStructDefinition(c, name));
        this.forEachUnion("leading-and-interposing", (u, name) => this.emitUnion(u, name));
      }
    };
    exports.CrystalRenderer = CrystalRenderer;
  }
});

// node_modules/quicktype-core/dist/language/CSharp.js
var require_CSharp = __commonJS({
  "node_modules/quicktype-core/dist/language/CSharp.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemTextJsonCSharpRenderer = exports.systemTextJsonCSharpOptions = exports.NewtonsoftCSharpRenderer = exports.newtonsoftCSharpOptions = exports.CSharpRenderer = exports.CSharpTargetLanguage = exports.cSharpOptions = exports.AccessModifier = exports.Framework = void 0;
    var collection_utils_1 = require_dist();
    var unicode_properties_1 = __importDefault(require_main());
    var Annotation_1 = require_Annotation();
    var Constraints_1 = require_Constraints();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var Framework;
    (function(Framework2) {
      Framework2["Newtonsoft"] = "Newtonsoft";
      Framework2["SystemTextJson"] = "SystemTextJson";
    })(Framework = exports.Framework || (exports.Framework = {}));
    var AccessModifier;
    (function(AccessModifier2) {
      AccessModifier2["None"] = "None";
      AccessModifier2["Public"] = "Public";
      AccessModifier2["Internal"] = "Internal";
    })(AccessModifier = exports.AccessModifier || (exports.AccessModifier = {}));
    function noFollow(t) {
      return t;
    }
    function needTransformerForType(t) {
      if (t instanceof Type_1.UnionType) {
        const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(t);
        if (maybeNullable === null)
          return "automatic";
        if (needTransformerForType(maybeNullable) === "manual")
          return "nullable";
        return "none";
      }
      if (t instanceof Type_1.ArrayType) {
        const itemsNeed = needTransformerForType(t.items);
        if (itemsNeed === "manual" || itemsNeed === "nullable")
          return "automatic";
        return "none";
      }
      if (t instanceof Type_1.EnumType)
        return "automatic";
      if (t.kind === "double")
        return (0, Constraints_1.minMaxValueForType)(t) !== void 0 ? "manual" : "none";
      if (t.kind === "integer-string" || t.kind === "bool-string")
        return "manual";
      if (t.kind === "string") {
        return (0, Constraints_1.minMaxLengthForType)(t) !== void 0 ? "manual" : "none";
      }
      return "none";
    }
    function alwaysApplyTransformation(xf) {
      const t = xf.targetType;
      if (t instanceof Type_1.EnumType)
        return true;
      if (t instanceof Type_1.UnionType)
        return (0, TypeUtils_1.nullableFromUnion)(t) === null;
      return false;
    }
    function csTypeForTransformedStringType(t) {
      switch (t.kind) {
        case "date-time":
          return "DateTimeOffset";
        case "uuid":
          return "Guid";
        case "uri":
          return "Uri";
        default:
          return (0, Support_1.panic)(`Transformed string type ${t.kind} not supported`);
      }
    }
    exports.cSharpOptions = {
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", [
        ["NewtonSoft", Framework.Newtonsoft],
        ["SystemTextJson", Framework.SystemTextJson]
      ], "NewtonSoft"),
      useList: new RendererOptions_1.EnumOption("array-type", "Use T[] or List<T>", [
        ["array", false],
        ["list", true]
      ]),
      dense: new RendererOptions_1.EnumOption("density", "Property density", [
        ["normal", false],
        ["dense", true]
      ], "normal", "secondary"),
      // FIXME: Do this via a configurable named eventually.
      namespace: new RendererOptions_1.StringOption("namespace", "Generated namespace", "NAME", "QuickType"),
      version: new RendererOptions_1.EnumOption("csharp-version", "C# version", [
        ["5", 5],
        ["6", 6]
      ], "6", "secondary"),
      virtual: new RendererOptions_1.BooleanOption("virtual", "Generate virtual properties", false),
      typeForAny: new RendererOptions_1.EnumOption("any-type", 'Type to use for "any"', [
        ["object", "object"],
        ["dynamic", "dynamic"]
      ], "object", "secondary"),
      useDecimal: new RendererOptions_1.EnumOption("number-type", "Type to use for numbers", [
        ["double", false],
        ["decimal", true]
      ], "double", "secondary"),
      features: new RendererOptions_1.EnumOption("features", "Output features", [
        ["complete", { namespaces: true, helpers: true, attributes: true }],
        ["attributes-only", { namespaces: true, helpers: false, attributes: true }],
        ["just-types-and-namespace", { namespaces: true, helpers: false, attributes: false }],
        ["just-types", { namespaces: true, helpers: false, attributes: false }]
      ]),
      baseclass: new RendererOptions_1.EnumOption("base-class", "Base class", [
        ["EntityData", "EntityData"],
        ["Object", void 0]
      ], "Object", "secondary"),
      checkRequired: new RendererOptions_1.BooleanOption("check-required", "Fail if required properties are missing", false),
      keepPropertyName: new RendererOptions_1.BooleanOption("keep-property-name", "Keep original field name generate", false)
    };
    var CSharpTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("C#", ["cs", "csharp"], "cs");
      }
      getOptions() {
        return [
          exports.cSharpOptions.framework,
          exports.cSharpOptions.namespace,
          exports.cSharpOptions.version,
          exports.cSharpOptions.dense,
          exports.cSharpOptions.useList,
          exports.cSharpOptions.useDecimal,
          exports.cSharpOptions.typeForAny,
          exports.cSharpOptions.virtual,
          exports.cSharpOptions.features,
          exports.cSharpOptions.baseclass,
          exports.cSharpOptions.checkRequired,
          exports.cSharpOptions.keepPropertyName
        ];
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date-time");
        mapping.set("time", "date-time");
        mapping.set("date-time", "date-time");
        mapping.set("uuid", "uuid");
        mapping.set("uri", "uri");
        mapping.set("integer-string", "integer-string");
        mapping.set("bool-string", "bool-string");
        return mapping;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      needsTransformerForType(t) {
        const need = needTransformerForType(t);
        return need !== "none" && need !== "nullable";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.cSharpOptions, untypedOptionValues);
        switch (options.framework) {
          case Framework.Newtonsoft:
            return new NewtonsoftCSharpRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.newtonsoftCSharpOptions, untypedOptionValues));
          case Framework.SystemTextJson:
            return new SystemTextJsonCSharpRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.systemTextJsonCSharpOptions, untypedOptionValues));
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.CSharpTargetLanguage = CSharpTargetLanguage;
    var namingFunction = (0, Naming_1.funPrefixNamer)("namer", csNameStyle);
    var namingFunctionKeep = (0, Naming_1.funPrefixNamer)("namerKeep", csNameStyleKeep);
    var denseJsonPropertyName = "J";
    var denseRequiredEnumName = "R";
    var denseNullValueHandlingEnumName = "N";
    function isStartCharacter(utf16Unit) {
      if (unicode_properties_1.default.isAlphabetic(utf16Unit)) {
        return true;
      }
      return utf16Unit === 95;
    }
    function isPartCharacter(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      if (["Nd", "Pc", "Mn", "Mc"].includes(category)) {
        return true;
      }
      return isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function csNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, "", isStartCharacter);
    }
    function csNameStyleKeep(original) {
      const keywords = [
        "abstract",
        "as",
        "base",
        "bool",
        "break",
        "byte",
        "case",
        "catch",
        "char",
        "checked",
        "class",
        "const",
        "continue",
        "decimal",
        "default",
        "delegate",
        "do",
        "double",
        "else",
        "enum",
        "event",
        "explicit",
        "extern",
        "false",
        "finally",
        "fixed",
        "float",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "int",
        "interface",
        "internal",
        "is",
        "lock",
        "long",
        "namespace",
        "new",
        "null",
        "object",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "ref",
        "return",
        "sbyte",
        "sealed",
        "short",
        "sizeof",
        "stackalloc",
        "static",
        "string",
        "struct",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "uint",
        "ulong",
        "unchecked",
        "unsafe",
        "ushort",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
      ];
      const words = [
        {
          word: original,
          isAcronym: false
        }
      ];
      const result = (0, Strings_1.combineWords)(words, legalizeName, (x) => x, (x) => x, (x) => x, (x) => x, "", isStartCharacter);
      return keywords.includes(result) ? "@" + result : result;
    }
    function isValueType(t) {
      if (t instanceof Type_1.UnionType) {
        return (0, TypeUtils_1.nullableFromUnion)(t) === null;
      }
      return ["integer", "double", "bool", "enum", "date-time", "uuid"].includes(t.kind);
    }
    var CSharpRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _csOptions) {
        super(targetLanguage, renderContext);
        this._csOptions = _csOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return ["QuickType", "Type", "System", "Console", "Exception", "DateTimeOffset", "Guid", "Uri"];
      }
      forbiddenForObjectProperties(_, classNamed) {
        return {
          names: [
            classNamed,
            "ToString",
            "GetHashCode",
            "Finalize",
            "Equals",
            "GetType",
            "MemberwiseClone",
            "ReferenceEquals"
          ],
          includeGlobalForbidden: false
        };
      }
      forbiddenForUnionMembers(_, unionNamed) {
        return { names: [unionNamed], includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return namingFunction;
      }
      namerForObjectProperty() {
        return this._csOptions.keepPropertyName ? namingFunctionKeep : namingFunction;
      }
      makeUnionMemberNamer() {
        return namingFunction;
      }
      makeEnumCaseNamer() {
        return namingFunction;
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      emitBlock(f, semicolon = false) {
        this.emitLine("{");
        this.indent(f);
        this.emitLine("}", semicolon ? ";" : "");
      }
      get doubleType() {
        return this._csOptions.useDecimal ? "decimal" : "double";
      }
      csType(t, follow = Transformers_1.followTargetType, withIssues = false) {
        const actualType = follow(t);
        return (0, TypeUtils_1.matchType)(actualType, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this._csOptions.typeForAny), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this._csOptions.typeForAny), (_boolType) => "bool", (_integerType) => "long", (_doubleType) => this.doubleType, (_stringType) => "string", (arrayType) => {
          const itemsType = this.csType(arrayType.items, follow, withIssues);
          if (this._csOptions.useList) {
            return ["List<", itemsType, ">"];
          } else {
            return [itemsType, "[]"];
          }
        }, (classType) => this.nameForNamedType(classType), (mapType) => ["Dictionary<string, ", this.csType(mapType.values, follow, withIssues), ">"], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return this.nullableCSType(nullable, noFollow);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => csTypeForTransformedStringType(transformedStringType));
      }
      nullableCSType(t, follow = Transformers_1.followTargetType, withIssues = false) {
        t = (0, Transformers_1.followTargetType)(t);
        const csType = this.csType(t, follow, withIssues);
        if (isValueType(t)) {
          return [csType, "?"];
        } else {
          return csType;
        }
      }
      baseclassForType(_t) {
        return void 0;
      }
      emitType(description, accessModifier, declaration, name, baseclass, emitter) {
        switch (accessModifier) {
          case AccessModifier.Public:
            declaration = ["public ", declaration];
            break;
          case AccessModifier.Internal:
            declaration = ["internal ", declaration];
            break;
          default:
            break;
        }
        this.emitDescription(description);
        if (baseclass === void 0) {
          this.emitLine(declaration, " ", name);
        } else {
          this.emitLine(declaration, " ", name, " : ", baseclass);
        }
        this.emitBlock(emitter);
      }
      attributesForProperty(_property, _name, _c, _jsonName) {
        return void 0;
      }
      propertyDefinition(property, name, _c, _jsonName) {
        const t = property.type;
        const csType = property.isOptional ? this.nullableCSType(t, Transformers_1.followTargetType, true) : this.csType(t, Transformers_1.followTargetType, true);
        const propertyArray = ["public "];
        if (this._csOptions.virtual)
          propertyArray.push("virtual ");
        return [...propertyArray, csType, " ", name, " { get; set; }"];
      }
      emitDescriptionBlock(lines) {
        const start = "/// <summary>";
        if (this._csOptions.dense) {
          this.emitLine(start, lines.join("; "), "</summary>");
        } else {
          this.emitCommentLines(lines, { lineStart: "/// ", beforeComment: start, afterComment: "/// </summary>" });
        }
      }
      blankLinesBetweenAttributes() {
        return false;
      }
      emitClassDefinition(c, className) {
        this.emitType(this.descriptionForType(c), AccessModifier.Public, "partial class", className, this.baseclassForType(c), () => {
          if (c.getProperties().size === 0)
            return;
          const blankLines = this.blankLinesBetweenAttributes() ? "interposing" : "none";
          let columns = [];
          let isFirstProperty = true;
          let previousDescription = void 0;
          this.forEachClassProperty(c, blankLines, (name, jsonName, p) => {
            const attributes = this.attributesForProperty(p, name, c, jsonName);
            const description = this.descriptionForClassProperty(c, jsonName);
            const property = this.propertyDefinition(p, name, c, jsonName);
            if (attributes === void 0) {
              if (
                // Descriptions should be preceded by an empty line
                !isFirstProperty && description !== void 0 || // If the previous property has a description, leave an empty line
                previousDescription !== void 0
              ) {
                this.ensureBlankLine();
              }
              this.emitDescription(description);
              this.emitLine(property);
            } else if (this._csOptions.dense && attributes.length > 0) {
              const comment = description === void 0 ? "" : ` // ${description.join("; ")}`;
              columns.push([attributes, " ", property, comment]);
            } else {
              this.emitDescription(description);
              for (const attribute of attributes) {
                this.emitLine(attribute);
              }
              this.emitLine(property);
            }
            isFirstProperty = false;
            previousDescription = description;
          });
          if (columns.length > 0) {
            this.emitTable(columns);
          }
        });
      }
      emitUnionDefinition(u, unionName) {
        const nonNulls = (0, TypeUtils_1.removeNullFromUnion)(u, true)[1];
        this.emitType(this.descriptionForType(u), AccessModifier.Public, "partial struct", unionName, this.baseclassForType(u), () => {
          this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
            const csType = this.nullableCSType(t);
            this.emitLine("public ", csType, " ", fieldName, ";");
          });
          this.ensureBlankLine();
          const nullTests = Array.from(nonNulls).map((t) => [
            this.nameForUnionMember(u, t),
            " == null"
          ]);
          this.ensureBlankLine();
          this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
            const csType = this.csType(t);
            this.emitExpressionMember(["public static implicit operator ", unionName, "(", csType, " ", fieldName, ")"], ["new ", unionName, " { ", fieldName, " = ", fieldName, " }"]);
          });
          if (u.findMember("null") === void 0)
            return;
          this.emitExpressionMember("public bool IsNull", (0, collection_utils_1.arrayIntercalate)(" && ", nullTests), true);
        });
      }
      emitEnumDefinition(e, enumName) {
        const caseNames = [];
        this.forEachEnumCase(e, "none", (name) => {
          if (caseNames.length > 0)
            caseNames.push(", ");
          caseNames.push(name);
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("public enum ", enumName, " { ", caseNames, " };");
      }
      emitExpressionMember(declare, define2, isProperty = false) {
        if (this._csOptions.version === 5) {
          this.emitLine(declare);
          this.emitBlock(() => {
            const stmt = ["return ", define2, ";"];
            if (isProperty) {
              this.emitLine("get");
              this.emitBlock(() => this.emitLine(stmt));
            } else {
              this.emitLine(stmt);
            }
          });
        } else {
          this.emitLine(declare, " => ", define2, ";");
        }
      }
      emitTypeSwitch(types, condition, withBlock, withReturn, f) {
        (0, Support_1.assert)(!withReturn || withBlock, "Can only have return with block");
        for (const t of types) {
          this.emitLine("if (", condition(t), ")");
          if (withBlock) {
            this.emitBlock(() => {
              f(t);
              if (withReturn) {
                this.emitLine("return;");
              }
            });
          } else {
            this.indent(() => f(t));
          }
        }
      }
      emitUsing(ns) {
        this.emitLine("using ", ns, ";");
      }
      emitUsings() {
        for (const ns of ["System", "System.Collections.Generic"]) {
          this.emitUsing(ns);
        }
      }
      emitRequiredHelpers() {
        return;
      }
      emitTypesAndSupport() {
        this.forEachObject("leading-and-interposing", (c, name) => this.emitClassDefinition(c, name));
        this.forEachEnum("leading-and-interposing", (e, name) => this.emitEnumDefinition(e, name));
        this.forEachUnion("leading-and-interposing", (u, name) => this.emitUnionDefinition(u, name));
        this.emitRequiredHelpers();
      }
      emitDefaultLeadingComments() {
        return;
      }
      emitDefaultFollowingComments() {
        return;
      }
      needNamespace() {
        return true;
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitDefaultLeadingComments();
        }
        this.ensureBlankLine();
        if (this.needNamespace()) {
          this.emitLine("namespace ", this._csOptions.namespace);
          this.emitBlock(() => {
            this.emitUsings();
            this.emitTypesAndSupport();
          });
        } else {
          this.emitUsings();
          this.emitTypesAndSupport();
        }
        this.emitDefaultFollowingComments();
      }
    };
    exports.CSharpRenderer = CSharpRenderer;
    exports.newtonsoftCSharpOptions = Object.assign({}, exports.cSharpOptions, {});
    var NewtonsoftCSharpRenderer = class extends CSharpRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext, _options);
        this._options = _options;
        this._enumExtensionsNames = /* @__PURE__ */ new Map();
        this._needHelpers = _options.features.helpers;
        this._needAttributes = _options.features.attributes;
        this._needNamespaces = _options.features.namespaces;
      }
      forbiddenNamesForGlobalNamespace() {
        const forbidden = [
          "Converter",
          "JsonConverter",
          "JsonSerializer",
          "JsonWriter",
          "JsonToken",
          "Serialize",
          "Newtonsoft",
          "MetadataPropertyHandling",
          "DateParseHandling",
          "FromJson",
          "Required"
        ];
        if (this._options.dense) {
          forbidden.push("J", "R", "N");
        }
        if (this._options.baseclass !== void 0) {
          forbidden.push(this._options.baseclass);
        }
        return super.forbiddenNamesForGlobalNamespace().concat(forbidden);
      }
      forbiddenForObjectProperties(c, className) {
        const result = super.forbiddenForObjectProperties(c, className);
        result.names = result.names.concat(["ToJson", "FromJson", "Required"]);
        return result;
      }
      makeNameForTransformation(xf, typeName) {
        if (typeName === void 0) {
          let xfer = xf.transformer;
          if (xfer instanceof Transformers_1.DecodingTransformer && xfer.consumer !== void 0) {
            xfer = xfer.consumer;
          }
          return new Naming_1.SimpleName([`${xfer.kind}_converter`], namingFunction, ConvenienceRenderer_1.inferredNameOrder + 30);
        }
        return new Naming_1.DependencyName(namingFunction, typeName.order + 30, (lookup) => `${lookup(typeName)}_converter`);
      }
      makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof Type_1.EnumType))
          return [];
        const extensionsName = new Naming_1.DependencyName(namingFunction, name.order + 30, (lookup) => `${lookup(name)}_extensions`);
        this._enumExtensionsNames.set(name, extensionsName);
        return [extensionsName];
      }
      emitUsings() {
        if (!this._needAttributes && !this._needHelpers)
          return;
        super.emitUsings();
        this.ensureBlankLine();
        for (const ns of ["System.Globalization", "Newtonsoft.Json", "Newtonsoft.Json.Converters"]) {
          this.emitUsing(ns);
        }
        if (this._options.dense) {
          this.emitUsing([denseJsonPropertyName, " = Newtonsoft.Json.JsonPropertyAttribute"]);
          this.emitUsing([denseRequiredEnumName, " = Newtonsoft.Json.Required"]);
          this.emitUsing([denseNullValueHandlingEnumName, " = Newtonsoft.Json.NullValueHandling"]);
        }
        if (this._options.baseclass === "EntityData") {
          this.emitUsing("Microsoft.Azure.Mobile.Server");
        }
      }
      baseclassForType(_t) {
        return this._options.baseclass;
      }
      emitDefaultLeadingComments() {
        if (!this._needHelpers)
          return;
        this.emitLine("// <auto-generated />");
        this.emitLine("//");
        this.emitLine("// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do", this.topLevels.size === 1 ? "" : " one of these", ":");
        this.emitLine("//");
        this.emitLine("//    using ", this._options.namespace, ";");
        this.emitLine("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
          let rhs;
          if (t instanceof Type_1.EnumType) {
            rhs = ["JsonConvert.DeserializeObject<", topLevelName, ">(jsonString)"];
          } else {
            rhs = [topLevelName, ".FromJson(jsonString)"];
          }
          this.emitLine("//    var ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = ", rhs, ";");
        });
      }
      converterForType(t) {
        let xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0 && t instanceof Type_1.UnionType) {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (maybeNullable !== null) {
            t = maybeNullable;
            xf = (0, Transformers_1.transformationForType)(t);
          }
        }
        if (xf === void 0)
          return void 0;
        if (alwaysApplyTransformation(xf))
          return void 0;
        return (0, Support_1.defined)(this.nameForTransformation(t));
      }
      attributesForProperty(property, _name, _c, jsonName) {
        if (!this._needAttributes)
          return void 0;
        const attributes = [];
        const jsonProperty = this._options.dense ? denseJsonPropertyName : "JsonProperty";
        const escapedName = (0, Strings_1.utf16StringEscape)(jsonName);
        const isNullable = (0, Transformers_1.followTargetType)(property.type).isNullable;
        const isOptional = property.isOptional;
        const requiredClass = this._options.dense ? "R" : "Required";
        const nullValueHandlingClass = this._options.dense ? "N" : "NullValueHandling";
        const nullValueHandling = isOptional && !isNullable ? [", NullValueHandling = ", nullValueHandlingClass, ".Ignore"] : [];
        let required;
        if (!this._options.checkRequired || isOptional && isNullable) {
          required = [nullValueHandling];
        } else if (isOptional && !isNullable) {
          required = [", Required = ", requiredClass, ".DisallowNull", nullValueHandling];
        } else if (!isOptional && isNullable) {
          required = [", Required = ", requiredClass, ".AllowNull"];
        } else {
          required = [", Required = ", requiredClass, ".Always", nullValueHandling];
        }
        attributes.push(["[", jsonProperty, '("', escapedName, '"', required, ")]"]);
        const converter = this.converterForType(property.type);
        if (converter !== void 0) {
          attributes.push(["[JsonConverter(typeof(", converter, "))]"]);
        }
        return attributes;
      }
      blankLinesBetweenAttributes() {
        return this._needAttributes && !this._options.dense;
      }
      // The "this" type can't be `dynamic`, so we have to force it to `object`.
      topLevelResultType(t) {
        return t.kind === "any" || t.kind === "none" ? "object" : this.csType(t);
      }
      emitFromJsonForTopLevel(t, name) {
        if (t instanceof Type_1.EnumType)
          return;
        let partial;
        let typeKind;
        const definedType = this.namedTypeToNameForTopLevel(t);
        if (definedType !== void 0) {
          partial = "partial ";
          typeKind = definedType instanceof Type_1.ClassType ? "class" : "struct";
        } else {
          partial = "";
          typeKind = "class";
        }
        const csType = this.topLevelResultType(t);
        this.emitType(void 0, AccessModifier.Public, [partial, typeKind], name, this.baseclassForType(t), () => {
          this.emitExpressionMember(["public static ", csType, " FromJson(string json)"], ["JsonConvert.DeserializeObject<", csType, ">(json, ", this._options.namespace, ".Converter.Settings)"]);
        });
      }
      emitDecoderSwitch(emitBody) {
        this.emitLine("switch (reader.TokenType)");
        this.emitBlock(emitBody);
      }
      emitTokenCase(tokenType2) {
        this.emitLine("case JsonToken.", tokenType2, ":");
      }
      emitThrow(message) {
        this.emitLine("throw new Exception(", message, ");");
      }
      deserializeTypeCode(typeName) {
        return ["serializer.Deserialize<", typeName, ">(reader)"];
      }
      serializeValueCode(value) {
        return ["serializer.Serialize(writer, ", value, ")"];
      }
      emitSerializeClass() {
        this.emitType(void 0, AccessModifier.Public, "static class", "Serialize", void 0, () => {
          const seenTypes = /* @__PURE__ */ new Set();
          this.forEachTopLevel("none", (t) => {
            if (!seenTypes.has(t)) {
              seenTypes.add(t);
              this.emitExpressionMember(["public static string ToJson(this ", this.topLevelResultType(t), " self)"], ["JsonConvert.SerializeObject(self, ", this._options.namespace, ".Converter.Settings)"]);
            }
          });
        });
      }
      emitCanConvert(expr) {
        this.emitExpressionMember("public override bool CanConvert(Type t)", expr);
      }
      emitReadJson(emitBody) {
        this.emitLine("public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)");
        this.emitBlock(emitBody);
      }
      emitWriteJson(variable, emitBody) {
        this.emitLine("public override void WriteJson(JsonWriter writer, object ", variable, ", JsonSerializer serializer)");
        this.emitBlock(emitBody);
      }
      converterObject(converterName) {
        return [converterName, ".Singleton"];
      }
      emitConverterClass() {
        const converterName = ["Converter"];
        this.emitType(void 0, AccessModifier.Internal, "static class", converterName, void 0, () => {
          this.emitLine("public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings");
          this.emitBlock(() => {
            this.emitLine("MetadataPropertyHandling = MetadataPropertyHandling.Ignore,");
            this.emitLine("DateParseHandling = DateParseHandling.None,");
            this.emitLine("Converters =");
            this.emitLine("{");
            this.indent(() => {
              for (const [t, converter] of this.typesWithNamedTransformations) {
                if (alwaysApplyTransformation((0, Support_1.defined)((0, Transformers_1.transformationForType)(t)))) {
                  this.emitLine(this.converterObject(converter), ",");
                }
              }
              this.emitLine("new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }");
            });
            this.emitLine("},");
          }, true);
        });
      }
      emitDecoderTransformerCase(tokenCases, variableName, xfer, targetType, emitFinish) {
        if (xfer === void 0)
          return;
        for (const tokenCase of tokenCases) {
          this.emitTokenCase(tokenCase);
        }
        this.indent(() => {
          const allHandled = this.emitDecodeTransformer(xfer, targetType, emitFinish, variableName);
          if (!allHandled) {
            this.emitLine("break;");
          }
        });
      }
      emitConsume(value, consumer, targetType, emitFinish) {
        if (consumer === void 0) {
          emitFinish(value);
          return true;
        } else {
          return this.emitTransformer(value, consumer, targetType, emitFinish);
        }
      }
      emitDecodeTransformer(xfer, targetType, emitFinish, variableName = "value") {
        if (xfer instanceof Transformers_1.DecodingTransformer) {
          const source = xfer.sourceType;
          const converter = this.converterForType(targetType);
          if (converter !== void 0) {
            const typeSource = this.csType(targetType);
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("var ", variableName, " = (", typeSource, ")converter.ReadJson(reader, typeof(", typeSource, "), null, serializer);");
          } else if (source.kind !== "null") {
            let output = targetType.kind === "double" ? targetType : source;
            this.emitLine("var ", variableName, " = ", this.deserializeTypeCode(this.csType(output)), ";");
          }
          return this.emitConsume(variableName, xfer.consumer, targetType, emitFinish);
        } else if (xfer instanceof Transformers_1.ArrayDecodingTransformer) {
          if (!(targetType instanceof Type_1.ArrayType)) {
            return (0, Support_1.panic)("Array decoding must produce an array type");
          }
          this.emitLine("reader.Read();");
          this.emitLine("var ", variableName, " = new List<", this.csType(targetType.items), ">();");
          this.emitLine("while (reader.TokenType != JsonToken.EndArray)");
          this.emitBlock(() => {
            this.emitDecodeTransformer(xfer.itemTransformer, xfer.itemTargetType, (v) => this.emitLine(variableName, ".Add(", v, ");"), "arrayItem");
            this.emitLine("reader.Read();");
          });
          let result = variableName;
          if (!this._options.useList) {
            result = [result, ".ToArray()"];
          }
          emitFinish(result);
          return true;
        } else if (xfer instanceof Transformers_1.DecodingChoiceTransformer) {
          this.emitDecoderSwitch(() => {
            const nullTransformer = xfer.nullTransformer;
            if (nullTransformer !== void 0) {
              this.emitTokenCase("Null");
              this.indent(() => {
                const allHandled = this.emitDecodeTransformer(nullTransformer, targetType, emitFinish, "null");
                if (!allHandled) {
                  this.emitLine("break");
                }
              });
            }
            this.emitDecoderTransformerCase(["Integer"], "integerValue", xfer.integerTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(xfer.integerTransformer === void 0 ? ["Integer", "Float"] : ["Float"], "doubleValue", xfer.doubleTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(["Boolean"], "boolValue", xfer.boolTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(["String", "Date"], "stringValue", xfer.stringTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(["StartObject"], "objectValue", xfer.objectTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(["StartArray"], "arrayValue", xfer.arrayTransformer, targetType, emitFinish);
          });
          return false;
        } else {
          return (0, Support_1.panic)("Unknown transformer");
        }
      }
      stringCaseValue(t, stringCase) {
        if (t.kind === "string") {
          return ['"', (0, Strings_1.utf16StringEscape)(stringCase), '"'];
        } else if (t instanceof Type_1.EnumType) {
          return [this.nameForNamedType(t), ".", this.nameForEnumCase(t, stringCase)];
        }
        return (0, Support_1.panic)(`Type ${t.kind} does not have string cases`);
      }
      emitTransformer(variable, xfer, targetType, emitFinish) {
        function directTargetType(continuation) {
          if (continuation === void 0) {
            return targetType;
          }
          return (0, Transformers_1.followTargetType)(continuation.sourceType);
        }
        if (xfer instanceof Transformers_1.ChoiceTransformer) {
          const caseXfers = xfer.transformers;
          if (caseXfers.length > 1 && caseXfers.every((caseXfer) => caseXfer instanceof Transformers_1.StringMatchTransformer)) {
            this.emitLine("switch (", variable, ")");
            this.emitBlock(() => {
              for (const caseXfer of caseXfers) {
                const matchXfer = caseXfer;
                const value = this.stringCaseValue((0, Transformers_1.followTargetType)(matchXfer.sourceType), matchXfer.stringCase);
                this.emitLine("case ", value, ":");
                this.indent(() => {
                  const allDone = this.emitTransformer(variable, matchXfer.transformer, targetType, emitFinish);
                  if (!allDone) {
                    this.emitLine("break;");
                  }
                });
              }
            });
            return false;
          } else {
            for (const caseXfer of caseXfers) {
              this.emitTransformer(variable, caseXfer, targetType, emitFinish);
            }
          }
        } else if (xfer instanceof Transformers_1.UnionMemberMatchTransformer) {
          const memberType = xfer.memberType;
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(xfer.sourceType);
          let test;
          let member;
          if (maybeNullable !== null) {
            if (memberType.kind === "null") {
              test = [variable, " == null"];
              member = "null";
            } else {
              test = [variable, " != null"];
              member = variable;
            }
          } else if (memberType.kind === "null") {
            test = [variable, ".IsNull"];
            member = "null";
          } else {
            const memberName = this.nameForUnionMember(xfer.sourceType, memberType);
            member = [variable, ".", memberName];
            test = [member, " != null"];
          }
          if (memberType.kind !== "null" && isValueType(memberType)) {
            member = [member, ".Value"];
          }
          this.emitLine("if (", test, ")");
          this.emitBlock(() => this.emitTransformer(member, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.StringMatchTransformer) {
          const value = this.stringCaseValue((0, Transformers_1.followTargetType)(xfer.sourceType), xfer.stringCase);
          this.emitLine("if (", variable, " == ", value, ")");
          this.emitBlock(() => this.emitTransformer(variable, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.EncodingTransformer) {
          const converter = this.converterForType(xfer.sourceType);
          if (converter !== void 0) {
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("converter.WriteJson(writer, ", variable, ", serializer);");
          } else {
            this.emitLine(this.serializeValueCode(variable), ";");
          }
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ArrayEncodingTransformer) {
          this.emitLine("writer.WriteStartArray();");
          const itemVariable = "arrayItem";
          this.emitLine("foreach (var ", itemVariable, " in ", variable, ")");
          this.emitBlock(() => {
            this.emitTransformer(itemVariable, xfer.itemTransformer, xfer.itemTargetType, () => {
              return;
            });
          });
          this.emitLine("writer.WriteEndArray();");
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ParseStringTransformer) {
          const immediateTargetType = xfer.consumer === void 0 ? targetType : xfer.consumer.sourceType;
          switch (immediateTargetType.kind) {
            case "date-time":
              this.emitLine("DateTimeOffset dt;");
              this.emitLine("if (DateTimeOffset.TryParse(", variable, ", out dt))");
              this.emitBlock(() => this.emitConsume("dt", xfer.consumer, targetType, emitFinish));
              break;
            case "uuid":
              this.emitLine("Guid guid;");
              this.emitLine("if (Guid.TryParse(", variable, ", out guid))");
              this.emitBlock(() => this.emitConsume("guid", xfer.consumer, targetType, emitFinish));
              break;
            case "uri":
              this.emitLine("try");
              this.emitBlock(() => {
                this.emitLine("var uri = new Uri(", variable, ");");
                this.emitConsume("uri", xfer.consumer, targetType, emitFinish);
              });
              this.emitLine("catch (UriFormatException) {}");
              break;
            case "integer":
              this.emitLine("long l;");
              this.emitLine("if (Int64.TryParse(", variable, ", out l))");
              this.emitBlock(() => this.emitConsume("l", xfer.consumer, targetType, emitFinish));
              break;
            case "bool":
              this.emitLine("bool b;");
              this.emitLine("if (Boolean.TryParse(", variable, ", out b))");
              this.emitBlock(() => this.emitConsume("b", xfer.consumer, targetType, emitFinish));
              break;
            default:
              return (0, Support_1.panic)(`Parsing string to ${immediateTargetType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringifyTransformer) {
          switch (xfer.sourceType.kind) {
            case "date-time":
              return this.emitConsume([variable, '.ToString("o", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
            case "uuid":
              return this.emitConsume([variable, '.ToString("D", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
            case "integer":
            case "uri":
              return this.emitConsume([variable, ".ToString()"], xfer.consumer, targetType, emitFinish);
            case "bool":
              this.emitLine("var boolString = ", variable, ' ? "true" : "false";');
              return this.emitConsume("boolString", xfer.consumer, targetType, emitFinish);
            default:
              return (0, Support_1.panic)(`Stringifying ${xfer.sourceType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringProducerTransformer) {
          const value = this.stringCaseValue(directTargetType(xfer.consumer), xfer.result);
          return this.emitConsume(value, xfer.consumer, targetType, emitFinish);
        } else if (xfer instanceof Transformers_1.MinMaxLengthCheckTransformer) {
          const min = xfer.minLength;
          const max = xfer.maxLength;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([variable, ".Length >= ", min.toString()]);
          }
          if (max !== void 0) {
            conditions.push([variable, ".Length <= ", max.toString()]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([" && "], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.MinMaxValueTransformer) {
          const min = xfer.minimum;
          const max = xfer.maximum;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([variable, " >= ", min.toString()]);
          }
          if (max !== void 0) {
            conditions.push([variable, " <= ", max.toString()]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([" && "], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.UnionInstantiationTransformer) {
          if (!(targetType instanceof Type_1.UnionType)) {
            return (0, Support_1.panic)("Union instantiation transformer must produce a union type");
          }
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(targetType);
          if (maybeNullable !== null) {
            emitFinish(variable);
          } else {
            const unionName = this.nameForNamedType(targetType);
            let initializer;
            if (xfer.sourceType.kind === "null") {
              initializer = " ";
            } else {
              const memberName = this.nameForUnionMember(targetType, xfer.sourceType);
              initializer = [" ", memberName, " = ", variable, " "];
            }
            emitFinish(["new ", unionName, " {", initializer, "}"]);
          }
          return true;
        } else {
          return (0, Support_1.panic)("Unknown transformer");
        }
        return false;
      }
      emitTransformation(converterName, t) {
        const xf = (0, Support_1.defined)((0, Transformers_1.transformationForType)(t));
        const reverse = xf.reverse;
        const targetType = xf.targetType;
        const xfer = xf.transformer;
        this.emitType(void 0, AccessModifier.Internal, "class", converterName, "JsonConverter", () => {
          const csType = this.csType(targetType);
          let canConvertExpr = ["t == typeof(", csType, ")"];
          const haveNullable = isValueType(targetType);
          if (haveNullable) {
            canConvertExpr = [canConvertExpr, " || t == typeof(", csType, "?)"];
          }
          this.emitCanConvert(canConvertExpr);
          this.ensureBlankLine();
          this.emitReadJson(() => {
            if (haveNullable && !(targetType instanceof Type_1.UnionType)) {
              this.emitLine("if (reader.TokenType == JsonToken.Null) return null;");
            }
            const allHandled = this.emitDecodeTransformer(xfer, targetType, (v) => this.emitLine("return ", v, ";"));
            if (!allHandled) {
              this.emitThrow(['"Cannot unmarshal type ', csType, '"']);
            }
          });
          this.ensureBlankLine();
          this.emitWriteJson("untypedValue", () => {
            if (haveNullable && !(targetType instanceof Type_1.UnionType)) {
              this.emitLine("if (untypedValue == null)");
              this.emitBlock(() => {
                this.emitLine("serializer.Serialize(writer, null);");
                this.emitLine("return;");
              });
            }
            this.emitLine("var value = (", csType, ")untypedValue;");
            const allHandled = this.emitTransformer("value", reverse.transformer, reverse.targetType, () => this.emitLine("return;"));
            if (!allHandled) {
              this.emitThrow(['"Cannot marshal type ', csType, '"']);
            }
          });
          this.ensureBlankLine();
          this.emitLine("public static readonly ", converterName, " Singleton = new ", converterName, "();");
        });
      }
      emitRequiredHelpers() {
        if (this._needHelpers) {
          this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitFromJsonForTopLevel(t, n));
          this.ensureBlankLine();
          this.emitSerializeClass();
        }
        if (this._needHelpers || this._needAttributes && (this.haveNamedUnions || this.haveEnums)) {
          this.ensureBlankLine();
          this.emitConverterClass();
          this.forEachTransformation("leading-and-interposing", (n, t) => this.emitTransformation(n, t));
        }
      }
      needNamespace() {
        return this._needNamespaces;
      }
    };
    exports.NewtonsoftCSharpRenderer = NewtonsoftCSharpRenderer;
    exports.systemTextJsonCSharpOptions = Object.assign({}, exports.cSharpOptions, {});
    var SystemTextJsonCSharpRenderer = class extends CSharpRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext, _options);
        this._options = _options;
        this._enumExtensionsNames = /* @__PURE__ */ new Map();
        this._needHelpers = _options.features.helpers;
        this._needAttributes = _options.features.attributes;
        this._needNamespaces = _options.features.namespaces;
      }
      forbiddenNamesForGlobalNamespace() {
        const forbidden = [
          "Converter",
          "JsonConverter",
          "JsonSerializer",
          "JsonWriter",
          "JsonToken",
          "Serialize",
          "JsonSerializerOptions",
          // "Newtonsoft",
          // "MetadataPropertyHandling",
          // "DateParseHandling",
          "FromJson",
          "Required"
        ];
        if (this._options.dense) {
          forbidden.push("J", "R", "N");
        }
        if (this._options.baseclass !== void 0) {
          forbidden.push(this._options.baseclass);
        }
        return super.forbiddenNamesForGlobalNamespace().concat(forbidden);
      }
      forbiddenForObjectProperties(c, className) {
        const result = super.forbiddenForObjectProperties(c, className);
        result.names = result.names.concat(["ToJson", "FromJson", "Required"]);
        return result;
      }
      makeNameForTransformation(xf, typeName) {
        if (typeName === void 0) {
          let xfer = xf.transformer;
          if (xfer instanceof Transformers_1.DecodingTransformer && xfer.consumer !== void 0) {
            xfer = xfer.consumer;
          }
          return new Naming_1.SimpleName([`${xfer.kind}_converter`], namingFunction, ConvenienceRenderer_1.inferredNameOrder + 30);
        }
        return new Naming_1.DependencyName(namingFunction, typeName.order + 30, (lookup) => `${lookup(typeName)}_converter`);
      }
      makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof Type_1.EnumType))
          return [];
        const extensionsName = new Naming_1.DependencyName(namingFunction, name.order + 30, (lookup) => `${lookup(name)}_extensions`);
        this._enumExtensionsNames.set(name, extensionsName);
        return [extensionsName];
      }
      emitUsings() {
        if (!this._needAttributes && !this._needHelpers)
          return;
        super.emitUsings();
        this.ensureBlankLine();
        for (const ns of ["System.Text.Json", "System.Text.Json.Serialization", "System.Globalization"]) {
          this.emitUsing(ns);
        }
        if (this._options.dense) {
          this.emitUsing([denseJsonPropertyName, " = System.Text.Json.Serialization.JsonPropertyNameAttribute"]);
          this.emitUsing([denseNullValueHandlingEnumName, " = System.Text.Json.Serialization.JsonIgnoreCondition"]);
        }
        if (this._options.baseclass === "EntityData") {
          this.emitUsing("Microsoft.Azure.Mobile.Server");
        }
      }
      baseclassForType(_t) {
        return this._options.baseclass;
      }
      emitDefaultFollowingComments() {
        if (!this._needHelpers)
          return;
        this.emitLine("#pragma warning restore CS8618");
        this.emitLine("#pragma warning restore CS8601");
        this.emitLine("#pragma warning restore CS8603");
      }
      emitDefaultLeadingComments() {
        if (!this._needHelpers)
          return;
        this.emitLine("// <auto-generated />");
        this.emitLine("//");
        this.emitLine("// To parse this JSON data, add NuGet 'System.Text.Json' then do", this.topLevels.size === 1 ? "" : " one of these", ":");
        this.emitLine("//");
        this.emitLine("//    using ", this._options.namespace, ";");
        this.emitLine("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
          let rhs;
          if (t instanceof Type_1.EnumType) {
            rhs = ["JsonSerializer.Deserialize<", topLevelName, ">(jsonString)"];
          } else {
            rhs = [topLevelName, ".FromJson(jsonString)"];
          }
          this.emitLine("//    var ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = ", rhs, ";");
        });
        this.emitLine("#nullable enable");
        this.emitLine("#pragma warning disable CS8618");
        this.emitLine("#pragma warning disable CS8601");
        this.emitLine("#pragma warning disable CS8603");
      }
      converterForType(t) {
        let xf = (0, Transformers_1.transformationForType)(t);
        if (xf === void 0 && t instanceof Type_1.UnionType) {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (maybeNullable !== null) {
            t = maybeNullable;
            xf = (0, Transformers_1.transformationForType)(t);
          }
        }
        if (xf === void 0)
          return void 0;
        if (alwaysApplyTransformation(xf))
          return void 0;
        return (0, Support_1.defined)(this.nameForTransformation(t));
      }
      attributesForProperty(property, _name, _c, jsonName) {
        if (!this._needAttributes)
          return void 0;
        const attributes = [];
        const jsonPropertyName = this._options.dense ? denseJsonPropertyName : "JsonPropertyName";
        const escapedName = (0, Strings_1.utf16StringEscape)(jsonName);
        const isNullable = (0, Transformers_1.followTargetType)(property.type).isNullable;
        const isOptional = property.isOptional;
        if (isOptional && !isNullable) {
          attributes.push(["[", "JsonIgnore", "(Condition = JsonIgnoreCondition.WhenWritingNull)]"]);
        }
        attributes.push(["[", jsonPropertyName, '("', escapedName, '")]']);
        const converter = this.converterForType(property.type);
        if (converter !== void 0) {
          attributes.push(["[JsonConverter(typeof(", converter, "))]"]);
        }
        return attributes;
      }
      blankLinesBetweenAttributes() {
        return this._needAttributes && !this._options.dense;
      }
      // The "this" type can't be `dynamic`, so we have to force it to `object`.
      topLevelResultType(t) {
        return t.kind === "any" || t.kind === "none" ? "object" : this.csType(t);
      }
      emitFromJsonForTopLevel(t, name) {
        if (t instanceof Type_1.EnumType)
          return;
        let partial;
        let typeKind;
        const definedType = this.namedTypeToNameForTopLevel(t);
        if (definedType !== void 0) {
          partial = "partial ";
          typeKind = definedType instanceof Type_1.ClassType ? "class" : "struct";
        } else {
          partial = "";
          typeKind = "class";
        }
        const csType = this.topLevelResultType(t);
        this.emitType(void 0, AccessModifier.Public, [partial, typeKind], name, this.baseclassForType(t), () => {
          this.emitExpressionMember(["public static ", csType, " FromJson(string json)"], ["JsonSerializer.Deserialize<", csType, ">(json, ", this._options.namespace, ".Converter.Settings)"]);
        });
      }
      emitDecoderSwitch(emitBody) {
        this.emitLine("switch (reader.TokenType)");
        this.emitBlock(emitBody);
      }
      emitTokenCase(tokenType2) {
        this.emitLine("case JsonTokenType.", tokenType2, ":");
      }
      emitThrow(message) {
        this.emitLine("throw new Exception(", message, ");");
      }
      deserializeTypeCode(typeName) {
        switch (typeName) {
          case "bool":
            return ["reader.GetBoolean()"];
          case "long":
            return ["reader.GetInt64()"];
          case "decimal":
            return ["reader.GetDecimal()"];
          case "double":
            return ["reader.GetDouble()"];
          case "string":
            return ["reader.GetString()"];
          default:
            return ["JsonSerializer.Deserialize<", typeName, ">(ref reader, options)"];
        }
      }
      serializeValueCode(value) {
        if (value !== "null")
          return ["JsonSerializer.Serialize(writer, ", value, ", options)"];
        else
          return ["writer.WriteNullValue()"];
      }
      emitSerializeClass() {
        this.emitType(void 0, AccessModifier.Public, "static class", "Serialize", void 0, () => {
          const seenTypes = /* @__PURE__ */ new Set();
          this.forEachTopLevel("none", (t) => {
            if (!seenTypes.has(t)) {
              seenTypes.add(t);
              this.emitExpressionMember(["public static string ToJson(this ", this.topLevelResultType(t), " self)"], ["JsonSerializer.Serialize(self, ", this._options.namespace, ".Converter.Settings)"]);
            }
          });
        });
      }
      emitCanConvert(expr) {
        this.emitExpressionMember("public override bool CanConvert(Type t)", expr);
      }
      emitReadJson(emitBody, csType) {
        this.emitLine("public override ", csType, " Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)");
        this.emitBlock(emitBody);
      }
      emitWriteJson(variable, emitBody, csType) {
        this.emitLine("public override void Write(Utf8JsonWriter writer, ", csType, " ", variable, ", JsonSerializerOptions options)");
        this.emitBlock(emitBody);
      }
      converterObject(converterName) {
        return [converterName, ".Singleton"];
      }
      emitConverterClass() {
        const converterName = ["Converter"];
        this.emitType(void 0, AccessModifier.Internal, "static class", converterName, void 0, () => {
          this.emitLine("public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)");
          this.emitBlock(() => {
            this.emitLine("Converters =");
            this.emitLine("{");
            this.indent(() => {
              for (const [t, converter] of this.typesWithNamedTransformations) {
                if (alwaysApplyTransformation((0, Support_1.defined)((0, Transformers_1.transformationForType)(t)))) {
                  this.emitLine(this.converterObject(converter), ",");
                }
              }
              this.emitLine("new DateOnlyConverter(),");
              this.emitLine("new TimeOnlyConverter(),");
              this.emitLine("IsoDateTimeOffsetConverter.Singleton");
            });
            this.emitLine("},");
          }, true);
        });
      }
      emitDecoderTransformerCase(tokenCases, variableName, xfer, targetType, emitFinish) {
        if (xfer === void 0)
          return;
        for (const tokenCase of tokenCases) {
          this.emitTokenCase(tokenCase);
        }
        this.indent(() => {
          const allHandled = this.emitDecodeTransformer(xfer, targetType, emitFinish, variableName);
          if (!allHandled) {
            this.emitLine("break;");
          }
        });
      }
      emitConsume(value, consumer, targetType, emitFinish) {
        if (consumer === void 0) {
          emitFinish(value);
          return true;
        } else {
          return this.emitTransformer(value, consumer, targetType, emitFinish);
        }
      }
      emitDecodeTransformer(xfer, targetType, emitFinish, variableName = "value") {
        if (xfer instanceof Transformers_1.DecodingTransformer) {
          const source = xfer.sourceType;
          const converter = this.converterForType(targetType);
          if (converter !== void 0) {
            const typeSource = this.csType(targetType);
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("var ", variableName, " = (", typeSource, ")converter.ReadJson(reader, typeof(", typeSource, "), null, serializer);");
          } else if (source.kind !== "null") {
            let output = targetType.kind === "double" ? targetType : source;
            this.emitLine("var ", variableName, " = ", this.deserializeTypeCode(this.csType(output)), ";");
          }
          return this.emitConsume(variableName, xfer.consumer, targetType, emitFinish);
        } else if (xfer instanceof Transformers_1.ArrayDecodingTransformer) {
          if (!(targetType instanceof Type_1.ArrayType)) {
            return (0, Support_1.panic)("Array decoding must produce an array type");
          }
          this.emitLine("reader.Read();");
          this.emitLine("var ", variableName, " = new List<", this.csType(targetType.items), ">();");
          this.emitLine("while (reader.TokenType != JsonToken.EndArray)");
          this.emitBlock(() => {
            this.emitDecodeTransformer(xfer.itemTransformer, xfer.itemTargetType, (v) => this.emitLine(variableName, ".Add(", v, ");"), "arrayItem");
            this.emitLine("reader.Read();");
          });
          let result = variableName;
          if (!this._options.useList) {
            result = [result, ".ToArray()"];
          }
          emitFinish(result);
          return true;
        } else if (xfer instanceof Transformers_1.DecodingChoiceTransformer) {
          this.emitDecoderSwitch(() => {
            const nullTransformer = xfer.nullTransformer;
            if (nullTransformer !== void 0) {
              this.emitTokenCase("Null");
              this.indent(() => {
                const allHandled = this.emitDecodeTransformer(nullTransformer, targetType, emitFinish, "null");
                if (!allHandled) {
                  this.emitLine("break");
                }
              });
            }
            this.emitDecoderTransformerCase(["Number"], "integerValue", xfer.integerTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(
              ["Number"],
              // xfer.integerTransformer === undefined ? ["Integer", "Float"] : ["Float"],
              "doubleValue",
              xfer.doubleTransformer,
              targetType,
              emitFinish
            );
            this.emitDecoderTransformerCase(["True", "False"], "boolValue", xfer.boolTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(
              // ["String", "Date"],
              ["String"],
              "stringValue",
              xfer.stringTransformer,
              targetType,
              emitFinish
            );
            this.emitDecoderTransformerCase(["StartObject"], "objectValue", xfer.objectTransformer, targetType, emitFinish);
            this.emitDecoderTransformerCase(["StartArray"], "arrayValue", xfer.arrayTransformer, targetType, emitFinish);
          });
          return false;
        } else {
          return (0, Support_1.panic)("Unknown transformer");
        }
      }
      stringCaseValue(t, stringCase) {
        if (t.kind === "string") {
          return ['"', (0, Strings_1.utf16StringEscape)(stringCase), '"'];
        } else if (t instanceof Type_1.EnumType) {
          return [this.nameForNamedType(t), ".", this.nameForEnumCase(t, stringCase)];
        }
        return (0, Support_1.panic)(`Type ${t.kind} does not have string cases`);
      }
      emitTransformer(variable, xfer, targetType, emitFinish) {
        function directTargetType(continuation) {
          if (continuation === void 0) {
            return targetType;
          }
          return (0, Transformers_1.followTargetType)(continuation.sourceType);
        }
        if (xfer instanceof Transformers_1.ChoiceTransformer) {
          const caseXfers = xfer.transformers;
          if (caseXfers.length > 1 && caseXfers.every((caseXfer) => caseXfer instanceof Transformers_1.StringMatchTransformer)) {
            this.emitLine("switch (", variable, ")");
            this.emitBlock(() => {
              for (const caseXfer of caseXfers) {
                const matchXfer = caseXfer;
                const value = this.stringCaseValue((0, Transformers_1.followTargetType)(matchXfer.sourceType), matchXfer.stringCase);
                this.emitLine("case ", value, ":");
                this.indent(() => {
                  const allDone = this.emitTransformer(variable, matchXfer.transformer, targetType, emitFinish);
                  if (!allDone) {
                    this.emitLine("break;");
                  }
                });
              }
            });
            return false;
          } else {
            for (const caseXfer of caseXfers) {
              this.emitTransformer(variable, caseXfer, targetType, emitFinish);
            }
          }
        } else if (xfer instanceof Transformers_1.UnionMemberMatchTransformer) {
          const memberType = xfer.memberType;
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(xfer.sourceType);
          let test;
          let member;
          if (maybeNullable !== null) {
            if (memberType.kind === "null") {
              test = [variable, " == null"];
              member = "null";
            } else {
              test = [variable, " != null"];
              member = variable;
            }
          } else if (memberType.kind === "null") {
            test = [variable, ".IsNull"];
            member = "null";
          } else {
            const memberName = this.nameForUnionMember(xfer.sourceType, memberType);
            member = [variable, ".", memberName];
            test = [member, " != null"];
          }
          if (memberType.kind !== "null" && isValueType(memberType)) {
            member = [member, ".Value"];
          }
          this.emitLine("if (", test, ")");
          this.emitBlock(() => this.emitTransformer(member, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.StringMatchTransformer) {
          const value = this.stringCaseValue((0, Transformers_1.followTargetType)(xfer.sourceType), xfer.stringCase);
          this.emitLine("if (", variable, " == ", value, ")");
          this.emitBlock(() => this.emitTransformer(variable, xfer.transformer, targetType, emitFinish));
        } else if (xfer instanceof Transformers_1.EncodingTransformer) {
          const converter = this.converterForType(xfer.sourceType);
          if (converter !== void 0) {
            this.emitLine("var converter = ", this.converterObject(converter), ";");
            this.emitLine("converter.WriteJson(writer, ", variable, ", serializer);");
          } else {
            this.emitLine(this.serializeValueCode(variable), ";");
          }
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ArrayEncodingTransformer) {
          this.emitLine("writer.WriteStartArray();");
          const itemVariable = "arrayItem";
          this.emitLine("foreach (var ", itemVariable, " in ", variable, ")");
          this.emitBlock(() => {
            this.emitTransformer(itemVariable, xfer.itemTransformer, xfer.itemTargetType, () => {
              return;
            });
          });
          this.emitLine("writer.WriteEndArray();");
          emitFinish([]);
          return true;
        } else if (xfer instanceof Transformers_1.ParseStringTransformer) {
          const immediateTargetType = xfer.consumer === void 0 ? targetType : xfer.consumer.sourceType;
          switch (immediateTargetType.kind) {
            case "date-time":
              this.emitLine("DateTimeOffset dt;");
              this.emitLine("if (DateTimeOffset.TryParse(", variable, ", out dt))");
              this.emitBlock(() => this.emitConsume("dt", xfer.consumer, targetType, emitFinish));
              break;
            case "uuid":
              this.emitLine("Guid guid;");
              this.emitLine("if (Guid.TryParse(", variable, ", out guid))");
              this.emitBlock(() => this.emitConsume("guid", xfer.consumer, targetType, emitFinish));
              break;
            case "uri":
              this.emitLine("try");
              this.emitBlock(() => {
                this.emitLine('var uri = new Uri("about:blank");');
                this.emitLine("if (!string.IsNullOrEmpty(stringValue))");
                this.emitBlock(() => {
                  this.emitLine("uri = new Uri(", variable, ");");
                });
                this.emitConsume("uri", xfer.consumer, targetType, emitFinish);
              });
              this.emitLine("catch (UriFormatException) {}");
              break;
            case "integer":
              this.emitLine("long l;");
              this.emitLine("if (Int64.TryParse(", variable, ", out l))");
              this.emitBlock(() => this.emitConsume("l", xfer.consumer, targetType, emitFinish));
              break;
            case "bool":
              this.emitLine("bool b;");
              this.emitLine("if (Boolean.TryParse(", variable, ", out b))");
              this.emitBlock(() => this.emitConsume("b", xfer.consumer, targetType, emitFinish));
              break;
            default:
              return (0, Support_1.panic)(`Parsing string to ${immediateTargetType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringifyTransformer) {
          switch (xfer.sourceType.kind) {
            case "date-time":
              return this.emitConsume([variable, '.ToString("o", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
            case "uuid":
              return this.emitConsume([variable, '.ToString("D", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
            case "integer":
            case "uri":
              return this.emitConsume([variable, ".ToString()"], xfer.consumer, targetType, emitFinish);
            case "bool":
              this.emitLine("var boolString = ", variable, ' ? "true" : "false";');
              return this.emitConsume("boolString", xfer.consumer, targetType, emitFinish);
            default:
              return (0, Support_1.panic)(`Stringifying ${xfer.sourceType.kind} not supported`);
          }
        } else if (xfer instanceof Transformers_1.StringProducerTransformer) {
          const value = this.stringCaseValue(directTargetType(xfer.consumer), xfer.result);
          return this.emitConsume(value, xfer.consumer, targetType, emitFinish);
        } else if (xfer instanceof Transformers_1.MinMaxLengthCheckTransformer) {
          const min = xfer.minLength;
          const max = xfer.maxLength;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([variable, ".Length >= ", min.toString()]);
          }
          if (max !== void 0) {
            conditions.push([variable, ".Length <= ", max.toString()]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([" && "], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.MinMaxValueTransformer) {
          const min = xfer.minimum;
          const max = xfer.maximum;
          const conditions = [];
          if (min !== void 0) {
            conditions.push([variable, " >= ", min.toString()]);
          }
          if (max !== void 0) {
            conditions.push([variable, " <= ", max.toString()]);
          }
          this.emitLine("if (", (0, collection_utils_1.arrayIntercalate)([" && "], conditions), ")");
          this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
          return false;
        } else if (xfer instanceof Transformers_1.UnionInstantiationTransformer) {
          if (!(targetType instanceof Type_1.UnionType)) {
            return (0, Support_1.panic)("Union instantiation transformer must produce a union type");
          }
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(targetType);
          if (maybeNullable !== null) {
            emitFinish(variable);
          } else {
            const unionName = this.nameForNamedType(targetType);
            let initializer;
            if (xfer.sourceType.kind === "null") {
              initializer = " ";
            } else {
              const memberName = this.nameForUnionMember(targetType, xfer.sourceType);
              initializer = [" ", memberName, " = ", variable, " "];
            }
            emitFinish(["new ", unionName, " {", initializer, "}"]);
          }
          return true;
        } else {
          return (0, Support_1.panic)("Unknown transformer");
        }
        return false;
      }
      emitTransformation(converterName, t) {
        const xf = (0, Support_1.defined)((0, Transformers_1.transformationForType)(t));
        const reverse = xf.reverse;
        const targetType = xf.targetType;
        const xfer = xf.transformer;
        const csType = this.csType(targetType);
        this.emitType(void 0, AccessModifier.Internal, "class", converterName, ["JsonConverter<", csType, ">"], () => {
          let canConvertExpr = ["t == typeof(", csType, ")"];
          this.emitCanConvert(canConvertExpr);
          this.ensureBlankLine();
          this.emitReadJson(() => {
            const allHandled = this.emitDecodeTransformer(xfer, targetType, (v) => this.emitLine("return ", v, ";"));
            if (!allHandled) {
              this.emitThrow(['"Cannot unmarshal type ', csType, '"']);
            }
          }, csType);
          this.ensureBlankLine();
          this.emitWriteJson("value", () => {
            const allHandled = this.emitTransformer("value", reverse.transformer, reverse.targetType, () => this.emitLine("return;"));
            if (!allHandled) {
              this.emitThrow(['"Cannot marshal type ', csType, '"']);
            }
          }, csType);
          this.ensureBlankLine();
          this.emitLine("public static readonly ", converterName, " Singleton = new ", converterName, "();");
        });
      }
      emitRequiredHelpers() {
        if (this._needHelpers) {
          this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitFromJsonForTopLevel(t, n));
          this.ensureBlankLine();
          this.emitSerializeClass();
        }
        if (this._needHelpers || this._needAttributes && (this.haveNamedUnions || this.haveEnums)) {
          this.ensureBlankLine();
          this.emitConverterClass();
          this.forEachTransformation("leading-and-interposing", (n, t) => this.emitTransformation(n, t));
          this.emitMultiline(`
public class DateOnlyConverter : JsonConverter<DateOnly>
{
    private readonly string serializationFormat;
    public DateOnlyConverter() : this(null) { }

    public DateOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
    }

    public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return DateOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
        => writer.WriteStringValue(value.ToString(serializationFormat));
}

public class TimeOnlyConverter : JsonConverter<TimeOnly>
{
    private readonly string serializationFormat;

    public TimeOnlyConverter() : this(null) { }

    public TimeOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
    }

    public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return TimeOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
        => writer.WriteStringValue(value.ToString(serializationFormat));
}

internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
{
    public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

    private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

    private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
    private string? _dateTimeFormat;
    private CultureInfo? _culture;

    public DateTimeStyles DateTimeStyles
    {
        get => _dateTimeStyles;
        set => _dateTimeStyles = value;
    }

    public string? DateTimeFormat
    {
        get => _dateTimeFormat ?? string.Empty;
        set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
    }

    public CultureInfo Culture
    {
        get => _culture ?? CultureInfo.CurrentCulture;
        set => _culture = value;
    }

    public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
    {
        string text;


        if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
            || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
        {
            value = value.ToUniversalTime();
        }

        text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

        writer.WriteStringValue(text);
    }

    public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        string? dateText = reader.GetString();
        
        if (string.IsNullOrEmpty(dateText) == false)
        {
            if (!string.IsNullOrEmpty(_dateTimeFormat))
            {
                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
            }
            else
            {
                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
            }
        }
        else
        {
            return default(DateTimeOffset);
        }
    }


    public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
}`);
        }
      }
      needNamespace() {
        return this._needNamespaces;
      }
    };
    exports.SystemTextJsonCSharpRenderer = SystemTextJsonCSharpRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Dart.js
var require_Dart = __commonJS({
  "node_modules/quicktype-core/dist/language/Dart.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DartRenderer = exports.DartTargetLanguage = exports.dartOptions = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    exports.dartOptions = {
      nullSafety: new RendererOptions_1.BooleanOption("null-safety", "Null Safety", true),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Types only", false),
      codersInClass: new RendererOptions_1.BooleanOption("coders-in-class", "Put encoder & decoder in Class", false),
      methodNamesWithMap: new RendererOptions_1.BooleanOption("from-map", "Use method names fromMap() & toMap()", false, "secondary"),
      requiredProperties: new RendererOptions_1.BooleanOption("required-props", "Make all properties required", false),
      finalProperties: new RendererOptions_1.BooleanOption("final-props", "Make all properties final", false),
      generateCopyWith: new RendererOptions_1.BooleanOption("copy-with", "Generate CopyWith method", false),
      useFreezed: new RendererOptions_1.BooleanOption("use-freezed", "Generate class definitions with @freezed compatibility", false, "secondary"),
      useHive: new RendererOptions_1.BooleanOption("use-hive", "Generate annotations for Hive type adapters", false, "secondary"),
      useJsonAnnotation: new RendererOptions_1.BooleanOption("use-json-annotation", "Generate annotations for json_serializable", false, "secondary"),
      partName: new RendererOptions_1.StringOption("part-name", "Use this name in `part` directive", "NAME", "", "secondary")
    };
    var DartTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Dart", ["dart"], "dart");
      }
      getOptions() {
        return [
          exports.dartOptions.nullSafety,
          exports.dartOptions.justTypes,
          exports.dartOptions.codersInClass,
          exports.dartOptions.methodNamesWithMap,
          exports.dartOptions.requiredProperties,
          exports.dartOptions.finalProperties,
          exports.dartOptions.generateCopyWith,
          exports.dartOptions.useFreezed,
          exports.dartOptions.useHive,
          exports.dartOptions.useJsonAnnotation,
          exports.dartOptions.partName
        ];
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date");
        mapping.set("date-time", "date-time");
        return mapping;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.dartOptions, untypedOptionValues);
        return new DartRenderer(this, renderContext, options);
      }
    };
    exports.DartTargetLanguage = DartTargetLanguage;
    var keywords = [
      "abstract",
      "do",
      "import",
      "super",
      "as",
      "dynamic",
      "in",
      "switch",
      "assert",
      "else",
      "interface",
      "sync*",
      "async",
      "enum",
      "is",
      "this",
      "async*",
      "export",
      "library",
      "throw",
      "await",
      "external",
      "mixin",
      "true",
      "break",
      "extends",
      "new",
      "try",
      "case",
      "factory",
      "null",
      "typedef",
      "catch",
      "false",
      "operator",
      "var",
      "class",
      "final",
      "part",
      "void",
      "const",
      "finally",
      "rethrow",
      "while",
      "continue",
      "for",
      "return",
      "with",
      "covariant",
      "get",
      "set",
      "yield",
      "default",
      "if",
      "static",
      "yield*",
      "deferred",
      "implements",
      "int",
      "double",
      "bool",
      "Map",
      "List",
      "String",
      "File",
      "fromJson",
      "toJson",
      "fromMap",
      "toMap"
    ];
    var typeNamingFunction = (0, Naming_1.funPrefixNamer)("types", (n) => dartNameStyle(true, false, n));
    var propertyNamingFunction = (0, Naming_1.funPrefixNamer)("properties", (n) => dartNameStyle(false, false, n));
    var enumCaseNamingFunction = (0, Naming_1.funPrefixNamer)("enum-cases", (n) => dartNameStyle(true, true, n));
    var stringEscape = (0, Strings_1.utf16ConcatMap)((0, Strings_1.escapeNonPrintableMapper)((cp) => (0, Strings_1.isPrintable)(cp) && cp !== 36, Strings_1.standardUnicodeHexEscape));
    function isStartCharacter(codePoint) {
      if (codePoint === 95)
        return false;
      return (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isLetter)(codePoint);
    }
    function isPartCharacter(codePoint) {
      return isStartCharacter(codePoint) || (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function dartNameStyle(startWithUpper, upperUnderscore, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const firstWordStyle = upperUnderscore ? Strings_1.allUpperWordStyle : startWithUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle;
      const restWordStyle = upperUnderscore ? Strings_1.allUpperWordStyle : Strings_1.firstUpperWordStyle;
      return (0, Strings_1.combineWords)(words, legalizeName, firstWordStyle, restWordStyle, firstWordStyle, restWordStyle, upperUnderscore ? "_" : "", isStartCharacter);
    }
    var DartRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._needEnumValues = false;
        this.classCounter = 0;
        this.classPropertyCounter = 0;
        this._topLevelDependents = /* @__PURE__ */ new Map();
        this._enumValues = /* @__PURE__ */ new Map();
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return typeNamingFunction;
      }
      namerForObjectProperty() {
        return propertyNamingFunction;
      }
      makeUnionMemberNamer() {
        return propertyNamingFunction;
      }
      makeEnumCaseNamer() {
        return enumCaseNamingFunction;
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      get toJson() {
        return `to${this._options.methodNamesWithMap ? "Map" : "Json"}`;
      }
      get fromJson() {
        return `from${this._options.methodNamesWithMap ? "Map" : "Json"}`;
      }
      makeTopLevelDependencyNames(_t, name) {
        const encoder = new Naming_1.DependencyName(propertyNamingFunction, name.order, (lookup) => `${lookup(name)}_${this.toJson}`);
        const decoder = new Naming_1.DependencyName(propertyNamingFunction, name.order, (lookup) => `${lookup(name)}_${this.fromJson}`);
        this._topLevelDependents.set(name, { encoder, decoder });
        return [encoder, decoder];
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(propertyNamingFunction, name.order, (lookup) => `get_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(propertyNamingFunction, name.order, (lookup) => `set_${lookup(name)}`);
        return [getterName, setterName];
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
      }
      makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof Type_1.EnumType))
          return [];
        const enumValue = new Naming_1.DependencyName(propertyNamingFunction, name.order, (lookup) => `${lookup(name)}_values`);
        this._enumValues.set(t, enumValue);
        return [enumValue];
      }
      emitFileHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        if (this._options.justTypes)
          return;
        if (!this._options.codersInClass) {
          this.emitLine("// To parse this JSON data, do");
          this.emitLine("//");
          this.forEachTopLevel("none", (_t, name) => {
            const { decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
            this.emitLine("//     final ", (0, Source_1.modifySource)(Strings_1.decapitalize, name), " = ", decoder, "(jsonString);");
          });
        }
        this.ensureBlankLine();
        if (this._options.requiredProperties) {
          this.emitLine("import 'package:meta/meta.dart';");
        }
        if (this._options.useFreezed) {
          this.emitLine("import 'package:freezed_annotation/freezed_annotation.dart';");
        }
        if (this._options.useHive) {
          this.emitLine("import 'package:hive/hive.dart';");
        }
        if (this._options.useJsonAnnotation && !this._options.useFreezed) {
          this.emitLine("import 'package:json_annotation/json_annotation.dart';");
        }
        this.emitLine("import 'dart:convert';");
        if (this._options.useFreezed || this._options.useHive || this._options.useJsonAnnotation) {
          this.ensureBlankLine();
          const optionNameIsEmpty = this._options.partName.length === 0;
          const name = (0, Source_1.modifySource)(Strings_1.snakeCase, optionNameIsEmpty ? [...this.topLevels.keys()][0] : this._options.partName);
          if (this._options.useFreezed) {
            this.emitLine("part '", name, ".freezed.dart';");
          }
          if (!this._options.justTypes) {
            this.emitLine("part '", name, ".g.dart';");
          }
        }
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: "///", beforeComment: "" });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      dartType(t, withIssues = false, forceNullable = false) {
        const nullable = forceNullable || this._options.nullSafety && t.isNullable && !this._options.requiredProperties;
        const withNullable = (s) => nullable ? [s, "?"] : s;
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "dynamic"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "dynamic"), (_boolType) => withNullable("bool"), (_integerType) => withNullable("int"), (_doubleType) => withNullable("double"), (_stringType) => withNullable("String"), (arrayType) => withNullable(["List<", this.dartType(arrayType.items, withIssues), ">"]), (classType) => withNullable(this.nameForNamedType(classType)), (mapType) => withNullable(["Map<String, ", this.dartType(mapType.values, withIssues), ">"]), (enumType) => withNullable(this.nameForNamedType(enumType)), (unionType) => {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (maybeNullable === null) {
            return "dynamic";
          }
          return withNullable(this.dartType(maybeNullable, withIssues));
        }, (transformedStringType) => {
          switch (transformedStringType.kind) {
            case "date-time":
            case "date":
              return withNullable("DateTime");
            default:
              return withNullable("String");
          }
        });
      }
      mapList(isNullable, itemType, list, mapper) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
          return [list, " == null ? [] : ", "List<", itemType, ">.from(", list, "!.map((x) => ", mapper, "))"];
        }
        return ["List<", itemType, ">.from(", list, ".map((x) => ", mapper, "))"];
      }
      mapMap(isNullable, valueType, map2, valueMapper) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
          return ["Map.from(", map2, "!).map((k, v) => MapEntry<String, ", valueType, ">(k, ", valueMapper, "))"];
        }
        return ["Map.from(", map2, ").map((k, v) => MapEntry<String, ", valueType, ">(k, ", valueMapper, "))"];
      }
      mapClass(isNullable, classType, dynamic) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
          return [
            dynamic,
            " == null ? null : ",
            this.nameForNamedType(classType),
            ".",
            this.fromJson,
            "(",
            dynamic,
            ")"
          ];
        }
        return [this.nameForNamedType(classType), ".", this.fromJson, "(", dynamic, ")"];
      }
      // FIXME: refactor this
      // If the first time is the unionType type, after nullableFromUnion conversion,
      // the isNullable property will become false, which is obviously wrong,
      // so add isNullable property
      // eslint-disable-next-line @typescript-eslint/default-param-last
      fromDynamicExpression(isNullable = false, t, ...dynamic) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => dynamic,
          (_nullType) => dynamic,
          // FIXME: check null
          // FIXME: check null
          (_boolType) => dynamic,
          (_integerType) => dynamic,
          (_doubleType) => [dynamic, this._options.nullSafety ? "?.toDouble()" : ".toDouble()"],
          (_stringType) => dynamic,
          (arrayType) => this.mapList(isNullable || arrayType.isNullable, this.dartType(arrayType.items), dynamic, this.fromDynamicExpression(arrayType.items.isNullable, arrayType.items, "x")),
          (classType) => this.mapClass(isNullable || classType.isNullable, classType, dynamic),
          (mapType) => this.mapMap(mapType.isNullable || isNullable, this.dartType(mapType.values), dynamic, this.fromDynamicExpression(mapType.values.isNullable, mapType.values, "v")),
          (enumType) => {
            return [
              (0, Support_1.defined)(this._enumValues.get(enumType)),
              ".map[",
              dynamic,
              this._options.nullSafety ? "]!" : "]"
            ];
          },
          (unionType) => {
            const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            if (maybeNullable === null) {
              return dynamic;
            }
            return this.fromDynamicExpression(unionType.isNullable, maybeNullable, dynamic);
          },
          (transformedStringType) => {
            switch (transformedStringType.kind) {
              case "date-time":
              case "date":
                if ((transformedStringType.isNullable || isNullable) && !this._options.requiredProperties && this._options.nullSafety) {
                  return [dynamic, " == null ? null : ", "DateTime.parse(", dynamic, ")"];
                }
                return ["DateTime.parse(", dynamic, ")"];
              default:
                return dynamic;
            }
          }
        );
      }
      // FIXME: refactor this
      // If the first time is the unionType type, after nullableFromUnion conversion,
      // the isNullable property will become false, which is obviously wrong,
      // so add isNullable property
      // eslint-disable-next-line @typescript-eslint/default-param-last
      toDynamicExpression(isNullable = false, t, ...dynamic) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => dynamic, (_nullType) => dynamic, (_boolType) => dynamic, (_integerType) => dynamic, (_doubleType) => dynamic, (_stringType) => dynamic, (arrayType) => this.mapList(arrayType.isNullable || isNullable, "dynamic", dynamic, this.toDynamicExpression(arrayType.items.isNullable, arrayType.items, "x")), (_classType) => {
          if (this._options.nullSafety && (_classType.isNullable || isNullable) && !this._options.requiredProperties) {
            return [dynamic, "?.", this.toJson, "()"];
          }
          return [dynamic, ".", this.toJson, "()"];
        }, (mapType) => this.mapMap(mapType.isNullable || isNullable, "dynamic", dynamic, this.toDynamicExpression(mapType.values.isNullable, mapType.values, "v")), (enumType) => {
          return [(0, Support_1.defined)(this._enumValues.get(enumType)), ".reverse[", dynamic, "]"];
        }, (unionType) => {
          const maybeNullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (maybeNullable === null) {
            return dynamic;
          }
          return this.toDynamicExpression(unionType.isNullable, maybeNullable, dynamic);
        }, (transformedStringType) => {
          switch (transformedStringType.kind) {
            case "date-time":
              if (this._options.nullSafety && !this._options.requiredProperties && (transformedStringType.isNullable || isNullable)) {
                return [dynamic, "?.toIso8601String()"];
              }
              return [dynamic, ".toIso8601String()"];
            case "date":
              if (this._options.nullSafety && !this._options.requiredProperties && (transformedStringType.isNullable || isNullable)) {
                return [
                  '"${',
                  dynamic,
                  "!.year.toString().padLeft(4, '0')",
                  "}-${",
                  dynamic,
                  "!.month.toString().padLeft(2, '0')}-${",
                  dynamic,
                  `!.day.toString().padLeft(2, '0')}"`
                ];
              }
              return [
                '"${',
                dynamic,
                ".year.toString().padLeft(4, '0')",
                "}-${",
                dynamic,
                ".month.toString().padLeft(2, '0')}-${",
                dynamic,
                `.day.toString().padLeft(2, '0')}"`
              ];
            default:
              return dynamic;
          }
        });
      }
      _emitEmptyConstructor(className) {
        this.emitLine(className, "();");
      }
      _emitConstructor(c, className) {
        this.emitLine(className, "({");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, _, prop) => {
            const required = this._options.requiredProperties || this._options.nullSafety && (!prop.type.isNullable || !prop.isOptional);
            this.emitLine(required ? "required " : "", "this.", name, ",");
          });
        });
        this.emitLine("});");
        this.ensureBlankLine();
      }
      _emitVariables(c) {
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const description = this.descriptionForClassProperty(c, jsonName);
          if (description !== void 0) {
            this.emitDescription(description);
          }
          if (this._options.useHive) {
            this.classPropertyCounter++;
            this.emitLine(`@HiveField(${this.classPropertyCounter})`);
          }
          if (this._options.useJsonAnnotation) {
            this.classPropertyCounter++;
            this.emitLine(`@JsonKey(name: "${jsonName}")`);
          }
          this.emitLine(this._options.finalProperties ? "final " : "", this.dartType(p.type, true), " ", name, ";");
        });
      }
      _emitCopyConstructor(c, className) {
        this.ensureBlankLine();
        this.emitLine(className, " copyWith({");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, _, _p) => {
            this.emitLine(this.dartType(_p.type, true, true), " ", name, ",");
          });
        });
        this.emitLine("}) => ");
        this.indent(() => {
          this.emitLine(className, "(");
          this.indent(() => {
            this.forEachClassProperty(c, "none", (name, _, _p) => {
              this.emitLine(name, ": ", name, " ?? ", "this.", name, ",");
            });
          });
          this.emitLine(");");
        });
      }
      _emitStringJsonEncoderDecoder(className) {
        this.ensureBlankLine();
        this.emitLine("factory ", className, ".from", this._options.methodNamesWithMap ? "Json" : "RawJson", "(String str) => ", className, ".", this.fromJson, "(json.decode(str));");
        this.ensureBlankLine();
        this.emitLine("String ", this._options.methodNamesWithMap ? "toJson() => " : "toRawJson() => ", "json.encode(", this.toJson, "());");
      }
      _emitMapEncoderDecoder(c, className) {
        this.ensureBlankLine();
        this.emitLine("factory ", className, ".", this.fromJson, "(Map<String, dynamic> json) => ", className, "(");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitLine(name, ": ", this.fromDynamicExpression(property.type.isNullable, property.type, 'json["', stringEscape(jsonName), '"]'), ",");
          });
        });
        this.emitLine(");");
        this.ensureBlankLine();
        this.emitLine("Map<String, dynamic> ", this.toJson, "() => {");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitLine('"', stringEscape(jsonName), '": ', this.toDynamicExpression(property.type.isNullable, property.type, name), ",");
          });
        });
        this.emitLine("};");
      }
      emitClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        if (this._options.useHive) {
          this.classCounter++;
          this.emitLine(`@HiveType(typeId: ${this.classCounter})`);
          this.classPropertyCounter = 0;
        }
        if (this._options.useJsonAnnotation) {
          this.emitLine("@JsonSerializable()");
        }
        this.emitBlock(["class ", className], () => {
          if (c.getProperties().size === 0) {
            this._emitEmptyConstructor(className);
          } else {
            this._emitVariables(c);
            this.ensureBlankLine();
            this._emitConstructor(c, className);
          }
          if (this._options.generateCopyWith) {
            this._emitCopyConstructor(c, className);
          }
          if (this._options.useJsonAnnotation) {
            this.ensureBlankLine();
            this.emitLine(
              // factory PublicAnswer.fromJson(Map<String, dynamic> json) => _$PublicAnswerFromJson(json);
              "factory ",
              className,
              ".fromJson(Map<String, dynamic> json) => ",
              "_$",
              className,
              "FromJson(json);"
            );
            this.ensureBlankLine();
            this.emitLine(
              // Map<String, dynamic> toJson() => _$PublicAnswerToJson(this);
              "Map<String, dynamic> toJson() => ",
              "_$",
              className,
              "ToJson(this);"
            );
          } else {
            if (this._options.justTypes)
              return;
            if (this._options.codersInClass) {
              this._emitStringJsonEncoderDecoder(className);
            }
            this._emitMapEncoderDecoder(c, className);
          }
        });
      }
      emitFreezedClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("@freezed");
        this.emitBlock(["class ", className, " with _$", className], () => {
          if (c.getProperties().size === 0) {
            this.emitLine("const factory ", className, "() = _", className, ";");
          } else {
            this.emitLine("const factory ", className, "({");
            this.indent(() => {
              this.forEachClassProperty(c, "none", (name, jsonName, prop) => {
                const description = this.descriptionForClassProperty(c, jsonName);
                if (description !== void 0) {
                  this.emitDescription(description);
                }
                const required = this._options.requiredProperties || this._options.nullSafety && (!prop.type.isNullable || !prop.isOptional);
                if (this._options.useJsonAnnotation) {
                  this.classPropertyCounter++;
                  this.emitLine(`@JsonKey(name: "${jsonName}")`);
                }
                this.emitLine(required ? "required " : "", this.dartType(prop.type, true), " ", name, ",");
              });
            });
            this.emitLine("}) = _", className, ";");
          }
          if (this._options.justTypes)
            return;
          this.ensureBlankLine();
          this.emitLine(
            // factory PublicAnswer.fromJson(Map<String, dynamic> json) => _$PublicAnswerFromJson(json);
            "factory ",
            className,
            ".fromJson(Map<String, dynamic> json) => ",
            "_$",
            className,
            "FromJson(json);"
          );
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("enum ", enumName, " {");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName, pos) => {
            const comma = pos === "first" || pos === "middle" ? "," : [];
            if (this._options.useJsonAnnotation) {
              this.emitLine('@JsonValue("', stringEscape(jsonName), '")');
            }
            this.emitLine(name, comma);
          });
        });
        this.emitLine("}");
        if (this._options.justTypes)
          return;
        this.ensureBlankLine();
        this.emitLine("final ", (0, Support_1.defined)(this._enumValues.get(e)), " = EnumValues({");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName, pos) => {
            const comma = pos === "first" || pos === "middle" ? "," : [];
            this.emitLine('"', stringEscape(jsonName), '": ', enumName, ".", name, comma);
          });
        });
        this.emitLine("});");
        this._needEnumValues = true;
      }
      emitEnumValues() {
        this.ensureBlankLine();
        this.emitMultiline(`class EnumValues<T> {
    Map<String, T> map;
    late Map<T, String> reverseMap;

    EnumValues(this.map);

    Map<T, String> get reverse {
        reverseMap = map.map((k, v) => MapEntry(v, k));
        return reverseMap;
    }
}`);
      }
      _emitTopLvlEncoderDecoder() {
        this.forEachTopLevel("leading-and-interposing", (t, name) => {
          const { encoder, decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
          this.emitLine(this.dartType(t), " ", decoder, "(String str) => ", this.fromDynamicExpression(t.isNullable, t, "json.decode(str)"), ";");
          this.ensureBlankLine();
          this.emitLine("String ", encoder, "(", this.dartType(t), " data) => json.encode(", this.toDynamicExpression(t.isNullable, t, "data"), ");");
        });
      }
      emitSourceStructure() {
        this.emitFileHeader();
        if (!this._options.justTypes && !this._options.codersInClass) {
          this._emitTopLvlEncoderDecoder();
        }
        this.forEachNamedType("leading-and-interposing", (c, n) => this._options.useFreezed ? this.emitFreezedClassDefinition(c, n) : this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (_e, _n) => {
        });
        if (this._needEnumValues) {
          this.emitEnumValues();
        }
      }
    };
    exports.DartRenderer = DartRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Elixir.js
var require_Elixir = __commonJS({
  "node_modules/quicktype-core/dist/language/Elixir.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ElixirRenderer = exports.ElixirTargetLanguage = exports.elixirOptions = void 0;
    var unicode = __importStar(require_main());
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Strings_1 = require_Strings();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var forbiddenModuleNames = [
      "Access",
      "Agent",
      "Any",
      "Application",
      "ArgumentError",
      "ArithmeticError",
      "Atom",
      "BadArityError",
      "BadBooleanError",
      "BadFunctionError",
      "BadMapError",
      "BadStructError",
      "Base",
      "Behaviour",
      "Bitwise",
      "Calendar",
      "CaseClauseError",
      "Code",
      "Collectable",
      "CondClauseError",
      "Config",
      "Date",
      "DateTime",
      "Dict",
      "DynamicSupervisor",
      "Enum",
      "ErlangError",
      "Exception",
      "File",
      "Float",
      "Function",
      "FunctionClauseError",
      "GenEvent",
      "GenServer",
      "HashDict",
      "HashSet",
      "IO",
      "Inspect",
      "Integer",
      "Kernel",
      "KeyError",
      "Keyword",
      "List",
      "Macro",
      "Map",
      "MapSet",
      "MatchError",
      "Module",
      "Node",
      "OptionParser",
      "Path",
      "Port",
      "Process",
      "Protocol",
      "Range",
      "Record",
      "Regex",
      "Registry",
      "RuntimeError",
      "Set",
      "Stream",
      "String",
      "StringIO",
      "Supervisor",
      "SyntaxError",
      "System",
      "SystemLimitError",
      "Task",
      "Time",
      "TokenMissingError",
      "Tuple",
      "URI",
      "UndefinedFunctionError",
      "UnicodeConversionError",
      "Version",
      "WithClauseError"
    ];
    var reservedWords = [
      "def",
      "defmodule",
      "use",
      "import",
      "alias",
      "true",
      "false",
      "nil",
      "when",
      "and",
      "or",
      "not",
      "in",
      "fn",
      "do",
      "end",
      "catch",
      "rescue",
      "after",
      "else"
    ];
    function unicodeEscape(codePoint) {
      return `\\u{${(0, Strings_1.intToHex)(codePoint, 0)}}`;
    }
    function capitalizeFirstLetter(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    var stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
    function escapeDoubleQuotes(str) {
      return str.replace(/"/g, '\\"');
    }
    function escapeNewLines(str) {
      return str.replace(/\n/g, "\\n");
    }
    exports.elixirOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      namespace: new RendererOptions_1.StringOption("namespace", "Specify a module namespace", "NAME", "")
    };
    var ElixirTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Elixir", ["elixir"], "ex");
      }
      getOptions() {
        return [exports.elixirOptions.justTypes, exports.elixirOptions.namespace];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get defaultIndentation() {
        return "  ";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new ElixirRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.elixirOptions, untypedOptionValues));
      }
    };
    exports.ElixirTargetLanguage = ElixirTargetLanguage;
    var isStartCharacter = Strings_1.isLetterOrUnderscore;
    function isPartCharacter(utf16Unit) {
      const category = unicode.getCategory(utf16Unit);
      return ["Nd", "Pc", "Mn", "Mc"].includes(category) || isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function simpleNameStyle(original, uppercase) {
      if (/^[0-9]+$/.test(original)) {
        original = `${original}N`;
      }
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    function memberNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, "_", isStartCharacter);
    }
    var ElixirRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      get commentLineStart() {
        return "# ";
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        return "class" === t.kind;
      }
      forbiddenNamesForGlobalNamespace() {
        return [...forbiddenModuleNames, ...reservedWords.map((word) => capitalizeFirstLetter(word))];
      }
      forbiddenForObjectProperties(_c, _classNamed) {
        return { names: reservedWords, includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return new Naming_1.Namer("types", (n) => simpleNameStyle(n, true), []);
      }
      namerForObjectProperty() {
        return new Naming_1.Namer("properties", memberNameStyle, []);
      }
      makeUnionMemberNamer() {
        return new Naming_1.Namer("properties", memberNameStyle, []);
      }
      makeEnumCaseNamer() {
        return new Naming_1.Namer("enum-cases", (n) => simpleNameStyle(n, true), []);
      }
      nameForNamedTypeWithNamespace(t) {
        if (this._options.namespace) {
          return [this._options.namespace, ".", this.nameForNamedType(t)];
        } else {
          return [this.nameForNamedType(t)];
        }
      }
      nameWithNamespace(n) {
        if (this._options.namespace) {
          return [this._options.namespace, ".", n];
        } else {
          return [n];
        }
      }
      elixirType(t, isOptional = false) {
        const optional = isOptional ? " | nil" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => ["any()", optional], (_nullType) => ["nil"], (_boolType) => ["boolean()", optional], (_integerType) => ["integer()", optional], (_doubleType) => ["float()", optional], (_stringType) => ["String.t()", optional], (arrayType) => ["[", this.elixirType(arrayType.items), "]", optional], (classType) => [this.nameForNamedTypeWithNamespace(classType), ".t()", optional], (mapType) => ["%{String.t() => ", this.elixirType(mapType.values), "}", optional], (enumType) => [this.nameForNamedTypeWithNamespace(enumType), ".t()", optional], (unionType) => {
          const children = [...unionType.getChildren()].map((ut) => this.elixirType(ut));
          return [
            children.flatMap((element, index) => index === children.length - 1 ? element : [element, " | "]),
            optional
          ];
        });
      }
      patternMatchClauseDecode(t, attributeName, suffix = "") {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => ["def decode_", attributeName, suffix, "(value) when is_nil(value), do: value"], (_boolType) => ["def decode_", attributeName, suffix, "(value) when is_boolean(value), do: value"], (_integerType) => ["def decode_", attributeName, suffix, "(value) when is_integer(value), do: value"], (_doubleType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_float(value), do: value\n",
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_integer(value), do: value"
        ], (_stringType) => ["def decode_", attributeName, suffix, "(value) when is_binary(value), do: value"], (_arrayType) => ["def decode_", attributeName, suffix, "(value) when is_list(value), do: value"], (classType) => {
          const requiredAttributeArgs = [];
          this.forEachClassProperty(classType, "none", (_name, jsonName, p) => {
            if (!p.isOptional) {
              requiredAttributeArgs.push(['"', jsonName, '" => _,']);
            }
          });
          return [
            "def decode_",
            attributeName,
            suffix,
            "(%{",
            requiredAttributeArgs,
            "} = value), do: ",
            this.nameForNamedTypeWithNamespace(classType),
            ".from_map(value)"
          ];
        }, (_mapType) => ["def decode_", attributeName, suffix, "(value) when is_map(value), do: value"], (enumType) => [
          "def decode_",
          attributeName,
          suffix,
          "(value) when is_binary(value)",
          ", do: ",
          this.nameForNamedTypeWithNamespace(enumType),
          ".decode(value)"
        ], (_unionType) => []);
      }
      patternMatchClauseEncode(t, attributeName, suffix = "") {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => ["def encode_", attributeName, suffix, "(value) when is_nil(value), do: value"], (_boolType) => ["def encode_", attributeName, suffix, "(value) when is_boolean(value), do: value"], (_integerType) => ["def encode_", attributeName, suffix, "(value) when is_integer(value), do: value"], (_doubleType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_float(value), do: value\n",
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_integer(value), do: value"
        ], (_stringType) => ["def encode_", attributeName, suffix, "(value) when is_binary(value), do: value"], (_arrayType) => ["def encode_", attributeName, suffix, "(value) when is_list(value), do: value"], (classType) => {
          const requiredAttributeArgs = [];
          this.forEachClassProperty(classType, "none", (_name, jsonName, p) => {
            if (!p.isOptional) {
              requiredAttributeArgs.push(['"', jsonName, '" => _,']);
            }
          });
          return [
            "def encode_",
            attributeName,
            suffix,
            "(%",
            this.nameForNamedTypeWithNamespace(classType),
            "{} = value), do: ",
            this.nameForNamedTypeWithNamespace(classType),
            ".to_map(value)"
          ];
        }, (_mapType) => ["def encode_", attributeName, suffix, "(value) when is_map(value), do: value"], (enumType) => [
          "def encode_",
          attributeName,
          suffix,
          "(value) when is_atom(value)",
          ", do: ",
          this.nameForNamedTypeWithNamespace(enumType),
          ".encode(value)"
        ], (_unionType) => []);
      }
      sortAndFilterPatternMatchTypes(types) {
        return types.filter((type) => !(type instanceof Type_1.UnionType)).sort((a, b) => {
          if (a instanceof Type_1.ClassType && !(b instanceof Type_1.ClassType)) {
            return -1;
          } else if (b instanceof Type_1.ClassType && !(a instanceof Type_1.ClassType)) {
            return 1;
          } else if (a.kind === "bool" && b.kind !== "bool") {
            return -1;
          } else if (b.kind === "bool" && a.kind !== "bool") {
            return 1;
          } else if (a instanceof Type_1.EnumType && !(b instanceof Type_1.EnumType)) {
            return -1;
          } else if (b instanceof Type_1.EnumType && !(a instanceof Type_1.EnumType)) {
            return 1;
          } else if (a.isPrimitive() && !b.isPrimitive()) {
            return -1;
          } else if (b.isPrimitive() && !a.isPrimitive()) {
            return 1;
          } else {
            return 0;
          }
        });
      }
      emitPatternMatches(types, name, parentName, suffix = "", optional = false) {
        this.ensureBlankLine();
        let typesToMatch = this.sortAndFilterPatternMatchTypes(types);
        if (typesToMatch.length < 2) {
          return;
        }
        if (typesToMatch.find((type) => type.kind === "double")) {
          typesToMatch = typesToMatch.filter((type) => type.kind !== "integer");
        }
        typesToMatch.forEach((type) => {
          this.emitLine(this.patternMatchClauseDecode(type, name, suffix));
        });
        if (optional && !typesToMatch.find((type) => type.kind === "null")) {
          this.emitLine("def decode_", name, suffix, "(value) when is_nil(value), do: value");
        }
        this.emitLine("def decode_", name, suffix, '(_), do: {:error, "Unexpected type when decoding ', parentName, ".", name, '"}');
        this.ensureBlankLine();
        typesToMatch.forEach((type) => {
          this.emitLine(this.patternMatchClauseEncode(type, name, suffix));
        });
        if (optional && !typesToMatch.find((type) => type.kind === "null")) {
          this.emitLine("def encode_", name, suffix, "(value) when is_nil(value), do: value");
        }
        this.emitLine("def encode_", name, suffix, '(_), do: {:error, "Unexpected type when encoding ', parentName, ".", name, '"}');
        this.ensureBlankLine();
      }
      nameOfTransformFunction(t, name, encode = false, prefix = "") {
        let mode = "decode";
        if (encode) {
          mode = "encode";
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => [], (_boolType) => [], (_integerType) => [], (_doubleType) => [], (_stringType) => [], (_arrayType) => [], (classType) => [this.nameForNamedTypeWithNamespace(classType), `.${encode ? "to" : "from"}_map`], (_mapType) => [], (enumType) => {
          return [this.nameForNamedTypeWithNamespace(enumType), `.${mode}`];
        }, (_unionType) => {
          return [`${mode}_`, name, prefix];
        });
      }
      fromDynamic(t, jsonName, name, optional = false) {
        const primitive = ['m["', jsonName, '"]'];
        return (0, TypeUtils_1.matchType)(t, (_anyType) => primitive, (_nullType) => primitive, (_boolType) => primitive, (_integerType) => primitive, (_doubleType) => primitive, (_stringType) => primitive, (arrayType) => {
          const arrayElement = arrayType.items;
          if (arrayElement instanceof Type_1.ArrayType) {
            return primitive;
          } else if (arrayElement.isPrimitive()) {
            return primitive;
          } else if (arrayElement instanceof Type_1.MapType) {
            return primitive;
          } else {
            if (optional) {
              return [
                "m",
                '["',
                jsonName,
                '"] && Enum.map(m["',
                jsonName,
                '"], &',
                this.nameOfTransformFunction(arrayElement, name, false, "_element"),
                "/1)"
              ];
            } else {
              return [
                'Enum.map(m["',
                jsonName,
                '"], &',
                this.nameOfTransformFunction(arrayElement, name, false, "_element"),
                "/1)"
              ];
            }
          }
        }, (classType) => [
          optional ? [primitive, " && "] : "",
          this.nameForNamedTypeWithNamespace(classType),
          ".from_map(",
          primitive,
          ")"
        ], (mapType) => {
          const mapValueTypes = [...mapType.values.getChildren()];
          const mapValueTypesNotPrimitive = mapValueTypes.filter((type) => !(type instanceof Type_1.PrimitiveType));
          if (mapValueTypesNotPrimitive.length === 0) {
            return [primitive];
          } else {
            if (mapType.values.kind === "union") {
              return [
                'm["',
                jsonName,
                '"]\n|> Map.new(fn {key, value} -> {key, ',
                this.nameOfTransformFunction(mapType.values, jsonName, false),
                "_value(value)} end)"
              ];
            } else if (mapType.values instanceof Type_1.EnumType || mapType.values instanceof Type_1.ClassType) {
              return [
                'm["',
                jsonName,
                '"]\n|> Map.new(fn {key, value} -> {key, ',
                this.nameOfTransformFunction(mapType.values, jsonName, false),
                "(value)} end)"
              ];
            }
            return [primitive];
          }
        }, (enumType) => {
          return [
            optional ? [primitive, " && "] : "",
            this.nameOfTransformFunction(enumType, name),
            "(",
            primitive,
            ")"
          ];
        }, (unionType) => {
          const unionTypes = [...unionType.getChildren()];
          const unionPrimitiveTypes = unionTypes.filter((type) => type.isPrimitive());
          if (unionTypes.length === unionPrimitiveTypes.length) {
            return ['m["', jsonName, '"]'];
          }
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (nullable instanceof Type_1.ClassType) {
              return this.fromDynamic(nullable, jsonName, name, true);
            }
            const nullableTypes = [...nullable.getChildren()];
            if (nullableTypes.length < 2) {
              return this.fromDynamic(nullable, jsonName, name, true);
            }
            return ['m["', jsonName, '"] && decode_', name, '(m["', jsonName, '"])'];
          }
          return ["decode_", name, '(m["', jsonName, '"])'];
        });
      }
      toDynamic(t, e, optional = false) {
        const expression = ["struct.", e];
        return (0, TypeUtils_1.matchType)(t, (_anyType) => expression, (_nullType) => expression, (_boolType) => expression, (_integerType) => expression, (_doubleType) => expression, (_stringType) => expression, (arrayType) => {
          const arrayElement = arrayType.items;
          if (arrayElement instanceof Type_1.ArrayType) {
            return expression;
          }
          if (arrayElement.isPrimitive()) {
            return expression;
          } else if (arrayElement instanceof Type_1.MapType) {
            return expression;
          } else {
            if (arrayElement.kind === "array") {
              return expression;
            } else {
              if (optional) {
                return [
                  "struct.",
                  e,
                  " && Enum.map(struct.",
                  e,
                  ", &",
                  this.nameOfTransformFunction(arrayElement, e, true, "_element"),
                  "/1)"
                ];
              } else {
                return [
                  "struct.",
                  e,
                  " && Enum.map(struct.",
                  e,
                  ", &",
                  this.nameOfTransformFunction(arrayElement, e, true, "_element"),
                  "/1)"
                ];
              }
            }
          }
        }, (classType) => [
          optional ? ["struct.", e, " && "] : "",
          this.nameForNamedTypeWithNamespace(classType),
          ".to_map(",
          "struct.",
          e,
          ")"
        ], (mapType) => {
          const mapValueTypes = [...mapType.values.getChildren()];
          const mapValueTypesNotPrimitive = mapValueTypes.filter((type) => !(type instanceof Type_1.PrimitiveType));
          if (mapValueTypesNotPrimitive.length === 0) {
            return [expression];
          } else {
            if (mapType.values.kind === "union") {
              return [
                "struct.",
                e,
                "\n|> Map.new(fn {key, value} -> {key, ",
                this.nameOfTransformFunction(mapType.values, e, true),
                "_value(value)} end)"
              ];
            } else if (mapType.values instanceof Type_1.EnumType || mapType.values instanceof Type_1.ClassType) {
              return [
                "struct.",
                e,
                "\n|> Map.new(fn {key, value} -> {key, ",
                this.nameOfTransformFunction(mapType.values, e, true),
                "(value)} end)"
              ];
            }
            return [expression];
          }
        }, (enumType) => {
          return [
            optional ? ["struct.", e, " && "] : "",
            this.nameForNamedTypeWithNamespace(enumType),
            ".encode(struct.",
            e,
            ")"
          ];
        }, (unionType) => {
          const unionTypes = [...unionType.getChildren()];
          const unionPrimitiveTypes = unionTypes.filter((type) => type.isPrimitive());
          if (unionTypes.length === unionPrimitiveTypes.length) {
            return ["struct.", e];
          }
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (nullable instanceof Type_1.ClassType) {
              return this.toDynamic(nullable, e, true);
            }
            const nullableTypes = [...nullable.getChildren()];
            if (nullableTypes.length < 2) {
              return this.toDynamic(nullable, e, true);
            }
            return ["struct.", e, " && encode_", e, "(struct.", e, ")"];
          }
          return ["encode_", e, "(struct.", e, ")"];
        });
      }
      emitBlock(source, emit) {
        this.emitLine(source);
        this.indent(emit);
        this.emitLine("end");
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
          firstLineStart: '@moduledoc """\n',
          lineStart: "",
          afterComment: '"""'
        });
      }
      emitModule(c, moduleName) {
        this.emitBlock(["defmodule ", this.nameWithNamespace(moduleName), " do"], () => {
          var _a;
          const structDescription = (_a = this.descriptionForType(c)) !== null && _a !== void 0 ? _a : [];
          const attributeDescriptions = [];
          this.forEachClassProperty(c, "none", (name, jsonName, _p) => {
            const attributeDescription = this.descriptionForClassProperty(c, jsonName);
            if (attributeDescription) {
              attributeDescriptions.push(["- `:", name, "` - ", attributeDescription]);
            }
          });
          if (structDescription.length || attributeDescriptions.length) {
            this.emitDescription([...structDescription, ...attributeDescriptions]);
            this.ensureBlankLine();
          }
          const requiredAttributes = [];
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            if (!p.isOptional) {
              if (requiredAttributes.length === 0) {
                requiredAttributes.push([":", name]);
              } else {
                requiredAttributes.push([", :", name]);
              }
            }
          });
          if (requiredAttributes.length) {
            this.emitLine(["@enforce_keys [", requiredAttributes, "]"]);
          }
          const attributeNames = [];
          this.forEachClassProperty(c, "none", (name, _jsonName, _p) => {
            if (attributeNames.length === 0) {
              attributeNames.push([":", name]);
            } else {
              attributeNames.push([", :", name]);
            }
          });
          this.emitLine(["defstruct [", attributeNames, "]"]);
          this.ensureBlankLine();
          const typeDefinitionTable = [[["@type "], ["t :: %__MODULE__{"]]];
          let count = c.getProperties().size;
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            const last = --count === 0;
            const attributeRow = [
              [],
              ["  ", name, ": ", this.elixirType(p.type), p.isOptional ? " | nil" : "", last ? "" : ","]
            ];
            typeDefinitionTable.push(attributeRow);
          });
          typeDefinitionTable.push([[], ["}"]]);
          this.emitTable(typeDefinitionTable);
          if (this._options.justTypes) {
            return;
          }
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            if (p.type.kind === "union") {
              const unionTypes = [...p.type.getChildren()];
              const unionPrimitiveTypes = unionTypes.filter((type) => type.isPrimitive());
              if (unionTypes.length === unionPrimitiveTypes.length) {
                return;
              }
              const unionTypesNonNull = unionTypes.filter((type) => type.kind !== "null");
              if (unionTypesNonNull.length === 1) {
                let suffix = "";
                let itemTypes = [];
                if (unionTypesNonNull[0] instanceof Type_1.ArrayType) {
                  suffix = "_element";
                  itemTypes = [...unionTypesNonNull[0].getChildren()];
                } else if (unionTypesNonNull[0] instanceof Type_1.MapType) {
                  suffix = "_value";
                  itemTypes = [...unionTypesNonNull[0].getChildren()];
                }
                if (itemTypes.length === 1 && itemTypes[0] instanceof Type_1.UnionType) {
                  itemTypes = [...itemTypes[0].getChildren()];
                }
                this.emitPatternMatches(itemTypes, name, this.nameForNamedTypeWithNamespace(c), suffix, p.isOptional);
              } else {
                this.emitPatternMatches(unionTypes, name, this.nameForNamedTypeWithNamespace(c), "", p.isOptional);
              }
            } else if (p.type.kind === "array") {
              const arrayType = p.type;
              if (arrayType.items instanceof Type_1.UnionType) {
                const unionType = arrayType.items;
                const typesInUnion = [...unionType.getChildren()];
                this.emitPatternMatches(typesInUnion, name, this.nameForNamedTypeWithNamespace(c), "_element");
              }
            } else if (p.type.kind === "map") {
              const mapType = p.type;
              if (mapType.values instanceof Type_1.UnionType) {
                const unionType = mapType.values;
                const typesInUnion = [...unionType.getChildren()];
                this.emitPatternMatches(typesInUnion, name, this.nameForNamedTypeWithNamespace(c), "_value");
              }
            }
          });
          let propCount = 0;
          this.forEachClassProperty(c, "none", (_name, _jsonName, _p) => {
            propCount++;
          });
          const isEmpty2 = propCount ? false : true;
          this.ensureBlankLine();
          this.emitBlock([`def from_map(${isEmpty2 ? "_" : ""}m) do`], () => {
            this.emitLine("%", this.nameWithNamespace(moduleName), "{");
            this.indent(() => {
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                jsonName = escapeDoubleQuotes(jsonName);
                jsonName = escapeNewLines(jsonName);
                const expression = this.fromDynamic(p.type, jsonName, name, p.isOptional);
                this.emitLine(name, ": ", expression, ",");
              });
            });
            this.emitLine("}");
          });
          this.ensureBlankLine();
          this.emitBlock("def from_json(json) do", () => {
            this.emitMultiline(`json
        |> Jason.decode!()
        |> from_map()`);
          });
          this.ensureBlankLine();
          this.emitBlock([`def to_map(${isEmpty2 ? "_" : ""}struct) do`], () => {
            this.emitLine("%{");
            this.indent(() => {
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const expression = this.toDynamic(p.type, name, p.isOptional);
                this.emitLine([[`"${stringEscape(jsonName)}"`], [" => ", expression, ","]]);
              });
            });
            this.emitLine("}");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_json(struct) do", () => {
            this.emitMultiline(`struct
        |> to_map()
        |> Jason.encode!()`);
          });
        });
      }
      isValidAtom(str) {
        function isLetter(char) {
          return /^[A-Za-z_]$/.test(char);
        }
        function isLetterOrDigit(char) {
          return /^[A-Za-z0-9_]$/.test(char);
        }
        if (str.length === 0) {
          return false;
        }
        const firstChar = str[0];
        if (!isLetter(firstChar)) {
          return false;
        }
        for (let i = 1; i < str.length; i++) {
          const char = str[i];
          if (!isLetterOrDigit(char) && char !== "@" && !(i === str.length - 1 && (char === "!" || char === "?"))) {
            return false;
          }
        }
        return true;
      }
      emitEnum(e, enumName) {
        this.emitBlock(["defmodule ", this.nameWithNamespace(enumName), " do"], () => {
          this.emitDescription(this.descriptionForType(e));
          this.emitLine("@valid_enum_members [");
          this.indent(() => {
            this.forEachEnumCase(e, "none", (_name, json) => {
              if (this.isValidAtom(json)) {
                this.emitLine(":", json, ",");
              } else {
                this.emitLine(":", `"${json}"`, ",");
              }
            });
          });
          this.emitLine("]");
          this.ensureBlankLine();
          this.emitMultiline(`def valid_atom?(value), do: value in @valid_enum_members

def valid_atom_string?(value) do
    try do
        atom = String.to_existing_atom(value)
        atom in @valid_enum_members
    rescue
        ArgumentError -> false
    end
end

def encode(value) do
    if valid_atom?(value) do
        Atom.to_string(value)
    else
        {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
end

def decode(value) do
    if valid_atom_string?(value) do
        String.to_existing_atom(value)
    else
        {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
end

def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
end

def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
end`);
        });
      }
      emitUnion(_u, _unionName) {
        return;
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitMultiline(`# This file was autogenerated using quicktype https://github.com/quicktype/quicktype
#
# Add Jason to your mix.exs`);
          this.forEachTopLevel("none", (_topLevel, name) => {
            this.emitLine("#");
            this.emitLine("# Decode a JSON string: ", this.nameWithNamespace(name), ".from_json(data)");
            this.emitLine("# Encode into a JSON string: ", this.nameWithNamespace(name), ".to_json(struct)");
          });
        }
        this.ensureBlankLine();
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitModule(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
        if (!this._options.justTypes) {
          this.forEachTopLevel("leading-and-interposing", (topLevel, name) => {
            const isTopLevelArray = "array" === topLevel.kind;
            this.emitBlock(["defmodule ", this.nameWithNamespace(name), " do"], () => {
              var _a;
              const description = (_a = this.descriptionForType(topLevel)) !== null && _a !== void 0 ? _a : [];
              if (description.length) {
                this.emitDescription([...description]);
                this.ensureBlankLine();
              }
              if (isTopLevelArray) {
                const arrayElement = topLevel.items;
                let isUnion = false;
                if (arrayElement instanceof Type_1.UnionType) {
                  this.emitPatternMatches([...arrayElement.getChildren()], "element", name);
                  isUnion = true;
                }
                this.emitBlock("def from_json(json) do", () => {
                  this.emitLine("json");
                  this.emitLine("|> Jason.decode!()");
                  this.emitLine("|> Enum.map(&", isUnion ? ["decode_element/1)"] : [this.nameWithNamespace(name), "Element.from_map/1)"]);
                });
                this.ensureBlankLine();
                this.emitBlock("def to_json(list) do", () => {
                  this.emitLine("Enum.map(list, &", isUnion ? ["encode_element/1)"] : [this.nameWithNamespace(name), "Element.to_map/1)"]);
                  this.emitLine("|> Jason.encode!()");
                });
              } else {
                this.emitBlock("def from_json(json) do", () => {
                  this.emitLine("Jason.decode!(json)");
                });
                this.ensureBlankLine();
                this.emitBlock("def to_json(data) do", () => {
                  this.emitLine("Jason.encode!(data)");
                });
              }
            });
          }, (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        }
      }
    };
    exports.ElixirRenderer = ElixirRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Elm.js
var require_Elm = __commonJS({
  "node_modules/quicktype-core/dist/language/Elm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ElmRenderer = exports.ElmTargetLanguage = exports.elmOptions = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    exports.elmOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      useList: new RendererOptions_1.EnumOption("array-type", "Use Array or List", [
        ["array", false],
        ["list", true]
      ]),
      // FIXME: Do this via a configurable named eventually.
      moduleName: new RendererOptions_1.StringOption("module", "Generated module name", "NAME", "QuickType")
    };
    var ElmTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Elm", ["elm"], "elm");
      }
      getOptions() {
        return [exports.elmOptions.justTypes, exports.elmOptions.moduleName, exports.elmOptions.useList];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new ElmRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.elmOptions, untypedOptionValues));
      }
    };
    exports.ElmTargetLanguage = ElmTargetLanguage;
    var forbiddenNames = [
      "if",
      "then",
      "else",
      "case",
      "of",
      "let",
      "in",
      "infix",
      "type",
      "module",
      "where",
      "import",
      "exposing",
      "as",
      "port",
      "int",
      "float",
      "bool",
      "string",
      "Jenc",
      "Jdec",
      "Jpipe",
      "always",
      "identity",
      "Array",
      "List",
      "Dict",
      "Maybe",
      "map",
      "toList",
      "makeArrayEncoder",
      "makeDictEncoder",
      "makeNullableEncoder",
      "Int",
      "True",
      "False",
      "String",
      "Float"
    ];
    var legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    function elmNameStyle(original, upper) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", Strings_1.isLetterOrUnderscore);
    }
    var upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (n) => elmNameStyle(n, true));
    var lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (n) => elmNameStyle(n, false));
    function requiredOrOptional(p) {
      function optional(fallback) {
        return { reqOrOpt: "Jpipe.optional", fallback };
      }
      const t = p.type;
      if (p.isOptional || t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) !== null) {
        return optional(" Nothing");
      }
      if (t.kind === "null") {
        return optional(" ()");
      }
      return { reqOrOpt: "Jpipe.required", fallback: "" };
    }
    var ElmRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._topLevelDependents = /* @__PURE__ */ new Map();
        this._namedTypeDependents = /* @__PURE__ */ new Map();
      }
      forbiddenNamesForGlobalNamespace() {
        return forbiddenNames;
      }
      makeTopLevelDependencyNames(t, topLevelName) {
        const encoder = new Naming_1.DependencyName(lowerNamingFunction, topLevelName.order, (lookup) => `${lookup(topLevelName)}_to_string`);
        let decoder = void 0;
        if (this.namedTypeToNameForTopLevel(t) === void 0) {
          decoder = new Naming_1.DependencyName(lowerNamingFunction, topLevelName.order, (lookup) => lookup(topLevelName));
        }
        this._topLevelDependents.set(topLevelName, { encoder, decoder });
        if (decoder !== void 0) {
          return [encoder, decoder];
        }
        return [encoder];
      }
      makeNamedTypeNamer() {
        return upperNamingFunction;
      }
      makeNamedTypeDependencyNames(_, typeName) {
        const encoder = new Naming_1.DependencyName(lowerNamingFunction, typeName.order, (lookup) => `encode_${lookup(typeName)}`);
        const decoder = new Naming_1.DependencyName(lowerNamingFunction, typeName.order, (lookup) => lookup(typeName));
        this._namedTypeDependents.set(typeName, { encoder, decoder });
        return [encoder, decoder];
      }
      namerForObjectProperty() {
        return lowerNamingFunction;
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      makeUnionMemberNamer() {
        return upperNamingFunction;
      }
      get unionMembersInGlobalNamespace() {
        return true;
      }
      makeEnumCaseNamer() {
        return upperNamingFunction;
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      proposeUnionMemberName(u, unionName, fieldType, lookup) {
        const fieldName = super.proposeUnionMemberName(u, unionName, fieldType, lookup);
        return `${fieldName}_in_${lookup(unionName)}`;
      }
      get commentLineStart() {
        return "-- ";
      }
      emitDescriptionBlock(lines) {
        if (lines.length === 1) {
          this.emitComments([{ customLines: lines, lineStart: "{-| ", lineEnd: " -}" }]);
        } else {
          this.emitCommentLines(lines, { firstLineStart: "{-| ", lineStart: "", afterComment: "-}" });
        }
      }
      get arrayType() {
        return this._options.useList ? "List" : "Array";
      }
      elmType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)((0, Source_1.annotated)(Annotation_1.anyTypeIssueAnnotation, "Jdec.Value")), (_nullType) => (0, Source_1.singleWord)((0, Source_1.annotated)(Annotation_1.nullTypeIssueAnnotation, "()")), (_boolType) => (0, Source_1.singleWord)("Bool"), (_integerType) => (0, Source_1.singleWord)("Int"), (_doubleType) => (0, Source_1.singleWord)("Float"), (_stringType) => (0, Source_1.singleWord)("String"), (arrayType) => (0, Source_1.multiWord)(" ", this.arrayType, (0, Source_1.parenIfNeeded)(this.elmType(arrayType.items))), (classType) => (0, Source_1.singleWord)(this.nameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "Dict String", (0, Source_1.parenIfNeeded)(this.elmType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.nameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableType = this.elmType(nullable);
            if (noOptional)
              return nullableType;
            return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(nullableType));
          }
          return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
        });
      }
      elmProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(this.elmType(p.type, true))).source;
        } else {
          return this.elmType(p.type).source;
        }
      }
      decoderNameForNamedType(t) {
        const name = this.nameForNamedType(t);
        return (0, Support_1.defined)(this._namedTypeDependents.get(name)).decoder;
      }
      decoderNameForType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("Jdec.value"), (_nullType) => (0, Source_1.multiWord)(" ", "Jdec.null", "()"), (_boolType) => (0, Source_1.singleWord)("Jdec.bool"), (_integerType) => (0, Source_1.singleWord)("Jdec.int"), (_doubleType) => (0, Source_1.singleWord)("Jdec.float"), (_stringType) => (0, Source_1.singleWord)("Jdec.string"), (arrayType) => (0, Source_1.multiWord)(" ", ["Jdec.", (0, Strings_1.decapitalize)(this.arrayType)], (0, Source_1.parenIfNeeded)(this.decoderNameForType(arrayType.items))), (classType) => (0, Source_1.singleWord)(this.decoderNameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "Jdec.dict", (0, Source_1.parenIfNeeded)(this.decoderNameForType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.decoderNameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableDecoder = this.decoderNameForType(nullable);
            if (noOptional)
              return nullableDecoder;
            return (0, Source_1.multiWord)(" ", "Jdec.nullable", (0, Source_1.parenIfNeeded)(nullableDecoder));
          }
          return (0, Source_1.singleWord)(this.decoderNameForNamedType(unionType));
        });
      }
      decoderNameForProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "Jdec.nullable", (0, Source_1.parenIfNeeded)(this.decoderNameForType(p.type, true)));
        } else {
          return this.decoderNameForType(p.type);
        }
      }
      encoderNameForNamedType(t) {
        const name = this.nameForNamedType(t);
        return (0, Support_1.defined)(this._namedTypeDependents.get(name)).encoder;
      }
      encoderNameForType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("identity"), (_nullType) => (0, Source_1.multiWord)(" ", "always", "Jenc.null"), (_boolType) => (0, Source_1.singleWord)("Jenc.bool"), (_integerType) => (0, Source_1.singleWord)("Jenc.int"), (_doubleType) => (0, Source_1.singleWord)("Jenc.float"), (_stringType) => (0, Source_1.singleWord)("Jenc.string"), (arrayType) => (0, Source_1.multiWord)(" ", ["make", this.arrayType, "Encoder"], (0, Source_1.parenIfNeeded)(this.encoderNameForType(arrayType.items))), (classType) => (0, Source_1.singleWord)(this.encoderNameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "makeDictEncoder", (0, Source_1.parenIfNeeded)(this.encoderNameForType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.encoderNameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableEncoder = this.encoderNameForType(nullable);
            if (noOptional)
              return nullableEncoder;
            return (0, Source_1.multiWord)(" ", "makeNullableEncoder", (0, Source_1.parenIfNeeded)(nullableEncoder));
          }
          return (0, Source_1.singleWord)(this.encoderNameForNamedType(unionType));
        });
      }
      encoderNameForProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "makeNullableEncoder", (0, Source_1.parenIfNeeded)(this.encoderNameForType(p.type, true)));
        } else {
          return this.encoderNameForType(p.type);
        }
      }
      emitTopLevelDefinition(t, topLevelName) {
        this.emitLine("type alias ", topLevelName, " = ", this.elmType(t).source);
      }
      emitClassDefinition(c, className) {
        let description = this.descriptionForType(c);
        this.forEachClassProperty(c, "none", (name, jsonName) => {
          const propertyDescription = this.descriptionForClassProperty(c, jsonName);
          if (propertyDescription === void 0)
            return;
          if (description === void 0) {
            description = [];
          } else {
            description.push("");
          }
          description.push(`${this.sourcelikeToString(name)}:`);
          description.push(...propertyDescription);
        });
        this.emitDescription(description);
        this.emitLine("type alias ", className, " =");
        this.indent(() => {
          let onFirst = true;
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            this.emitLine(onFirst ? "{" : ",", " ", name, " : ", this.elmProperty(p));
            onFirst = false;
          });
          if (onFirst) {
            this.emitLine("{");
          }
          this.emitLine("}");
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("type ", enumName);
        this.indent(() => {
          let onFirst = true;
          this.forEachEnumCase(e, "none", (name) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            this.emitLine(equalsOrPipe, " ", name);
            onFirst = false;
          });
        });
      }
      emitUnionDefinition(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("type ", unionName);
        this.indent(() => {
          let onFirst = true;
          this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            if (t.kind === "null") {
              this.emitLine(equalsOrPipe, " ", constructor);
            } else {
              this.emitLine(equalsOrPipe, " ", constructor, " ", (0, Source_1.parenIfNeeded)(this.elmType(t)));
            }
            onFirst = false;
          });
        });
      }
      emitTopLevelFunctions(t, topLevelName) {
        const { encoder, decoder } = (0, Support_1.defined)(this._topLevelDependents.get(topLevelName));
        if (this.namedTypeToNameForTopLevel(t) === void 0) {
          this.emitLine((0, Support_1.defined)(decoder), " : Jdec.Decoder ", topLevelName);
          this.emitLine((0, Support_1.defined)(decoder), " = ", this.decoderNameForType(t).source);
          this.ensureBlankLine();
        }
        this.emitLine(encoder, " : ", topLevelName, " -> String");
        this.emitLine(encoder, " r = Jenc.encode 0 (", this.encoderNameForType(t).source, " r)");
      }
      emitClassFunctions(c, className) {
        const decoderName = this.decoderNameForNamedType(c);
        this.emitLine(decoderName, " : Jdec.Decoder ", className);
        this.emitLine(decoderName, " =");
        this.indent(() => {
          this.emitLine("Jpipe.decode ", className);
          this.indent(() => {
            this.forEachClassProperty(c, "none", (_, jsonName, p) => {
              const propDecoder = (0, Source_1.parenIfNeeded)(this.decoderNameForProperty(p));
              const { reqOrOpt, fallback } = requiredOrOptional(p);
              this.emitLine("|> ", reqOrOpt, ' "', (0, Strings_1.stringEscape)(jsonName), '" ', propDecoder, fallback);
            });
          });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(c);
        this.emitLine(encoderName, " : ", className, " -> Jenc.Value");
        this.emitLine(encoderName, " x =");
        this.indent(() => {
          this.emitLine("Jenc.object");
          this.indent(() => {
            let onFirst = true;
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
              const bracketOrComma = onFirst ? "[" : ",";
              const propEncoder = this.encoderNameForProperty(p).source;
              this.emitLine(bracketOrComma, ' ("', (0, Strings_1.stringEscape)(jsonName), '", ', propEncoder, " x.", name, ")");
              onFirst = false;
            });
            if (onFirst) {
              this.emitLine("[");
            }
            this.emitLine("]");
          });
        });
      }
      emitEnumFunctions(e, enumName) {
        const decoderName = this.decoderNameForNamedType(e);
        this.emitLine(decoderName, " : Jdec.Decoder ", enumName);
        this.emitLine(decoderName, " =");
        this.indent(() => {
          this.emitLine("Jdec.string");
          this.indent(() => {
            this.emitLine("|> Jdec.andThen (\\str ->");
            this.indent(() => {
              this.emitLine("case str of");
              this.indent(() => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                  this.emitLine('"', (0, Strings_1.stringEscape)(jsonName), '" -> Jdec.succeed ', name);
                });
                this.emitLine('somethingElse -> Jdec.fail <| "Invalid ', enumName, ': " ++ somethingElse');
              });
            });
            this.emitLine(")");
          });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(e);
        this.emitLine(encoderName, " : ", enumName, " -> Jenc.Value");
        this.emitLine(encoderName, " x = case x of");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            this.emitLine(name, ' -> Jenc.string "', (0, Strings_1.stringEscape)(jsonName), '"');
          });
        });
      }
      emitUnionFunctions(u, unionName) {
        function sortOrder(_, t) {
          if (t.kind === "array") {
            return "  array";
          } else if (t.kind === "double") {
            return " xdouble";
          } else if (t.isPrimitive()) {
            return " " + t.kind;
          }
          return t.kind;
        }
        const decoderName = this.decoderNameForNamedType(u);
        this.emitLine(decoderName, " : Jdec.Decoder ", unionName);
        this.emitLine(decoderName, " =");
        this.indent(() => {
          this.emitLine("Jdec.oneOf");
          this.indent(() => {
            let onFirst = true;
            this.forEachUnionMember(u, null, "none", sortOrder, (constructor, t) => {
              const bracketOrComma = onFirst ? "[" : ",";
              if (t.kind === "null") {
                this.emitLine(bracketOrComma, " Jdec.null ", constructor);
              } else {
                const decoder = (0, Source_1.parenIfNeeded)(this.decoderNameForType(t));
                this.emitLine(bracketOrComma, " Jdec.map ", constructor, " ", decoder);
              }
              onFirst = false;
            });
            this.emitLine("]");
          });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(u);
        this.emitLine(encoderName, " : ", unionName, " -> Jenc.Value");
        this.emitLine(encoderName, " x = case x of");
        this.indent(() => {
          this.forEachUnionMember(u, null, "none", sortOrder, (constructor, t) => {
            if (t.kind === "null") {
              this.emitLine(constructor, " -> Jenc.null");
            } else {
              const encoder = this.encoderNameForType(t).source;
              this.emitLine(constructor, " y -> ", encoder, " y");
            }
          });
        });
      }
      emitSourceStructure() {
        const exports2 = [];
        const topLevelDecoders = [];
        this.forEachTopLevel("none", (_, name) => {
          let { encoder, decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
          if (decoder === void 0) {
            decoder = (0, Support_1.defined)(this._namedTypeDependents.get(name)).decoder;
          }
          topLevelDecoders.push(decoder);
          exports2.push(name, encoder, decoder);
        });
        this.forEachObject("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t))
            exports2.push(name);
        });
        this.forEachEnum("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t))
            exports2.push([name, "(..)"]);
        });
        this.forEachUnion("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t))
            exports2.push([name, "(..)"]);
        });
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitCommentLines([
            "To decode the JSON data, add this file to your project, run",
            "",
            "    elm-package install NoRedInk/elm-decode-pipeline",
            "",
            "add these imports",
            "",
            "    import Json.Decode exposing (decodeString)`);"
          ]);
          this.emitLine("--     import ", this._options.moduleName, " exposing (", (0, collection_utils_1.arrayIntercalate)(", ", topLevelDecoders), ")");
          this.emitMultiline(`--
-- and you're off to the races with
--`);
          this.forEachTopLevel("none", (_, name) => {
            let { decoder } = (0, Support_1.defined)(this._topLevelDependents.get(name));
            if (decoder === void 0) {
              decoder = (0, Support_1.defined)(this._namedTypeDependents.get(name)).decoder;
            }
            this.emitLine("--     decodeString ", decoder, " myJsonString");
          });
        }
        if (!this._options.justTypes) {
          this.ensureBlankLine();
          this.emitLine("module ", this._options.moduleName, " exposing");
          this.indent(() => {
            for (let i = 0; i < exports2.length; i++) {
              this.emitLine(i === 0 ? "(" : ",", " ", exports2[i]);
            }
            this.emitLine(")");
          });
          this.ensureBlankLine();
          this.emitMultiline(`import Json.Decode as Jdec
import Json.Decode.Pipeline as Jpipe
import Json.Encode as Jenc
import Dict exposing (Dict, map, toList)`);
          if (this._options.useList) {
            this.emitLine("import List exposing (map)");
          } else {
            this.emitLine("import Array exposing (Array, map)");
          }
        }
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelDefinition(t, topLevelName), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, enumName) => this.emitEnumDefinition(e, enumName), (u, unionName) => this.emitUnionDefinition(u, unionName));
        if (this._options.justTypes)
          return;
        this.ensureBlankLine();
        this.emitLine("-- decoders and encoders");
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelFunctions(t, topLevelName));
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className), (e, enumName) => this.emitEnumFunctions(e, enumName), (u, unionName) => this.emitUnionFunctions(u, unionName));
        this.ensureBlankLine();
        this.emitLine("--- encoder helpers");
        this.ensureBlankLine();
        this.emitLine("make", this.arrayType, "Encoder : (a -> Jenc.Value) -> ", this.arrayType, " a -> Jenc.Value");
        this.emitLine("make", this.arrayType, "Encoder f arr =");
        this.indent(() => {
          this.emitLine("Jenc.", (0, Strings_1.decapitalize)(this.arrayType), " (", this.arrayType, ".map f arr)");
        });
        this.ensureBlankLine();
        this.emitMultiline(`makeDictEncoder : (a -> Jenc.Value) -> Dict String a -> Jenc.Value
makeDictEncoder f dict =
    Jenc.object (toList (Dict.map (\\k -> f) dict))

makeNullableEncoder : (a -> Jenc.Value) -> Maybe a -> Jenc.Value
makeNullableEncoder f m =
    case m of
    Just x -> f x
    Nothing -> Jenc.null`);
      }
    };
    exports.ElmRenderer = ElmRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Golang.js
var require_Golang = __commonJS({
  "node_modules/quicktype-core/dist/language/Golang.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoRenderer = exports.GoTargetLanguage = exports.goOptions = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    exports.goOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      justTypesAndPackage: new RendererOptions_1.BooleanOption("just-types-and-package", "Plain types with package only", false),
      packageName: new RendererOptions_1.StringOption("package", "Generated package name", "NAME", "main"),
      multiFileOutput: new RendererOptions_1.BooleanOption("multi-file-output", "Renders each top-level object in its own Go file", false),
      fieldTags: new RendererOptions_1.StringOption("field-tags", "list of tags which should be generated for fields", "TAGS", "json"),
      omitEmpty: new RendererOptions_1.BooleanOption("omit-empty", 'If set, all non-required objects will be tagged with ",omitempty"', false)
    };
    var GoTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Go", ["go", "golang"], "go");
      }
      getOptions() {
        return [
          exports.goOptions.justTypes,
          exports.goOptions.justTypesAndPackage,
          exports.goOptions.packageName,
          exports.goOptions.multiFileOutput,
          exports.goOptions.fieldTags,
          exports.goOptions.omitEmpty
        ];
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date-time", "date-time");
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new GoRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.goOptions, untypedOptionValues));
      }
      get defaultIndentation() {
        return "	";
      }
    };
    exports.GoTargetLanguage = GoTargetLanguage;
    var namingFunction = (0, Naming_1.funPrefixNamer)("namer", goNameStyle);
    var legalizeName = (0, Strings_1.legalizeCharacters)(Strings_1.isLetterOrUnderscoreOrDigit);
    function goNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", Strings_1.isLetterOrUnderscore);
    }
    var primitiveValueTypeKinds = ["integer", "double", "bool", "string"];
    var compoundTypeKinds = ["array", "class", "map", "enum"];
    function isValueType(t) {
      const kind = t.kind;
      return primitiveValueTypeKinds.includes(kind) || kind === "class" || kind === "enum" || kind === "date-time";
    }
    function canOmitEmpty(cp, omitEmptyOption) {
      if (!cp.isOptional)
        return false;
      if (omitEmptyOption)
        return true;
      const t = cp.type;
      return !["union", "null", "any"].includes(t.kind);
    }
    var GoRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._topLevelUnmarshalNames = /* @__PURE__ */ new Map();
      }
      makeNamedTypeNamer() {
        return namingFunction;
      }
      namerForObjectProperty() {
        return namingFunction;
      }
      makeUnionMemberNamer() {
        return namingFunction;
      }
      makeEnumCaseNamer() {
        return namingFunction;
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      makeTopLevelDependencyNames(_, topLevelName) {
        const unmarshalName = new Naming_1.DependencyName(namingFunction, topLevelName.order, (lookup) => `unmarshal_${lookup(topLevelName)}`);
        this._topLevelUnmarshalNames.set(topLevelName, unmarshalName);
        return [unmarshalName];
      }
      /// startFile takes a file name, lowercases it, appends ".go" to it, and sets it as the current filename.
      startFile(basename) {
        if (this._options.multiFileOutput === false) {
          return;
        }
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished: " + this._currentFilename);
        this._currentFilename = `${this.sourcelikeToString(basename)}.go`;
        this.initializeEmitContextForFilename(this._currentFilename);
      }
      /// endFile pushes the current file name onto the collection of finished files and then resets the current file name. These finished files are used in index.ts to write the output.
      endFile() {
        if (this._options.multiFileOutput === false) {
          return;
        }
        this.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitFunc(decl, f) {
        this.emitBlock(["func ", decl], f);
      }
      emitStruct(name, table) {
        this.emitBlock(["type ", name, " struct"], () => this.emitTable(table));
      }
      nullableGoType(t, withIssues) {
        const goType = this.goType(t, withIssues);
        if (isValueType(t)) {
          return ["*", goType];
        } else {
          return goType;
        }
      }
      propertyGoType(cp) {
        const t = cp.type;
        if (t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) === null) {
          return ["*", this.goType(t, true)];
        }
        if (cp.isOptional) {
          return this.nullableGoType(t, true);
        }
        return this.goType(t, true);
      }
      goType(t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "interface{}"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "interface{}"), (_boolType) => "bool", (_integerType) => "int64", (_doubleType) => "float64", (_stringType) => "string", (arrayType) => ["[]", this.goType(arrayType.items, withIssues)], (classType) => this.nameForNamedType(classType), (mapType) => {
          let valueSource;
          const v = mapType.values;
          if (v instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(v) === null) {
            valueSource = ["*", this.nameForNamedType(v)];
          } else {
            valueSource = this.goType(v, withIssues);
          }
          return ["map[string]", valueSource];
        }, (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return this.nullableGoType(nullable, withIssues);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "time.Time";
          }
          return "string";
        });
      }
      emitTopLevel(t, name) {
        this.startFile(name);
        if (this._options.multiFileOutput && this._options.justTypes === false && this._options.justTypesAndPackage === false && this.leadingComments === void 0) {
          this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
          this.emitLineOnce("// To parse and unparse this JSON data, add this code to your project and do:");
          this.emitLineOnce("//");
          const ref = (0, Source_1.modifySource)(Strings_1.camelCase, name);
          this.emitLineOnce("//    ", ref, ", err := ", (0, Support_1.defined)(this._topLevelUnmarshalNames.get(name)), "(bytes)");
          this.emitLineOnce("//    bytes, err = ", ref, ".Marshal()");
        }
        this.emitPackageDefinitons(true);
        const unmarshalName = (0, Support_1.defined)(this._topLevelUnmarshalNames.get(name));
        if (this.namedTypeToNameForTopLevel(t) === void 0) {
          this.emitLine("type ", name, " ", this.goType(t));
        }
        if (this._options.justTypes || this._options.justTypesAndPackage)
          return;
        this.ensureBlankLine();
        this.emitFunc([unmarshalName, "(data []byte) (", name, ", error)"], () => {
          this.emitLine("var r ", name);
          this.emitLine("err := json.Unmarshal(data, &r)");
          this.emitLine("return r, err");
        });
        this.ensureBlankLine();
        this.emitFunc(["(r *", name, ") Marshal() ([]byte, error)"], () => {
          this.emitLine("return json.Marshal(r)");
        });
        this.endFile();
      }
      emitClass(c, className) {
        this.startFile(className);
        let columns = [];
        const usedTypes = /* @__PURE__ */ new Set();
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const description = this.descriptionForClassProperty(c, jsonName);
          const docStrings = description !== void 0 && description.length > 0 ? description.map((d) => "// " + d) : [];
          const goType = this.propertyGoType(p);
          const omitEmpty = canOmitEmpty(p, this._options.omitEmpty) ? ",omitempty" : [];
          docStrings.forEach((doc) => columns.push([doc]));
          const tags = this._options.fieldTags.split(",").map((tag) => tag + ':"' + (0, Strings_1.stringEscape)(jsonName) + omitEmpty + '"').join(" ");
          columns.push([
            [name, " "],
            [goType, " "],
            ["`", tags, "`"]
          ]);
          usedTypes.add(goType.toString());
        });
        this.emitPackageDefinitons(false, usedTypes.has("time.Time") || usedTypes.has("*,time.Time") || usedTypes.has("[],time.Time") ? /* @__PURE__ */ new Set(["time"]) : void 0);
        this.emitDescription(this.descriptionForType(c));
        this.emitStruct(className, columns);
        this.endFile();
      }
      emitEnum(e, enumName) {
        this.startFile(enumName);
        this.emitPackageDefinitons(false);
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("type ", enumName, " string");
        this.ensureBlankLine();
        this.emitLine("const (");
        let columns = [];
        this.forEachEnumCase(e, "none", (name, jsonName) => {
          columns.push([
            [name, " "],
            [enumName, ' = "', (0, Strings_1.stringEscape)(jsonName), '"']
          ]);
        });
        this.indent(() => this.emitTable(columns));
        this.emitLine(")");
        this.endFile();
      }
      emitUnion(u, unionName) {
        this.startFile(unionName);
        this.emitPackageDefinitons(false);
        const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        const isNullableArg = hasNull !== null ? "true" : "false";
        const ifMember = (kind, ifNotMember, f) => {
          const maybeType = u.findMember(kind);
          if (maybeType === void 0)
            return ifNotMember;
          return f(maybeType, this.nameForUnionMember(u, maybeType), this.goType(maybeType));
        };
        const maybeAssignNil = (kind) => {
          ifMember(kind, void 0, (_1, fieldName, _2) => {
            this.emitLine("x.", fieldName, " = nil");
          });
        };
        const makeArgs = (primitiveArg, compoundArg) => {
          const args = [];
          for (const kind of primitiveValueTypeKinds) {
            args.push(ifMember(kind, "nil", (_1, fieldName, _2) => primitiveArg(fieldName)), ", ");
          }
          for (const kind of compoundTypeKinds) {
            args.push(ifMember(kind, "false, nil", (t, fieldName, _) => compoundArg(t.kind === "class", fieldName)), ", ");
          }
          args.push(isNullableArg);
          return args;
        };
        let columns = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
          const goType = this.nullableGoType(t, true);
          columns.push([[fieldName, " "], goType]);
        });
        this.emitDescription(this.descriptionForType(u));
        this.emitStruct(unionName, columns);
        if (this._options.justTypes || this._options.justTypesAndPackage)
          return;
        this.ensureBlankLine();
        this.emitFunc(["(x *", unionName, ") UnmarshalJSON(data []byte) error"], () => {
          for (const kind of compoundTypeKinds) {
            maybeAssignNil(kind);
          }
          ifMember("class", void 0, (_1, _2, goType) => {
            this.emitLine("var c ", goType);
          });
          const args = makeArgs((fn) => ["&x.", fn], (isClass, fn) => {
            if (isClass) {
              return "true, &c";
            } else {
              return ["true, &x.", fn];
            }
          });
          this.emitLine("object, err := unmarshalUnion(data, ", args, ")");
          this.emitBlock("if err != nil", () => {
            this.emitLine("return err");
          });
          this.emitBlock("if object", () => {
            ifMember("class", void 0, (_1, fieldName, _2) => {
              this.emitLine("x.", fieldName, " = &c");
            });
          });
          this.emitLine("return nil");
        });
        this.ensureBlankLine();
        this.emitFunc(["(x *", unionName, ") MarshalJSON() ([]byte, error)"], () => {
          const args = makeArgs((fn) => ["x.", fn], (_, fn) => ["x.", fn, " != nil, x.", fn]);
          this.emitLine("return marshalUnion(", args, ")");
        });
        this.endFile();
      }
      emitSingleFileHeaderComments() {
        this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
        this.emitLineOnce("// To parse and unparse this JSON data, add this code to your project and do:");
        this.forEachTopLevel("none", (_, name) => {
          this.emitLine("//");
          const ref = (0, Source_1.modifySource)(Strings_1.camelCase, name);
          this.emitLine("//    ", ref, ", err := ", (0, Support_1.defined)(this._topLevelUnmarshalNames.get(name)), "(bytes)");
          this.emitLine("//    bytes, err = ", ref, ".Marshal()");
        });
      }
      emitPackageDefinitons(includeJSONEncodingImport, imports = /* @__PURE__ */ new Set()) {
        if (!this._options.justTypes || this._options.justTypesAndPackage) {
          this.ensureBlankLine();
          const packageDeclaration = "package " + this._options.packageName;
          this.emitLineOnce(packageDeclaration);
          this.ensureBlankLine();
        }
        if (!this._options.justTypes && !this._options.justTypesAndPackage) {
          if (this.haveNamedUnions && this._options.multiFileOutput === false) {
            imports.add("bytes");
            imports.add("errors");
          }
          if (includeJSONEncodingImport) {
            imports.add("encoding/json");
          }
        }
        this.emitImports(imports);
      }
      emitImports(imports) {
        const sortedImports = Array.from(imports).sort((a, b) => a.localeCompare(b));
        if (sortedImports.length === 0) {
          return;
        }
        sortedImports.forEach((packageName) => {
          this.emitLineOnce(`import "${packageName}"`);
        });
        this.ensureBlankLine();
      }
      emitHelperFunctions() {
        if (this.haveNamedUnions) {
          this.startFile("JSONSchemaSupport");
          const imports = /* @__PURE__ */ new Set();
          if (this._options.multiFileOutput) {
            imports.add("bytes");
            imports.add("errors");
          }
          this.emitPackageDefinitons(true, imports);
          this.ensureBlankLine();
          this.emitMultiline(`func unmarshalUnion(data []byte, pi **int64, pf **float64, pb **bool, ps **string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) (bool, error) {
    if pi != nil {
        *pi = nil
    }
    if pf != nil {
        *pf = nil
    }
    if pb != nil {
        *pb = nil
    }
    if ps != nil {
        *ps = nil
    }

    dec := json.NewDecoder(bytes.NewReader(data))
    dec.UseNumber()
    tok, err := dec.Token()
    if err != nil {
        return false, err
    }

    switch v := tok.(type) {
    case json.Number:
        if pi != nil {
            i, err := v.Int64()
            if err == nil {
                *pi = &i
                return false, nil
            }
        }
        if pf != nil {
            f, err := v.Float64()
            if err == nil {
                *pf = &f
                return false, nil
            }
            return false, errors.New("Unparsable number")
        }
        return false, errors.New("Union does not contain number")
    case float64:
        return false, errors.New("Decoder should not return float64")
    case bool:
        if pb != nil {
            *pb = &v
            return false, nil
        }
        return false, errors.New("Union does not contain bool")
    case string:
        if haveEnum {
            return false, json.Unmarshal(data, pe)
        }
        if ps != nil {
            *ps = &v
            return false, nil
        }
        return false, errors.New("Union does not contain string")
    case nil:
        if nullable {
            return false, nil
        }
        return false, errors.New("Union does not contain null")
    case json.Delim:
        if v == '{' {
            if haveObject {
                return true, json.Unmarshal(data, pc)
            }
            if haveMap {
                return false, json.Unmarshal(data, pm)
            }
            return false, errors.New("Union does not contain object")
        }
        if v == '[' {
            if haveArray {
                return false, json.Unmarshal(data, pa)
            }
            return false, errors.New("Union does not contain array")
        }
        return false, errors.New("Cannot handle delimiter")
    }
    return false, errors.New("Cannot unmarshal union")

}

func marshalUnion(pi *int64, pf *float64, pb *bool, ps *string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) ([]byte, error) {
    if pi != nil {
        return json.Marshal(*pi)
    }
    if pf != nil {
        return json.Marshal(*pf)
    }
    if pb != nil {
        return json.Marshal(*pb)
    }
    if ps != nil {
        return json.Marshal(*ps)
    }
    if haveArray {
        return json.Marshal(pa)
    }
    if haveObject {
        return json.Marshal(pc)
    }
    if haveMap {
        return json.Marshal(pm)
    }
    if haveEnum {
        return json.Marshal(pe)
    }
    if nullable {
        return json.Marshal(nil)
    }
    return nil, errors.New("Union must not be null")
}`);
          this.endFile();
        }
      }
      emitSourceStructure() {
        if (this._options.multiFileOutput === false && this._options.justTypes === false && this._options.justTypesAndPackage === false && this.leadingComments === void 0) {
          this.emitSingleFileHeaderComments();
          this.emitPackageDefinitons(false, this.collectAllImports());
        }
        this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevel(t, name), (t) => !(this._options.justTypes || this._options.justTypesAndPackage) || this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachObject("leading-and-interposing", (c, className) => this.emitClass(c, className));
        this.forEachEnum("leading-and-interposing", (u, enumName) => this.emitEnum(u, enumName));
        this.forEachUnion("leading-and-interposing", (u, unionName) => this.emitUnion(u, unionName));
        if (this._options.justTypes || this._options.justTypesAndPackage) {
          return;
        }
        this.emitHelperFunctions();
      }
      collectAllImports() {
        let imports = /* @__PURE__ */ new Set();
        this.forEachObject("leading-and-interposing", (c, _className) => {
          const classImports = this.collectClassImports(c);
          imports = /* @__PURE__ */ new Set([...imports, ...classImports]);
        });
        this.forEachUnion("leading-and-interposing", (u, _unionName) => {
          const unionImports = this.collectUnionImports(u);
          imports = /* @__PURE__ */ new Set([...imports, ...unionImports]);
        });
        return imports;
      }
      collectClassImports(c) {
        const usedTypes = /* @__PURE__ */ new Set();
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("time.Time", "time");
        mapping.set("*,time.Time", "time");
        mapping.set("[],time.Time", "time");
        this.forEachClassProperty(c, "none", (_name, _jsonName, p) => {
          const goType = this.propertyGoType(p);
          usedTypes.add(goType.toString());
        });
        const imports = /* @__PURE__ */ new Set();
        usedTypes.forEach((k) => {
          const typeImport = mapping.get(k);
          if (typeImport) {
            imports.add(typeImport);
          }
        });
        return imports;
      }
      collectUnionImports(u) {
        const usedTypes = /* @__PURE__ */ new Set();
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("time.Time", "time");
        mapping.set("*,time.Time", "time");
        this.forEachUnionMember(u, null, "none", null, (_fieldName, t) => {
          const goType = this.nullableGoType(t, true);
          usedTypes.add(goType.toString());
        });
        const imports = /* @__PURE__ */ new Set();
        usedTypes.forEach((k) => {
          const typeImport = mapping.get(k);
          if (!typeImport) {
            return;
          }
          imports.add(typeImport);
        });
        return imports;
      }
    };
    exports.GoRenderer = GoRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Haskell.js
var require_Haskell = __commonJS({
  "node_modules/quicktype-core/dist/language/Haskell.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HaskellRenderer = exports.HaskellTargetLanguage = exports.haskellOptions = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var TargetLanguage_1 = require_TargetLanguage();
    var TypeUtils_1 = require_TypeUtils();
    exports.haskellOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      useList: new RendererOptions_1.EnumOption("array-type", "Use Array or List", [
        ["array", false],
        ["list", true]
      ]),
      moduleName: new RendererOptions_1.StringOption("module", "Generated module name", "NAME", "QuickType")
    };
    var HaskellTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Haskell", ["haskell"], "haskell");
      }
      getOptions() {
        return [exports.haskellOptions.justTypes, exports.haskellOptions.moduleName, exports.haskellOptions.useList];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new HaskellRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.haskellOptions, untypedOptionValues));
      }
    };
    exports.HaskellTargetLanguage = HaskellTargetLanguage;
    var forbiddenNames = [
      // reserved keywords
      "as",
      "case",
      "class",
      "data",
      "default",
      "deriving",
      "do",
      "else",
      "family",
      "forall",
      "foreign",
      "hiding",
      "if",
      "import",
      "in",
      "infix",
      "infixl",
      "infixr",
      "instance",
      "let",
      "of",
      "mdo",
      "module",
      "newtype",
      "proc",
      "qualified",
      "rec",
      "then",
      "type",
      "where",
      // in Prelude keywords ...
      "id",
      "Array",
      "HashMap",
      "Map",
      "Maybe",
      "Bool",
      "Int",
      "True",
      "False",
      "Enum",
      // Aeson types
      "encode",
      "decode",
      "text",
      "Text",
      "Value",
      "Object",
      "Result",
      "Series",
      "Error"
    ];
    var legalizeName = (0, Strings_1.legalizeCharacters)((cp) => (0, Strings_1.isAscii)(cp) && (0, Strings_1.isLetterOrUnderscoreOrDigit)(cp));
    function haskellNameStyle(original, upper) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", Strings_1.isLetterOrUnderscore);
    }
    var upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (n) => haskellNameStyle(n, true));
    var lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (n) => haskellNameStyle(n, false));
    var HaskellRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      forbiddenNamesForGlobalNamespace() {
        return forbiddenNames;
      }
      makeNamedTypeNamer() {
        return upperNamingFunction;
      }
      namerForObjectProperty() {
        return lowerNamingFunction;
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      makeUnionMemberNamer() {
        return upperNamingFunction;
      }
      get unionMembersInGlobalNamespace() {
        return true;
      }
      makeEnumCaseNamer() {
        return upperNamingFunction;
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      proposeUnionMemberName(u, unionName, fieldType, lookup) {
        const fieldName = super.proposeUnionMemberName(u, unionName, fieldType, lookup);
        return `${fieldName}_in_${lookup(unionName)}`;
      }
      get commentLineStart() {
        return "-- ";
      }
      emitDescriptionBlock(lines) {
        if (lines.length === 1) {
          this.emitComments([{ customLines: lines, lineStart: "{-| ", lineEnd: " -}" }]);
        } else {
          this.emitCommentLines(lines, {
            firstLineStart: "{-| ",
            lineStart: "",
            afterComment: "-}"
          });
        }
      }
      haskellType(t, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.multiWord)(" ", "Maybe", "Text"), (_nullType) => (0, Source_1.multiWord)(" ", "Maybe", "Text"), (_boolType) => (0, Source_1.singleWord)("Bool"), (_integerType) => (0, Source_1.singleWord)("Int"), (_doubleType) => (0, Source_1.singleWord)("Float"), (_stringType) => (0, Source_1.singleWord)("Text"), (arrayType) => {
          if (this._options.useList) {
            return (0, Source_1.multiWord)("", "[", (0, Source_1.parenIfNeeded)(this.haskellType(arrayType.items)), "]");
          }
          return (0, Source_1.multiWord)(" ", "Vector", (0, Source_1.parenIfNeeded)(this.haskellType(arrayType.items)));
        }, (classType) => (0, Source_1.singleWord)(this.nameForNamedType(classType)), (mapType) => (0, Source_1.multiWord)(" ", "HashMap Text", (0, Source_1.parenIfNeeded)(this.haskellType(mapType.values))), (enumType) => (0, Source_1.singleWord)(this.nameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            const nullableType = this.haskellType(nullable);
            if (noOptional)
              return nullableType;
            return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(nullableType));
          }
          return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
        });
      }
      haskellProperty(p) {
        if (p.isOptional) {
          return (0, Source_1.multiWord)(" ", "Maybe", (0, Source_1.parenIfNeeded)(this.haskellType(p.type, true))).source;
        } else {
          return this.haskellType(p.type).source;
        }
      }
      encoderNameForType(t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("String"), (_nullType) => (0, Source_1.singleWord)("Null"), (_boolType) => (0, Source_1.singleWord)("Bool"), (_integerType) => (0, Source_1.singleWord)("Number"), (_doubleType) => (0, Source_1.singleWord)("Number"), (_stringType) => (0, Source_1.singleWord)("String"), (_arrayType) => (0, Source_1.singleWord)("Array"), (_classType) => (0, Source_1.singleWord)("Object"), (_mapType) => (0, Source_1.singleWord)("Object"), (_enumType) => (0, Source_1.singleWord)("Object"), (_unionType) => (0, Source_1.singleWord)("Object"));
      }
      emitTopLevelDefinition(t, topLevelName) {
        this.emitLine("type ", topLevelName, " = ", this.haskellType(t).source);
      }
      emitClassDefinition(c, className) {
        let description = this.descriptionForType(c);
        this.forEachClassProperty(c, "none", (name, jsonName) => {
          const propertyDescription = this.descriptionForClassProperty(c, jsonName);
          if (propertyDescription === void 0)
            return;
          if (description === void 0) {
            description = [];
          } else {
            description.push("");
          }
          description.push(`${this.sourcelikeToString(name)}:`);
          description.push(...propertyDescription);
        });
        this.emitDescription(description);
        this.emitLine("data ", className, " = ", className);
        this.indent(() => {
          let onFirst = true;
          this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
            this.emitLine(onFirst ? "{ " : ", ", name, className, " :: ", this.haskellProperty(p));
            onFirst = false;
          });
          if (onFirst) {
            this.emitLine("{");
          }
          this.emitLine("} deriving (Show)");
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("data ", enumName);
        this.indent(() => {
          let onFirst = true;
          this.forEachEnumCase(e, "none", (name) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            this.emitLine(equalsOrPipe, " ", name, enumName);
            onFirst = false;
          });
          this.emitLine("deriving (Show)");
        });
      }
      emitUnionDefinition(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("data ", unionName);
        this.indent(() => {
          let onFirst = true;
          this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
            const equalsOrPipe = onFirst ? "=" : "|";
            if (t.kind === "null") {
              this.emitLine(equalsOrPipe, " ", constructor);
            } else {
              this.emitLine(equalsOrPipe, " ", constructor, " ", (0, Source_1.parenIfNeeded)(this.haskellType(t)));
            }
            onFirst = false;
          });
          this.emitLine("deriving (Show)");
        });
      }
      emitTopLevelFunctions(topLevelName) {
        this.emitLine("decodeTopLevel :: ByteString -> Maybe ", topLevelName);
        this.emitLine("decodeTopLevel = decode");
      }
      classPropertyLength(c) {
        let counter = 0;
        this.forEachClassProperty(c, "none", () => {
          counter += 1;
        });
        return counter;
      }
      emitClassEncoderInstance(c, className) {
        let classProperties = [];
        this.forEachClassProperty(c, "none", (name) => {
          classProperties.push(" ");
          classProperties.push(name);
          classProperties.push(className);
        });
        this.emitLine("instance ToJSON ", className, " where");
        this.indent(() => {
          if (classProperties.length === 0) {
            this.emitLine("toJSON = \\_ -> emptyObject");
          } else {
            this.emitLine("toJSON (", className, ...classProperties, ") =");
            this.indent(() => {
              this.emitLine("object");
              let onFirst = true;
              this.forEachClassProperty(c, "none", (name, jsonName) => {
                this.emitLine(onFirst ? "[ " : ", ", '"', (0, Strings_1.stringEscape)(jsonName), '" .= ', name, className);
                onFirst = false;
              });
              if (onFirst) {
                this.emitLine("[");
              }
              this.emitLine("]");
            });
          }
        });
      }
      emitClassDecoderInstance(c, className) {
        this.emitLine("instance FromJSON ", className, " where");
        this.indent(() => {
          if (this.classPropertyLength(c) === 0) {
            this.emitLine("parseJSON emptyObject = return ", className);
          } else {
            this.emitLine("parseJSON (Object v) = ", className);
            this.indent(() => {
              let onFirst = true;
              this.forEachClassProperty(c, "none", (_, jsonName, p) => {
                const operator = p.isOptional ? ".:?" : ".:";
                this.emitLine(onFirst ? "<$> " : "<*> ", "v ", operator, ' "', (0, Strings_1.stringEscape)(jsonName), '"');
                onFirst = false;
              });
            });
          }
        });
      }
      emitClassFunctions(c, className) {
        this.emitClassEncoderInstance(c, className);
        this.ensureBlankLine();
        this.emitClassDecoderInstance(c, className);
      }
      emitEnumEncoderInstance(e, enumName) {
        this.emitLine("instance ToJSON ", enumName, " where");
        this.indent(() => {
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            this.emitLine("toJSON ", name, enumName, ' = "', (0, Strings_1.stringEscape)(jsonName), '"');
          });
        });
      }
      emitEnumDecoderInstance(e, enumName) {
        this.emitLine("instance FromJSON ", enumName, " where");
        this.indent(() => {
          this.emitLine('parseJSON = withText "', enumName, '" parseText');
          this.indent(() => {
            this.emitLine("where");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine('parseText "', (0, Strings_1.stringEscape)(jsonName), '" = return ', name, enumName);
              });
            });
          });
        });
      }
      emitEnumFunctions(e, enumName) {
        this.emitEnumEncoderInstance(e, enumName);
        this.ensureBlankLine();
        this.emitEnumDecoderInstance(e, enumName);
      }
      emitUnionEncoderInstance(u, unionName) {
        this.emitLine("instance ToJSON ", unionName, " where");
        this.indent(() => {
          this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
            if (t.kind === "null") {
              this.emitLine("toJSON ", constructor, " = Null");
            } else {
              this.emitLine("toJSON (", constructor, " x) = toJSON x");
            }
          });
        });
      }
      emitUnionDecoderInstance(u, unionName) {
        this.emitLine("instance FromJSON ", unionName, " where");
        this.indent(() => {
          this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
            if (t.kind === "null") {
              this.emitLine("parseJSON Null = return ", constructor);
            } else {
              this.emitLine("parseJSON xs@(", this.encoderNameForType(t).source, " _) = (fmap ", constructor, " . parseJSON) xs");
            }
          });
        });
      }
      emitUnionFunctions(u, unionName) {
        this.emitUnionEncoderInstance(u, unionName);
        this.ensureBlankLine();
        this.emitUnionDecoderInstance(u, unionName);
      }
      emitLanguageExtensions(ext) {
        this.emitLine(`{-# LANGUAGE ${ext} #-}`);
      }
      emitSourceStructure() {
        const exports2 = [];
        this.forEachTopLevel("none", (_, name) => {
          exports2.push([name, " (..)"]);
        });
        this.forEachObject("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t))
            exports2.push([name, " (..)"]);
        });
        this.forEachEnum("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t))
            exports2.push([name, " (..)"]);
        });
        this.forEachUnion("none", (t, name) => {
          if (!(0, collection_utils_1.mapContains)(this.topLevels, t))
            exports2.push([name, " (..)"]);
        });
        this.emitLanguageExtensions("StrictData");
        this.emitLanguageExtensions("OverloadedStrings");
        if (!this._options.justTypes) {
          this.ensureBlankLine();
          this.emitLine("module ", this._options.moduleName);
          this.indent(() => {
            for (let i = 0; i < exports2.length; i++) {
              this.emitLine(i === 0 ? "(" : ",", " ", exports2[i]);
            }
            this.emitLine(", decodeTopLevel");
            this.emitLine(") where");
          });
          this.ensureBlankLine();
          this.emitMultiline(`import Data.Aeson
import Data.Aeson.Types (emptyObject)
import Data.ByteString.Lazy (ByteString)
import Data.HashMap.Strict (HashMap)
import Data.Text (Text)`);
          if (this._options.useList) {
          } else {
            this.emitLine("import Data.Vector (Vector)");
          }
        }
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelDefinition(t, topLevelName), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, enumName) => this.emitEnumDefinition(e, enumName), (u, unionName) => this.emitUnionDefinition(u, unionName));
        this.forEachTopLevel("leading-and-interposing", (_, topLevelName) => this.emitTopLevelFunctions(topLevelName));
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className), (e, enumName) => this.emitEnumFunctions(e, enumName), (u, unionName) => this.emitUnionFunctions(u, unionName));
        if (this._options.justTypes)
          return;
        this.ensureBlankLine();
      }
    };
    exports.HaskellRenderer = HaskellRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Java.js
var require_Java = __commonJS({
  "node_modules/quicktype-core/dist/language/Java.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JacksonRenderer = exports.JavaRenderer = exports.javaNameStyle = exports.stringEscape = exports.JavaTargetLanguage = exports.javaOptions = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    exports.javaOptions = {
      useList: new RendererOptions_1.EnumOption("array-type", "Use T[] or List<T>", [
        ["array", false],
        ["list", true]
      ], "array"),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      dateTimeProvider: new RendererOptions_1.EnumOption("datetime-provider", "Date time provider type", [
        ["java8", "java8"],
        ["legacy", "legacy"]
      ], "java8"),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      // FIXME: Do this via a configurable named eventually.
      packageName: new RendererOptions_1.StringOption("package", "Generated package name", "NAME", "io.quicktype"),
      lombok: new RendererOptions_1.BooleanOption("lombok", "Use lombok", false, "primary"),
      lombokCopyAnnotations: new RendererOptions_1.BooleanOption("lombok-copy-annotations", "Copy accessor annotations", true, "secondary")
    };
    var JavaTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Java", ["java"], "java");
      }
      getOptions() {
        return [
          exports.javaOptions.useList,
          exports.javaOptions.justTypes,
          exports.javaOptions.dateTimeProvider,
          exports.javaOptions.acronymStyle,
          exports.javaOptions.packageName,
          exports.javaOptions.lombok,
          exports.javaOptions.lombokCopyAnnotations
        ];
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.javaOptions, untypedOptionValues);
        if (options.justTypes) {
          return new JavaRenderer(this, renderContext, options);
        }
        return new JacksonRenderer(this, renderContext, options);
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date");
        mapping.set("time", "time");
        mapping.set("date-time", "date-time");
        mapping.set("uuid", "uuid");
        return mapping;
      }
    };
    exports.JavaTargetLanguage = JavaTargetLanguage;
    var javaKeywords = [
      "_",
      "Object",
      "Class",
      "System",
      "Long",
      "Double",
      "Boolean",
      "String",
      "List",
      "Map",
      "UUID",
      "Exception",
      "IOException",
      "Override",
      "abstract",
      "continue",
      "for",
      "new",
      "switch",
      "assert",
      "default",
      "goto",
      "package",
      "synchronized",
      "boolean",
      "do",
      "if",
      "private",
      "this",
      "break",
      "double",
      "implements",
      "protected",
      "throw",
      "byte",
      "else",
      "import",
      "public",
      "throws",
      "case",
      "enum",
      "instanceof",
      "return",
      "transient",
      "catch",
      "extends",
      "int",
      "short",
      "try",
      "char",
      "final",
      "interface",
      "static",
      "void",
      "class",
      "finally",
      "long",
      "strictfp",
      "volatile",
      "const",
      "float",
      "native",
      "super",
      "while",
      "null",
      "false",
      "true"
    ];
    exports.stringEscape = (0, Strings_1.utf16ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isAscii, Strings_1.standardUnicodeHexEscape));
    function isStartCharacter(codePoint) {
      if (codePoint === 95)
        return true;
      return (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isLetter)(codePoint);
    }
    function isPartCharacter(codePoint) {
      return isStartCharacter(codePoint) || (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function javaNameStyle(startWithUpper, upperUnderscore, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upperUnderscore ? Strings_1.allUpperWordStyle : startWithUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, upperUnderscore ? Strings_1.allUpperWordStyle : Strings_1.firstUpperWordStyle, upperUnderscore || startWithUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, upperUnderscore ? "_" : "", isStartCharacter);
    }
    exports.javaNameStyle = javaNameStyle;
    var JavaDateTimeProvider = class {
      constructor(_renderer, _className) {
        this._renderer = _renderer;
        this._className = _className;
        this.shouldEmitDateTimeConverter = true;
        this.shouldEmitTimeConverter = true;
        this.shouldEmitDateConverter = true;
      }
    };
    var Java8DateTimeProvider = class extends JavaDateTimeProvider {
      constructor() {
        super(...arguments);
        this.keywords = [
          "LocalDate",
          "OffsetDateTime",
          "OffsetTime",
          "ZoneOffset",
          "ZonedDateTime",
          "DateTimeFormatter",
          "DateTimeFormatterBuilder",
          "ChronoField"
        ];
        this.dateTimeImports = ["java.time.OffsetDateTime"];
        this.dateImports = ["java.time.LocalDate"];
        this.timeImports = ["java.time.OffsetTime"];
        this.converterImports = [
          "java.time.LocalDate",
          "java.time.OffsetDateTime",
          "java.time.OffsetTime",
          "java.time.ZoneOffset",
          "java.time.ZonedDateTime",
          "java.time.format.DateTimeFormatter",
          "java.time.format.DateTimeFormatterBuilder",
          "java.time.temporal.ChronoField"
        ];
        this.dateTimeType = "OffsetDateTime";
        this.dateType = "LocalDate";
        this.timeType = "OffsetTime";
        this.dateTimeJacksonAnnotations = [];
        this.dateJacksonAnnotations = [];
        this.timeJacksonAnnotations = [];
      }
      emitDateTimeConverters() {
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final DateTimeFormatter DATE_TIME_FORMATTER = new DateTimeFormatterBuilder()");
        this._renderer.indent(() => this._renderer.indent(() => {
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_DATE_TIME)");
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_OFFSET_DATE_TIME)");
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_INSTANT)");
          this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SX"))');
          this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssX"))');
          this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))');
          this._renderer.emitLine(".toFormatter()");
          this._renderer.emitLine(".withZone(ZoneOffset.UTC);");
        }));
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static OffsetDateTime parseDateTimeString(String str)", () => {
          this._renderer.emitLine("return ZonedDateTime.from(Converter.DATE_TIME_FORMATTER.parse(str)).toOffsetDateTime();");
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final DateTimeFormatter TIME_FORMATTER = new DateTimeFormatterBuilder()");
        this._renderer.indent(() => this._renderer.indent(() => {
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_TIME)");
          this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_OFFSET_TIME)");
          this._renderer.emitLine(".parseDefaulting(ChronoField.YEAR, 2020)");
          this._renderer.emitLine(".parseDefaulting(ChronoField.MONTH_OF_YEAR, 1)");
          this._renderer.emitLine(".parseDefaulting(ChronoField.DAY_OF_MONTH, 1)");
          this._renderer.emitLine(".toFormatter()");
          this._renderer.emitLine(".withZone(ZoneOffset.UTC);");
        }));
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static OffsetTime parseTimeString(String str)", () => {
          this._renderer.emitLine("return ZonedDateTime.from(Converter.TIME_FORMATTER.parse(str)).toOffsetDateTime().toOffsetTime();");
        });
      }
      convertStringToDateTime(variable) {
        return [this._className, ".parseDateTimeString(", variable, ")"];
      }
      convertStringToTime(variable) {
        return [this._className, ".parseTimeString(", variable, ")"];
      }
      convertStringToDate(variable) {
        return ["LocalDate.parse(", variable, ")"];
      }
      convertDateTimeToString(variable) {
        return [variable, ".format(java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME)"];
      }
      convertTimeToString(variable) {
        return [variable, ".format(java.time.format.DateTimeFormatter.ISO_OFFSET_TIME)"];
      }
      convertDateToString(variable) {
        return [variable, ".format(java.time.format.DateTimeFormatter.ISO_DATE)"];
      }
    };
    var JavaLegacyDateTimeProvider = class extends JavaDateTimeProvider {
      constructor() {
        super(...arguments);
        this.keywords = ["SimpleDateFormat", "Date"];
        this.dateTimeImports = ["java.util.Date"];
        this.dateImports = ["java.util.Date"];
        this.timeImports = ["java.util.Date"];
        this.converterImports = ["java.util.Date", "java.text.SimpleDateFormat"];
        this.dateTimeType = "Date";
        this.dateType = "Date";
        this.timeType = "Date";
        this.dateTimeJacksonAnnotations = [
          `@JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ssX", timezone = "UTC")`
        ];
        this.dateJacksonAnnotations = ['@JsonFormat(pattern = "yyyy-MM-dd")'];
        this.timeJacksonAnnotations = ['@JsonFormat(pattern = "HH:mm:ssX", timezone = "UTC")'];
        this.shouldEmitTimeConverter = false;
        this.shouldEmitDateConverter = false;
      }
      emitDateTimeConverters() {
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final String[] DATE_TIME_FORMATS = {");
        this._renderer.indent(() => this._renderer.indent(() => {
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ss.SX",`);
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ss.S",`);
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ssX",`);
          this._renderer.emitLine(`"yyyy-MM-dd'T'HH:mm:ss",`);
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss.SX",');
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss.S",');
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ssX",');
          this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss",');
          this._renderer.emitLine('"HH:mm:ss.SZ",');
          this._renderer.emitLine('"HH:mm:ss.S",');
          this._renderer.emitLine('"HH:mm:ssZ",');
          this._renderer.emitLine('"HH:mm:ss",');
          this._renderer.emitLine('"yyyy-MM-dd",');
        }));
        this._renderer.emitLine("};");
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static Date parseAllDateTimeString(String str)", () => {
          this._renderer.emitBlock("for (String format : DATE_TIME_FORMATS)", () => {
            this._renderer.emitIgnoredTryCatchBlock(() => {
              this._renderer.emitLine("return new SimpleDateFormat(format).parse(str);");
            });
          });
          this._renderer.emitLine("return null;");
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeDateTime(Date datetime)", () => {
          this._renderer.emitLine(`return new SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ssZ").format(datetime);`);
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeDate(Date datetime)", () => {
          this._renderer.emitLine('return new SimpleDateFormat("yyyy-MM-dd").format(datetime);');
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeTime(Date datetime)", () => {
          this._renderer.emitLine('return new SimpleDateFormat("hh:mm:ssZ").format(datetime);');
        });
      }
      convertStringToDateTime(variable) {
        return [this._className, ".parseAllDateTimeString(", variable, ")"];
      }
      convertStringToTime(variable) {
        return [this._className, ".parseAllDateTimeString(", variable, ")"];
      }
      convertStringToDate(variable) {
        return [this._className, ".parseAllDateTimeString(", variable, ")"];
      }
      convertDateTimeToString(variable) {
        return [this._className, ".serializeDateTime(", variable, ")"];
      }
      convertTimeToString(variable) {
        return [this._className, ".serializeTime(", variable, ")"];
      }
      convertDateToString(variable) {
        return [this._className, ".serializeDate(", variable, ")"];
      }
    };
    var JavaRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._haveEmittedLeadingComments = false;
        this._converterClassname = "Converter";
        this._converterKeywords = [];
        switch (_options.dateTimeProvider) {
          default:
          case "java8":
            this._dateTimeProvider = new Java8DateTimeProvider(this, this._converterClassname);
            break;
          case "legacy":
            this._dateTimeProvider = new JavaLegacyDateTimeProvider(this, this._converterClassname);
            break;
        }
      }
      forbiddenNamesForGlobalNamespace() {
        const keywords = [
          ...javaKeywords,
          ...this._converterKeywords,
          this._converterClassname,
          ...this._dateTimeProvider.keywords
        ];
        return keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return this.getNameStyling("typeNamingFunction");
      }
      namerForObjectProperty() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeUnionMemberNamer() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeEnumCaseNamer() {
        return this.getNameStyling("enumCaseNamingFunction");
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `get_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `set_${lookup(name)}`);
        return [getterName, setterName];
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
      }
      getNameStyling(convention) {
        const styling = {
          typeNamingFunction: (0, Naming_1.funPrefixNamer)("types", (n) => javaNameStyle(true, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          propertyNamingFunction: (0, Naming_1.funPrefixNamer)("properties", (n) => javaNameStyle(false, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          enumCaseNamingFunction: (0, Naming_1.funPrefixNamer)("enum-cases", (n) => javaNameStyle(true, true, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)))
        };
        return styling[convention];
      }
      fieldOrMethodName(methodName, topLevelName) {
        if (this.topLevels.size === 1) {
          return methodName;
        }
        return [topLevelName, (0, Strings_1.capitalize)(methodName)];
      }
      methodName(prefix, suffix, topLevelName) {
        if (this.topLevels.size === 1) {
          return [prefix, suffix];
        }
        return [prefix, topLevelName, suffix];
      }
      decoderName(topLevelName) {
        return this.fieldOrMethodName("fromJsonString", topLevelName);
      }
      encoderName(topLevelName) {
        return this.fieldOrMethodName("toJsonString", topLevelName);
      }
      readerGetterName(topLevelName) {
        return this.methodName("get", "ObjectReader", topLevelName);
      }
      writerGetterName(topLevelName) {
        return this.methodName("get", "ObjectWriter", topLevelName);
      }
      startFile(basename) {
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished");
        this._currentFilename = `${this.sourcelikeToString(basename)}.java`;
        this.ensureBlankLine();
        if (!this._haveEmittedLeadingComments && this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          this.ensureBlankLine();
          this._haveEmittedLeadingComments = true;
        }
      }
      finishFile() {
        super.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      emitPackageAndImports(imports) {
        this.emitLine("package ", this._options.packageName, ";");
        this.ensureBlankLine();
        for (const pkg of imports) {
          this.emitLine("import ", pkg, ";");
        }
      }
      emitFileHeader(fileName, imports) {
        this.startFile(fileName);
        this.emitPackageAndImports(imports);
        this.ensureBlankLine();
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitTryCatch(main, handler, exception = "Exception") {
        this.emitLine("try {");
        this.indent(main);
        this.emitLine("} catch (", exception, " ex) {");
        this.indent(handler);
        this.emitLine("}");
      }
      emitIgnoredTryCatchBlock(f) {
        this.emitTryCatch(f, () => this.emitLine("// Ignored"));
      }
      javaType(reference, t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "Object"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "Object"), (_boolType) => reference ? "Boolean" : "boolean", (_integerType) => reference ? "Long" : "long", (_doubleType) => reference ? "Double" : "double", (_stringType) => "String", (arrayType) => {
          if (this._options.useList) {
            return ["List<", this.javaType(true, arrayType.items, withIssues), ">"];
          } else {
            return [this.javaType(false, arrayType.items, withIssues), "[]"];
          }
        }, (classType) => this.nameForNamedType(classType), (mapType) => ["Map<String, ", this.javaType(true, mapType.values, withIssues), ">"], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return this.javaType(true, nullable, withIssues);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "time") {
            return this._dateTimeProvider.timeType;
          }
          if (transformedStringType.kind === "date") {
            return this._dateTimeProvider.dateType;
          }
          if (transformedStringType.kind === "date-time") {
            return this._dateTimeProvider.dateTimeType;
          }
          if (transformedStringType.kind === "uuid") {
            return "UUID";
          }
          return "String";
        });
      }
      javaImport(t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [], (_nullType) => [], (_boolType) => [], (_integerType) => [], (_doubleType) => [], (_stringType) => [], (arrayType) => {
          if (this._options.useList) {
            return [...this.javaImport(arrayType.items), "java.util.List"];
          } else {
            return [...this.javaImport(arrayType.items)];
          }
        }, (_classType) => [], (mapType) => [...this.javaImport(mapType.values), "java.util.Map"], (_enumType) => [], (unionType) => {
          const imports = [];
          unionType.members.forEach((type) => this.javaImport(type).forEach((imp) => imports.push(imp)));
          return imports;
        }, (transformedStringType) => {
          if (transformedStringType.kind === "time") {
            return this._dateTimeProvider.timeImports;
          }
          if (transformedStringType.kind === "date") {
            return this._dateTimeProvider.dateImports;
          }
          if (transformedStringType.kind === "date-time") {
            return this._dateTimeProvider.dateTimeImports;
          }
          if (transformedStringType.kind === "uuid") {
            return ["java.util.UUID"];
          }
          return [];
        });
      }
      javaTypeWithoutGenerics(reference, t) {
        if (t instanceof Type_1.ArrayType) {
          if (this._options.useList) {
            return ["List"];
          } else {
            return [this.javaTypeWithoutGenerics(false, t.items), "[]"];
          }
        } else if (t instanceof Type_1.MapType) {
          return "Map";
        } else if (t instanceof Type_1.UnionType) {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (nullable !== null)
            return this.javaTypeWithoutGenerics(true, nullable);
          return this.nameForNamedType(t);
        } else {
          return this.javaType(reference, t);
        }
      }
      emitClassAttributes(_c, _className) {
        if (this._options.lombok) {
          this.emitLine("@lombok.Data");
        }
      }
      annotationsForAccessor(_c, _className, _propertyName, _jsonName, _p, _isSetter) {
        return [];
      }
      importsForType(t) {
        if (t instanceof Type_1.ClassType) {
          return [];
        }
        if (t instanceof Type_1.UnionType) {
          return ["java.io.IOException"];
        }
        if (t instanceof Type_1.EnumType) {
          return ["java.io.IOException"];
        }
        return (0, Support_1.assertNever)(t);
      }
      importsForClass(c) {
        const imports = [];
        this.forEachClassProperty(c, "none", (_name, _jsonName, p) => {
          this.javaImport(p.type).forEach((imp) => imports.push(imp));
        });
        imports.sort();
        return [...new Set(imports)];
      }
      importsForUnionMembers(u) {
        const imports = [];
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        this.forEachUnionMember(u, nonNulls, "none", null, (_fieldName, t) => {
          this.javaImport(t).forEach((imp) => imports.push(imp));
        });
        imports.sort();
        return [...new Set(imports)];
      }
      emitClassDefinition(c, className) {
        let imports = [...this.importsForType(c), ...this.importsForClass(c)];
        this.emitFileHeader(className, imports);
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAttributes(c, className);
        this.emitBlock(["public class ", className], () => {
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            if (this._options.lombok && this._options.lombokCopyAnnotations) {
              const getter = this.annotationsForAccessor(c, className, name, jsonName, p, false);
              const setter = this.annotationsForAccessor(c, className, name, jsonName, p, true);
              if (getter.length !== 0) {
                this.emitLine("@lombok.Getter(onMethod_ = {" + getter.join(", ") + "})");
              }
              if (setter.length !== 0) {
                this.emitLine("@lombok.Setter(onMethod_ = {" + setter.join(", ") + "})");
              }
            }
            this.emitLine("private ", this.javaType(false, p.type, true), " ", name, ";");
          });
          if (!this._options.lombok) {
            this.forEachClassProperty(c, "leading-and-interposing", (name, jsonName, p) => {
              this.emitDescription(this.descriptionForClassProperty(c, jsonName));
              const [getterName, setterName] = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              const rendered = this.javaType(false, p.type);
              this.annotationsForAccessor(c, className, name, jsonName, p, false).forEach((annotation) => this.emitLine(annotation));
              this.emitLine("public ", rendered, " ", getterName, "() { return ", name, "; }");
              this.annotationsForAccessor(c, className, name, jsonName, p, true).forEach((annotation) => this.emitLine(annotation));
              this.emitLine("public void ", setterName, "(", rendered, " value) { this.", name, " = value; }");
            });
          }
        });
        this.finishFile();
      }
      unionField(u, t, withIssues = false) {
        const fieldType = this.javaType(true, t, withIssues);
        const fieldName = [this.nameForUnionMember(u, t), "Value"];
        return { fieldType, fieldName };
      }
      emitUnionAttributes(_u, _unionName) {
      }
      emitUnionSerializer(_u, _unionName) {
      }
      emitUnionDefinition(u, unionName) {
        const imports = [...this.importsForType(u), ...this.importsForUnionMembers(u)];
        this.emitFileHeader(unionName, imports);
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        this.emitUnionAttributes(u, unionName);
        this.emitBlock(["public class ", unionName], () => {
          for (const t of nonNulls) {
            const { fieldType, fieldName } = this.unionField(u, t, true);
            this.emitLine("public ", fieldType, " ", fieldName, ";");
          }
          this.emitUnionSerializer(u, unionName);
        });
        this.finishFile();
      }
      emitEnumSerializationAttributes(_e) {
      }
      emitEnumDeserializationAttributes(_e) {
      }
      emitEnumDefinition(e, enumName) {
        this.emitFileHeader(enumName, this.importsForType(e));
        this.emitDescription(this.descriptionForType(e));
        const caseNames = [];
        this.forEachEnumCase(e, "none", (name) => {
          if (caseNames.length > 0)
            caseNames.push(", ");
          caseNames.push(name);
        });
        caseNames.push(";");
        this.emitBlock(["public enum ", enumName], () => {
          this.emitLine(caseNames);
          this.ensureBlankLine();
          this.emitEnumSerializationAttributes(e);
          this.emitBlock("public String toValue()", () => {
            this.emitLine("switch (this) {");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("case ", name, ': return "', (0, exports.stringEscape)(jsonName), '";');
              });
            });
            this.emitLine("}");
            this.emitLine("return null;");
          });
          this.ensureBlankLine();
          this.emitEnumDeserializationAttributes(e);
          this.emitBlock(["public static ", enumName, " forValue(String value) throws IOException"], () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine('if (value.equals("', (0, exports.stringEscape)(jsonName), '")) return ', name, ";");
            });
            this.emitLine('throw new IOException("Cannot deserialize ', enumName, '");');
          });
        });
        this.finishFile();
      }
      emitSourceStructure() {
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.JavaRenderer = JavaRenderer;
    var JacksonRenderer = class extends JavaRenderer {
      constructor(targetLanguage, renderContext, options) {
        super(targetLanguage, renderContext, options);
        this._converterKeywords = [
          "JsonProperty",
          "JsonDeserialize",
          "JsonDeserializer",
          "JsonSerialize",
          "JsonSerializer",
          "JsonParser",
          "JsonProcessingException",
          "DeserializationContext",
          "SerializerProvider"
        ];
      }
      emitClassAttributes(c, _className) {
        if (c.getProperties().size === 0)
          this.emitLine("@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.NONE)");
        super.emitClassAttributes(c, _className);
      }
      annotationsForAccessor(_c, _className, _propertyName, jsonName, p, _isSetter) {
        const superAnnotations = super.annotationsForAccessor(_c, _className, _propertyName, jsonName, p, _isSetter);
        const annotations = ['@JsonProperty("' + (0, exports.stringEscape)(jsonName) + '")'];
        switch (p.type.kind) {
          case "date-time":
            this._dateTimeProvider.dateTimeJacksonAnnotations.forEach((annotation) => annotations.push(annotation));
            break;
          case "date":
            this._dateTimeProvider.dateJacksonAnnotations.forEach((annotation) => annotations.push(annotation));
            break;
          case "time":
            this._dateTimeProvider.timeJacksonAnnotations.forEach((annotation) => annotations.push(annotation));
            break;
          default:
            break;
        }
        return [...superAnnotations, ...annotations];
      }
      importsForType(t) {
        if (t instanceof Type_1.ClassType) {
          const imports = super.importsForType(t);
          imports.push("com.fasterxml.jackson.annotation.*");
          return imports;
        }
        if (t instanceof Type_1.UnionType) {
          const imports = super.importsForType(t);
          imports.push("java.io.IOException", "com.fasterxml.jackson.core.*", "com.fasterxml.jackson.databind.*", "com.fasterxml.jackson.databind.annotation.*");
          if (this._options.useList) {
            imports.push("com.fasterxml.jackson.core.type.*");
          }
          return imports;
        }
        if (t instanceof Type_1.EnumType) {
          const imports = super.importsForType(t);
          imports.push("com.fasterxml.jackson.annotation.*");
          return imports;
        }
        return (0, Support_1.assertNever)(t);
      }
      emitUnionAttributes(_u, unionName) {
        this.emitLine("@JsonDeserialize(using = ", unionName, ".Deserializer.class)");
        this.emitLine("@JsonSerialize(using = ", unionName, ".Serializer.class)");
      }
      emitUnionSerializer(u, unionName) {
        const stringBasedObjects = ["uuid", "time", "date", "date-time"];
        const tokenCase = (tokenType2) => {
          this.emitLine("case ", tokenType2, ":");
        };
        const emitNullDeserializer = () => {
          this.indent(() => {
            tokenCase("VALUE_NULL");
            this.indent(() => this.emitLine("break;"));
          });
        };
        const emitDeserializerCodeForStringObjects = (fieldName, kind, parseFrom) => {
          switch (kind) {
            case "date":
              this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToDate(parseFrom), ";");
              break;
            case "time":
              this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToTime(parseFrom), ";");
              break;
            case "date-time":
              this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToDateTime(parseFrom), ";");
              break;
            case "uuid":
              this.emitLine("value.", fieldName, " = UUID.fromString(", parseFrom, ");");
              break;
            default:
              return (0, Support_1.panic)("Requested type isnt an object!");
          }
        };
        const emitDeserializeType = (t, variableFieldName = "") => {
          const { fieldName } = this.unionField(u, t);
          const rendered = this.javaTypeWithoutGenerics(true, t);
          if (this._options.useList && t instanceof Type_1.ArrayType) {
            this.emitLine("value.", fieldName, " = jsonParser.readValueAs(new TypeReference<", rendered, ">() {});");
          } else if (stringBasedObjects.some((stringBasedTypeKind) => t.kind === stringBasedTypeKind)) {
            emitDeserializerCodeForStringObjects(fieldName, t.kind, variableFieldName);
          } else if (t.kind === "string") {
            this.emitLine("value.", fieldName, " = ", variableFieldName, ";");
          } else if (t.kind === "enum") {
            const { fieldType } = this.unionField(u, t, true);
            this.emitLine("value.", fieldName, " = ", fieldType, ".forValue(", variableFieldName, ");");
          } else {
            this.emitLine("value.", fieldName, " = jsonParser.readValueAs(", rendered, ".class);");
          }
        };
        const emitDeserializer = (tokenTypes, kind) => {
          const t = u.findMember(kind);
          if (t === void 0)
            return;
          this.indent(() => {
            for (const tokenType2 of tokenTypes) {
              tokenCase(tokenType2);
            }
            this.indent(() => {
              emitDeserializeType(t);
              this.emitLine("break;");
            });
          });
        };
        const emitStringDeserializer = () => {
          const enumType = u.findMember("enum");
          const stringType = u.findMember("string");
          if (stringBasedObjects.every((kind) => u.findMember(kind) === void 0) && stringType === void 0 && enumType === void 0)
            return;
          this.indent(() => {
            tokenCase("VALUE_STRING");
            this.indent(() => {
              const fromVariable = "string";
              this.emitLine("String " + fromVariable + " = jsonParser.readValueAs(String.class);");
              stringBasedObjects.forEach((kind) => {
                const type = u.findMember(kind);
                if (type !== void 0) {
                  this.emitIgnoredTryCatchBlock(() => {
                    emitDeserializeType(type, fromVariable);
                  });
                }
              });
              if (enumType !== void 0) {
                this.emitIgnoredTryCatchBlock(() => {
                  emitDeserializeType(enumType, fromVariable);
                });
              }
              if (stringType !== void 0) {
                emitDeserializeType(stringType, fromVariable);
              }
              this.emitLine("break;");
            });
          });
        };
        const emitNumberDeserializer = () => {
          const integerType = u.findMember("integer");
          const doubleType = u.findMember("double");
          if (doubleType === void 0 && integerType === void 0)
            return;
          this.indent(() => {
            tokenCase("VALUE_NUMBER_INT");
            if (integerType !== void 0) {
              this.indent(() => {
                emitDeserializeType(integerType);
                this.emitLine("break;");
              });
            }
            if (doubleType !== void 0) {
              tokenCase("VALUE_NUMBER_FLOAT");
              this.indent(() => {
                emitDeserializeType(doubleType);
                this.emitLine("break;");
              });
            }
          });
        };
        const customObjectSerializer = ["time", "date", "date-time"];
        const serializerCodeForType = (type, fieldName) => {
          switch (type.kind) {
            case "date":
              return this._dateTimeProvider.convertDateToString(fieldName);
            case "time":
              return this._dateTimeProvider.convertTimeToString(fieldName);
            case "date-time":
              return this._dateTimeProvider.convertDateTimeToString(fieldName);
            default:
              return (0, Support_1.panic)("Requested type doesn't have custom serializer code!");
          }
        };
        const emitSerializeType = (t) => {
          let { fieldName } = this.unionField(u, t, true);
          this.emitBlock(["if (obj.", fieldName, " != null)"], () => {
            if (customObjectSerializer.some((customSerializerType) => t.kind === customSerializerType)) {
              this.emitLine("jsonGenerator.writeObject(", serializerCodeForType(t, ["obj.", fieldName]), ");");
            } else {
              this.emitLine("jsonGenerator.writeObject(obj.", fieldName, ");");
            }
            this.emitLine("return;");
          });
        };
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        this.ensureBlankLine();
        this.emitBlock(["static class Deserializer extends JsonDeserializer<", unionName, ">"], () => {
          this.emitLine("@Override");
          this.emitBlock([
            "public ",
            unionName,
            " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException"
          ], () => {
            this.emitLine(unionName, " value = new ", unionName, "();");
            this.emitLine("switch (jsonParser.currentToken()) {");
            if (maybeNull !== null)
              emitNullDeserializer();
            emitNumberDeserializer();
            emitDeserializer(["VALUE_TRUE", "VALUE_FALSE"], "bool");
            emitStringDeserializer();
            emitDeserializer(["START_ARRAY"], "array");
            emitDeserializer(["START_OBJECT"], "class");
            emitDeserializer(["START_OBJECT"], "map");
            this.indent(() => this.emitLine('default: throw new IOException("Cannot deserialize ', unionName, '");'));
            this.emitLine("}");
            this.emitLine("return value;");
          });
        });
        this.ensureBlankLine();
        this.emitBlock(["static class Serializer extends JsonSerializer<", unionName, ">"], () => {
          this.emitLine("@Override");
          this.emitBlock([
            "public void serialize(",
            unionName,
            " obj, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException"
          ], () => {
            for (const t of nonNulls) {
              emitSerializeType(t);
            }
            if (maybeNull !== null) {
              this.emitLine("jsonGenerator.writeNull();");
            } else {
              this.emitLine('throw new IOException("', unionName, ' must not be null");');
            }
          });
        });
      }
      emitEnumSerializationAttributes(_e) {
        this.emitLine("@JsonValue");
      }
      emitEnumDeserializationAttributes(_e) {
        this.emitLine("@JsonCreator");
      }
      emitOffsetDateTimeConverterModule() {
        this.emitLine("SimpleModule module = new SimpleModule();");
        if (this._dateTimeProvider.shouldEmitDateTimeConverter) {
          this.emitLine("module.addDeserializer(", this._dateTimeProvider.dateTimeType, ".class, new JsonDeserializer<", this._dateTimeProvider.dateTimeType, ">() {");
          this.indent(() => {
            this.emitLine("@Override");
            this.emitBlock([
              "public ",
              this._dateTimeProvider.dateTimeType,
              " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
              "throws IOException, JsonProcessingException"
            ], () => {
              this.emitLine("String value = jsonParser.getText();");
              this.emitLine("return ", this._dateTimeProvider.convertStringToDateTime("value"), ";");
            });
          });
          this.emitLine("});");
        }
        if (!this._dateTimeProvider.shouldEmitTimeConverter) {
          this.emitLine("module.addDeserializer(", this._dateTimeProvider.timeType, ".class, new JsonDeserializer<", this._dateTimeProvider.timeType, ">() {");
          this.indent(() => {
            this.emitLine("@Override");
            this.emitBlock([
              "public ",
              this._dateTimeProvider.timeType,
              " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
              "throws IOException, JsonProcessingException"
            ], () => {
              this.emitLine("String value = jsonParser.getText();");
              this.emitLine("return ", this._dateTimeProvider.convertStringToTime("value"), ";");
            });
          });
          this.emitLine("});");
        }
        if (!this._dateTimeProvider.shouldEmitDateConverter) {
          this.emitLine("module.addDeserializer(", this._dateTimeProvider.dateType, ".class, new JsonDeserializer<", this._dateTimeProvider.dateType, ">() {");
          this.indent(() => {
            this.emitLine("@Override");
            this.emitBlock([
              "public ",
              this._dateTimeProvider.dateType,
              " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
              "throws IOException, JsonProcessingException"
            ], () => {
              this.emitLine("String value = jsonParser.getText();");
              this.emitLine("return ", this._dateTimeProvider.convertStringToDate("value"), ";");
            });
          });
          this.emitLine("});");
        }
        this.emitLine("mapper.registerModule(module);");
      }
      emitConverterClass() {
        this.startFile(this._converterClassname);
        this.emitCommentLines([
          "To use this code, add the following Maven dependency to your project:",
          "",
          this._options.lombok ? "    org.projectlombok : lombok : 1.18.2" : "",
          "    com.fasterxml.jackson.core     : jackson-databind          : 2.9.0",
          this._options.dateTimeProvider === "java8" ? "    com.fasterxml.jackson.datatype : jackson-datatype-jsr310   : 2.9.0" : "",
          "",
          "Import this package:",
          ""
        ]);
        this.emitLine("//     import ", this._options.packageName, ".Converter;");
        this.emitMultiline(`//
// Then you can deserialize a JSON string with
//`);
        this.forEachTopLevel("none", (t, name) => {
          this.emitLine("//     ", this.javaType(false, t), " data = Converter.", this.decoderName(name), "(jsonString);");
        });
        this.ensureBlankLine();
        const imports = [
          "java.io.IOException",
          "com.fasterxml.jackson.databind.*",
          "com.fasterxml.jackson.databind.module.SimpleModule",
          "com.fasterxml.jackson.core.JsonParser",
          "com.fasterxml.jackson.core.JsonProcessingException",
          "java.util.*"
        ].concat(this._dateTimeProvider.converterImports);
        this.emitPackageAndImports(imports);
        this.ensureBlankLine();
        this.emitBlock(["public class Converter"], () => {
          this.emitLine("// Date-time helpers");
          this._dateTimeProvider.emitDateTimeConverters();
          this.emitLine("// Serialize/deserialize helpers");
          this.forEachTopLevel("leading-and-interposing", (topLevelType, topLevelName) => {
            const topLevelTypeRendered = this.javaType(false, topLevelType);
            this.emitBlock([
              "public static ",
              topLevelTypeRendered,
              " ",
              this.decoderName(topLevelName),
              "(String json) throws IOException"
            ], () => {
              this.emitLine("return ", this.readerGetterName(topLevelName), "().readValue(json);");
            });
            this.ensureBlankLine();
            this.emitBlock([
              "public static String ",
              this.encoderName(topLevelName),
              "(",
              topLevelTypeRendered,
              " obj) throws JsonProcessingException"
            ], () => {
              this.emitLine("return ", this.writerGetterName(topLevelName), "().writeValueAsString(obj);");
            });
          });
          this.forEachTopLevel("leading-and-interposing", (topLevelType, topLevelName) => {
            const readerName = this.fieldOrMethodName("reader", topLevelName);
            const writerName = this.fieldOrMethodName("writer", topLevelName);
            this.emitLine("private static ObjectReader ", readerName, ";");
            this.emitLine("private static ObjectWriter ", writerName, ";");
            this.ensureBlankLine();
            this.emitBlock(["private static void ", this.methodName("instantiate", "Mapper", topLevelName), "()"], () => {
              const renderedForClass = this.javaTypeWithoutGenerics(false, topLevelType);
              this.emitLine("ObjectMapper mapper = new ObjectMapper();");
              this.emitLine("mapper.findAndRegisterModules();");
              this.emitLine("mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);");
              this.emitLine("mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);");
              this.emitOffsetDateTimeConverterModule();
              this.emitLine(readerName, " = mapper.readerFor(", renderedForClass, ".class);");
              this.emitLine(writerName, " = mapper.writerFor(", renderedForClass, ".class);");
            });
            this.ensureBlankLine();
            this.emitBlock(["private static ObjectReader ", this.readerGetterName(topLevelName), "()"], () => {
              this.emitLine("if (", readerName, " == null) ", this.methodName("instantiate", "Mapper", topLevelName), "();");
              this.emitLine("return ", readerName, ";");
            });
            this.ensureBlankLine();
            this.emitBlock(["private static ObjectWriter ", this.writerGetterName(topLevelName), "()"], () => {
              this.emitLine("if (", writerName, " == null) ", this.methodName("instantiate", "Mapper", topLevelName), "();");
              this.emitLine("return ", writerName, ";");
            });
          });
        });
        this.finishFile();
      }
      emitSourceStructure() {
        this.emitConverterClass();
        super.emitSourceStructure();
      }
    };
    exports.JacksonRenderer = JacksonRenderer;
  }
});

// node_modules/quicktype-core/dist/support/Converters.js
var require_Converters = __commonJS({
  "node_modules/quicktype-core/dist/support/Converters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertersOption = exports.ConvertersOptions = void 0;
    var RendererOptions_1 = require_RendererOptions();
    var ConvertersOptions;
    (function(ConvertersOptions2) {
      ConvertersOptions2["AllObjects"] = "all-objects";
      ConvertersOptions2["TopLevel"] = "top-level";
    })(ConvertersOptions = exports.ConvertersOptions || (exports.ConvertersOptions = {}));
    function convertersOption() {
      return new RendererOptions_1.EnumOption("converters", "Which converters to generate (top-level by default)", [
        [ConvertersOptions.TopLevel, ConvertersOptions.TopLevel],
        [ConvertersOptions.AllObjects, ConvertersOptions.AllObjects]
      ], ConvertersOptions.TopLevel, "secondary");
    }
    exports.convertersOption = convertersOption;
  }
});

// node_modules/quicktype-core/dist/language/JavaScriptUnicodeMaps.js
var require_JavaScriptUnicodeMaps = __commonJS({
  "node_modules/quicktype-core/dist/language/JavaScriptUnicodeMaps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isES3IdentifierPart = exports.isES3IdentifierStart = void 0;
    function lookupInUnicodeMap(code, map2) {
      if (code < map2[0]) {
        return false;
      }
      let lo = 0;
      let hi = map2.length;
      let mid;
      while (lo + 1 < hi) {
        mid = lo + (hi - lo) / 2;
        mid -= mid % 2;
        if (map2[mid] <= code && code <= map2[mid + 1]) {
          return true;
        }
        if (code < map2[mid]) {
          hi = mid;
        } else {
          lo = mid + 2;
        }
      }
      return false;
    }
    function isES3IdentifierStart(ch) {
      return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch === 36 || ch === 95 || ch > 127 && lookupInUnicodeMap(ch, unicodeES3IdentifierStart);
    }
    exports.isES3IdentifierStart = isES3IdentifierStart;
    function isES3IdentifierPart(ch) {
      return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95 || ch > 127 && lookupInUnicodeMap(ch, unicodeES3IdentifierPart);
    }
    exports.isES3IdentifierPart = isES3IdentifierPart;
    var unicodeES3IdentifierStart = [
      170,
      170,
      181,
      181,
      186,
      186,
      192,
      214,
      216,
      246,
      248,
      543,
      546,
      563,
      592,
      685,
      688,
      696,
      699,
      705,
      720,
      721,
      736,
      740,
      750,
      750,
      890,
      890,
      902,
      902,
      904,
      906,
      908,
      908,
      910,
      929,
      931,
      974,
      976,
      983,
      986,
      1011,
      1024,
      1153,
      1164,
      1220,
      1223,
      1224,
      1227,
      1228,
      1232,
      1269,
      1272,
      1273,
      1329,
      1366,
      1369,
      1369,
      1377,
      1415,
      1488,
      1514,
      1520,
      1522,
      1569,
      1594,
      1600,
      1610,
      1649,
      1747,
      1749,
      1749,
      1765,
      1766,
      1786,
      1788,
      1808,
      1808,
      1810,
      1836,
      1920,
      1957,
      2309,
      2361,
      2365,
      2365,
      2384,
      2384,
      2392,
      2401,
      2437,
      2444,
      2447,
      2448,
      2451,
      2472,
      2474,
      2480,
      2482,
      2482,
      2486,
      2489,
      2524,
      2525,
      2527,
      2529,
      2544,
      2545,
      2565,
      2570,
      2575,
      2576,
      2579,
      2600,
      2602,
      2608,
      2610,
      2611,
      2613,
      2614,
      2616,
      2617,
      2649,
      2652,
      2654,
      2654,
      2674,
      2676,
      2693,
      2699,
      2701,
      2701,
      2703,
      2705,
      2707,
      2728,
      2730,
      2736,
      2738,
      2739,
      2741,
      2745,
      2749,
      2749,
      2768,
      2768,
      2784,
      2784,
      2821,
      2828,
      2831,
      2832,
      2835,
      2856,
      2858,
      2864,
      2866,
      2867,
      2870,
      2873,
      2877,
      2877,
      2908,
      2909,
      2911,
      2913,
      2949,
      2954,
      2958,
      2960,
      2962,
      2965,
      2969,
      2970,
      2972,
      2972,
      2974,
      2975,
      2979,
      2980,
      2984,
      2986,
      2990,
      2997,
      2999,
      3001,
      3077,
      3084,
      3086,
      3088,
      3090,
      3112,
      3114,
      3123,
      3125,
      3129,
      3168,
      3169,
      3205,
      3212,
      3214,
      3216,
      3218,
      3240,
      3242,
      3251,
      3253,
      3257,
      3294,
      3294,
      3296,
      3297,
      3333,
      3340,
      3342,
      3344,
      3346,
      3368,
      3370,
      3385,
      3424,
      3425,
      3461,
      3478,
      3482,
      3505,
      3507,
      3515,
      3517,
      3517,
      3520,
      3526,
      3585,
      3632,
      3634,
      3635,
      3648,
      3654,
      3713,
      3714,
      3716,
      3716,
      3719,
      3720,
      3722,
      3722,
      3725,
      3725,
      3732,
      3735,
      3737,
      3743,
      3745,
      3747,
      3749,
      3749,
      3751,
      3751,
      3754,
      3755,
      3757,
      3760,
      3762,
      3763,
      3773,
      3773,
      3776,
      3780,
      3782,
      3782,
      3804,
      3805,
      3840,
      3840,
      3904,
      3911,
      3913,
      3946,
      3976,
      3979,
      4096,
      4129,
      4131,
      4135,
      4137,
      4138,
      4176,
      4181,
      4256,
      4293,
      4304,
      4342,
      4352,
      4441,
      4447,
      4514,
      4520,
      4601,
      4608,
      4614,
      4616,
      4678,
      4680,
      4680,
      4682,
      4685,
      4688,
      4694,
      4696,
      4696,
      4698,
      4701,
      4704,
      4742,
      4744,
      4744,
      4746,
      4749,
      4752,
      4782,
      4784,
      4784,
      4786,
      4789,
      4792,
      4798,
      4800,
      4800,
      4802,
      4805,
      4808,
      4814,
      4816,
      4822,
      4824,
      4846,
      4848,
      4878,
      4880,
      4880,
      4882,
      4885,
      4888,
      4894,
      4896,
      4934,
      4936,
      4954,
      5024,
      5108,
      5121,
      5740,
      5743,
      5750,
      5761,
      5786,
      5792,
      5866,
      6016,
      6067,
      6176,
      6263,
      6272,
      6312,
      7680,
      7835,
      7840,
      7929,
      7936,
      7957,
      7960,
      7965,
      7968,
      8005,
      8008,
      8013,
      8016,
      8023,
      8025,
      8025,
      8027,
      8027,
      8029,
      8029,
      8031,
      8061,
      8064,
      8116,
      8118,
      8124,
      8126,
      8126,
      8130,
      8132,
      8134,
      8140,
      8144,
      8147,
      8150,
      8155,
      8160,
      8172,
      8178,
      8180,
      8182,
      8188,
      8319,
      8319,
      8450,
      8450,
      8455,
      8455,
      8458,
      8467,
      8469,
      8469,
      8473,
      8477,
      8484,
      8484,
      8486,
      8486,
      8488,
      8488,
      8490,
      8493,
      8495,
      8497,
      8499,
      8505,
      8544,
      8579,
      12293,
      12295,
      12321,
      12329,
      12337,
      12341,
      12344,
      12346,
      12353,
      12436,
      12445,
      12446,
      12449,
      12538,
      12540,
      12542,
      12549,
      12588,
      12593,
      12686,
      12704,
      12727,
      13312,
      19893,
      19968,
      40869,
      40960,
      42124,
      44032,
      55203,
      63744,
      64045,
      64256,
      64262,
      64275,
      64279,
      64285,
      64285,
      64287,
      64296,
      64298,
      64310,
      64312,
      64316,
      64318,
      64318,
      64320,
      64321,
      64323,
      64324,
      64326,
      64433,
      64467,
      64829,
      64848,
      64911,
      64914,
      64967,
      65008,
      65019,
      65136,
      65138,
      65140,
      65140,
      65142,
      65276,
      65313,
      65338,
      65345,
      65370,
      65382,
      65470,
      65474,
      65479,
      65482,
      65487,
      65490,
      65495,
      65498,
      65500
    ];
    var unicodeES3IdentifierPart = [
      170,
      170,
      181,
      181,
      186,
      186,
      192,
      214,
      216,
      246,
      248,
      543,
      546,
      563,
      592,
      685,
      688,
      696,
      699,
      705,
      720,
      721,
      736,
      740,
      750,
      750,
      768,
      846,
      864,
      866,
      890,
      890,
      902,
      902,
      904,
      906,
      908,
      908,
      910,
      929,
      931,
      974,
      976,
      983,
      986,
      1011,
      1024,
      1153,
      1155,
      1158,
      1164,
      1220,
      1223,
      1224,
      1227,
      1228,
      1232,
      1269,
      1272,
      1273,
      1329,
      1366,
      1369,
      1369,
      1377,
      1415,
      1425,
      1441,
      1443,
      1465,
      1467,
      1469,
      1471,
      1471,
      1473,
      1474,
      1476,
      1476,
      1488,
      1514,
      1520,
      1522,
      1569,
      1594,
      1600,
      1621,
      1632,
      1641,
      1648,
      1747,
      1749,
      1756,
      1759,
      1768,
      1770,
      1773,
      1776,
      1788,
      1808,
      1836,
      1840,
      1866,
      1920,
      1968,
      2305,
      2307,
      2309,
      2361,
      2364,
      2381,
      2384,
      2388,
      2392,
      2403,
      2406,
      2415,
      2433,
      2435,
      2437,
      2444,
      2447,
      2448,
      2451,
      2472,
      2474,
      2480,
      2482,
      2482,
      2486,
      2489,
      2492,
      2492,
      2494,
      2500,
      2503,
      2504,
      2507,
      2509,
      2519,
      2519,
      2524,
      2525,
      2527,
      2531,
      2534,
      2545,
      2562,
      2562,
      2565,
      2570,
      2575,
      2576,
      2579,
      2600,
      2602,
      2608,
      2610,
      2611,
      2613,
      2614,
      2616,
      2617,
      2620,
      2620,
      2622,
      2626,
      2631,
      2632,
      2635,
      2637,
      2649,
      2652,
      2654,
      2654,
      2662,
      2676,
      2689,
      2691,
      2693,
      2699,
      2701,
      2701,
      2703,
      2705,
      2707,
      2728,
      2730,
      2736,
      2738,
      2739,
      2741,
      2745,
      2748,
      2757,
      2759,
      2761,
      2763,
      2765,
      2768,
      2768,
      2784,
      2784,
      2790,
      2799,
      2817,
      2819,
      2821,
      2828,
      2831,
      2832,
      2835,
      2856,
      2858,
      2864,
      2866,
      2867,
      2870,
      2873,
      2876,
      2883,
      2887,
      2888,
      2891,
      2893,
      2902,
      2903,
      2908,
      2909,
      2911,
      2913,
      2918,
      2927,
      2946,
      2947,
      2949,
      2954,
      2958,
      2960,
      2962,
      2965,
      2969,
      2970,
      2972,
      2972,
      2974,
      2975,
      2979,
      2980,
      2984,
      2986,
      2990,
      2997,
      2999,
      3001,
      3006,
      3010,
      3014,
      3016,
      3018,
      3021,
      3031,
      3031,
      3047,
      3055,
      3073,
      3075,
      3077,
      3084,
      3086,
      3088,
      3090,
      3112,
      3114,
      3123,
      3125,
      3129,
      3134,
      3140,
      3142,
      3144,
      3146,
      3149,
      3157,
      3158,
      3168,
      3169,
      3174,
      3183,
      3202,
      3203,
      3205,
      3212,
      3214,
      3216,
      3218,
      3240,
      3242,
      3251,
      3253,
      3257,
      3262,
      3268,
      3270,
      3272,
      3274,
      3277,
      3285,
      3286,
      3294,
      3294,
      3296,
      3297,
      3302,
      3311,
      3330,
      3331,
      3333,
      3340,
      3342,
      3344,
      3346,
      3368,
      3370,
      3385,
      3390,
      3395,
      3398,
      3400,
      3402,
      3405,
      3415,
      3415,
      3424,
      3425,
      3430,
      3439,
      3458,
      3459,
      3461,
      3478,
      3482,
      3505,
      3507,
      3515,
      3517,
      3517,
      3520,
      3526,
      3530,
      3530,
      3535,
      3540,
      3542,
      3542,
      3544,
      3551,
      3570,
      3571,
      3585,
      3642,
      3648,
      3662,
      3664,
      3673,
      3713,
      3714,
      3716,
      3716,
      3719,
      3720,
      3722,
      3722,
      3725,
      3725,
      3732,
      3735,
      3737,
      3743,
      3745,
      3747,
      3749,
      3749,
      3751,
      3751,
      3754,
      3755,
      3757,
      3769,
      3771,
      3773,
      3776,
      3780,
      3782,
      3782,
      3784,
      3789,
      3792,
      3801,
      3804,
      3805,
      3840,
      3840,
      3864,
      3865,
      3872,
      3881,
      3893,
      3893,
      3895,
      3895,
      3897,
      3897,
      3902,
      3911,
      3913,
      3946,
      3953,
      3972,
      3974,
      3979,
      3984,
      3991,
      3993,
      4028,
      4038,
      4038,
      4096,
      4129,
      4131,
      4135,
      4137,
      4138,
      4140,
      4146,
      4150,
      4153,
      4160,
      4169,
      4176,
      4185,
      4256,
      4293,
      4304,
      4342,
      4352,
      4441,
      4447,
      4514,
      4520,
      4601,
      4608,
      4614,
      4616,
      4678,
      4680,
      4680,
      4682,
      4685,
      4688,
      4694,
      4696,
      4696,
      4698,
      4701,
      4704,
      4742,
      4744,
      4744,
      4746,
      4749,
      4752,
      4782,
      4784,
      4784,
      4786,
      4789,
      4792,
      4798,
      4800,
      4800,
      4802,
      4805,
      4808,
      4814,
      4816,
      4822,
      4824,
      4846,
      4848,
      4878,
      4880,
      4880,
      4882,
      4885,
      4888,
      4894,
      4896,
      4934,
      4936,
      4954,
      4969,
      4977,
      5024,
      5108,
      5121,
      5740,
      5743,
      5750,
      5761,
      5786,
      5792,
      5866,
      6016,
      6099,
      6112,
      6121,
      6160,
      6169,
      6176,
      6263,
      6272,
      6313,
      7680,
      7835,
      7840,
      7929,
      7936,
      7957,
      7960,
      7965,
      7968,
      8005,
      8008,
      8013,
      8016,
      8023,
      8025,
      8025,
      8027,
      8027,
      8029,
      8029,
      8031,
      8061,
      8064,
      8116,
      8118,
      8124,
      8126,
      8126,
      8130,
      8132,
      8134,
      8140,
      8144,
      8147,
      8150,
      8155,
      8160,
      8172,
      8178,
      8180,
      8182,
      8188,
      8255,
      8256,
      8319,
      8319,
      8400,
      8412,
      8417,
      8417,
      8450,
      8450,
      8455,
      8455,
      8458,
      8467,
      8469,
      8469,
      8473,
      8477,
      8484,
      8484,
      8486,
      8486,
      8488,
      8488,
      8490,
      8493,
      8495,
      8497,
      8499,
      8505,
      8544,
      8579,
      12293,
      12295,
      12321,
      12335,
      12337,
      12341,
      12344,
      12346,
      12353,
      12436,
      12441,
      12442,
      12445,
      12446,
      12449,
      12542,
      12549,
      12588,
      12593,
      12686,
      12704,
      12727,
      13312,
      19893,
      19968,
      40869,
      40960,
      42124,
      44032,
      55203,
      63744,
      64045,
      64256,
      64262,
      64275,
      64279,
      64285,
      64296,
      64298,
      64310,
      64312,
      64316,
      64318,
      64318,
      64320,
      64321,
      64323,
      64324,
      64326,
      64433,
      64467,
      64829,
      64848,
      64911,
      64914,
      64967,
      65008,
      65019,
      65056,
      65059,
      65075,
      65076,
      65101,
      65103,
      65136,
      65138,
      65140,
      65140,
      65142,
      65276,
      65296,
      65305,
      65313,
      65338,
      65343,
      65343,
      65345,
      65370,
      65381,
      65470,
      65474,
      65479,
      65482,
      65487,
      65490,
      65495,
      65498,
      65500
    ];
  }
});

// node_modules/quicktype-core/dist/language/JavaScript.js
var require_JavaScript = __commonJS({
  "node_modules/quicktype-core/dist/language/JavaScript.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JavaScriptRenderer = exports.legalizeName = exports.JavaScriptTargetLanguage = exports.javaScriptOptions = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Converters_1 = require_Converters();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var TypeUtils_1 = require_TypeUtils();
    var JavaScriptUnicodeMaps_1 = require_JavaScriptUnicodeMaps();
    exports.javaScriptOptions = {
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      runtimeTypecheck: new RendererOptions_1.BooleanOption("runtime-typecheck", "Verify JSON.parse results at runtime", true),
      runtimeTypecheckIgnoreUnknownProperties: new RendererOptions_1.BooleanOption("runtime-typecheck-ignore-unknown-properties", "Ignore unknown properties when verifying at runtime", false, "secondary"),
      converters: (0, Converters_1.convertersOption)(),
      rawType: new RendererOptions_1.EnumOption("raw-type", "Type of raw input (json by default)", [
        ["json", "json"],
        ["any", "any"]
      ], "json", "secondary")
    };
    var JavaScriptTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor(displayName = "JavaScript", names = ["javascript", "js", "jsx"], extension = "js") {
        super(displayName, names, extension);
      }
      getOptions() {
        return [
          exports.javaScriptOptions.runtimeTypecheck,
          exports.javaScriptOptions.runtimeTypecheckIgnoreUnknownProperties,
          exports.javaScriptOptions.acronymStyle,
          exports.javaScriptOptions.converters,
          exports.javaScriptOptions.rawType
        ];
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("date-time", dateTimeType);
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsFullObjectType() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new JavaScriptRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.javaScriptOptions, untypedOptionValues));
      }
    };
    exports.JavaScriptTargetLanguage = JavaScriptTargetLanguage;
    exports.legalizeName = (0, Strings_1.utf16LegalizeCharacters)(JavaScriptUnicodeMaps_1.isES3IdentifierPart);
    var identityNamingFunction = (0, Naming_1.funPrefixNamer)("properties", (s) => s);
    var JavaScriptRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _jsOptions) {
        super(targetLanguage, renderContext);
        this._jsOptions = _jsOptions;
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(this._jsOptions.acronymStyle);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, exports.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", JavaScriptUnicodeMaps_1.isES3IdentifierStart);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return identityNamingFunction;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, true));
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNameForProperty(c, className, p, jsonName, _assignedName) {
        return super.makeNameForProperty(c, className, p, jsonName, void 0);
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      typeMapTypeFor(t) {
        if (["class", "object", "enum"].includes(t.kind)) {
          return ['r("', this.nameForNamedType(t), '")'];
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => '"any"', (_nullType) => "null", (_boolType) => "true", (_integerType) => "0", (_doubleType) => "3.14", (_stringType) => '""', (arrayType) => ["a(", this.typeMapTypeFor(arrayType.items), ")"], (_classType) => (0, Support_1.panic)("We handled this above"), (mapType) => ["m(", this.typeMapTypeFor(mapType.values), ")"], (_enumType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
          const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type));
          return ["u(", ...(0, collection_utils_1.arrayIntercalate)(", ", children), ")"];
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "Date";
          }
          return '""';
        });
      }
      typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        if (!p.isOptional) {
          return typeMap;
        }
        return ["u(undefined, ", typeMap, ")"];
      }
      emitBlock(source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
      }
      emitTypeMap() {
        const { any: anyAnnotation } = this.typeAnnotations;
        this.emitBlock(`const typeMap${anyAnnotation} = `, ";", () => {
          this.forEachObject("none", (t, name) => {
            const additionalProperties = t.getAdditionalProperties();
            const additional = additionalProperties !== void 0 ? this.typeMapTypeFor(additionalProperties) : "false";
            this.emitLine('"', name, '": o([');
            this.indent(() => {
              this.forEachClassProperty(t, "none", (propName, jsonName, property) => {
                this.emitLine('{ json: "', (0, Strings_1.utf16StringEscape)(jsonName), '", js: "', (0, Source_1.modifySource)(Strings_1.utf16StringEscape, propName), '", typ: ', this.typeMapTypeForProperty(property), " },");
              });
            });
            this.emitLine("], ", additional, "),");
          });
          this.forEachEnum("none", (e, name) => {
            this.emitLine('"', name, '": [');
            this.indent(() => {
              this.forEachEnumCase(e, "none", (_caseName, jsonName) => {
                this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}",`);
              });
            });
            this.emitLine("],");
          });
        });
      }
      deserializerFunctionName(name) {
        return ["to", name];
      }
      deserializerFunctionLine(_t, name) {
        return ["function ", this.deserializerFunctionName(name), "(json)"];
      }
      serializerFunctionName(name) {
        const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
        return [camelCaseName, "ToJson"];
      }
      serializerFunctionLine(_t, name) {
        return ["function ", this.serializerFunctionName(name), "(value)"];
      }
      get moduleLine() {
        return void 0;
      }
      get castFunctionLines() {
        return ["function cast(val, typ)", "function uncast(val, typ)"];
      }
      get typeAnnotations() {
        return {
          any: "",
          anyArray: "",
          anyMap: "",
          string: "",
          stringArray: "",
          boolean: "",
          never: ""
        };
      }
      emitConvertModuleBody() {
        const converter = (t, name) => {
          const typeMap = this.typeMapTypeFor(t);
          this.emitBlock([this.deserializerFunctionLine(t, name), " "], "", () => {
            const parsedJson = this._jsOptions.rawType === "json" ? "JSON.parse(json)" : "json";
            if (!this._jsOptions.runtimeTypecheck) {
              this.emitLine("return ", parsedJson, ";");
            } else {
              this.emitLine("return cast(", parsedJson, ", ", typeMap, ");");
            }
          });
          this.ensureBlankLine();
          this.emitBlock([this.serializerFunctionLine(t, name), " "], "", () => {
            if (this._jsOptions.rawType === "json") {
              if (!this._jsOptions.runtimeTypecheck) {
                this.emitLine("return JSON.stringify(value);");
              } else {
                this.emitLine("return JSON.stringify(uncast(value, ", typeMap, "), null, 2);");
              }
            } else {
              if (!this._jsOptions.runtimeTypecheck) {
                this.emitLine("return value;");
              } else {
                this.emitLine("return uncast(value, ", typeMap, ");");
              }
            }
          });
        };
        switch (this._jsOptions.converters) {
          case Converters_1.ConvertersOptions.AllObjects:
            this.forEachObject("interposing", converter);
            break;
          default:
            this.forEachTopLevel("interposing", converter);
            break;
        }
      }
      emitConvertModuleHelpers() {
        if (this._jsOptions.runtimeTypecheck) {
          const { any: anyAnnotation, anyArray: anyArrayAnnotation, anyMap: anyMapAnnotation, string: stringAnnotation, stringArray: stringArrayAnnotation, never: neverAnnotation } = this.typeAnnotations;
          this.ensureBlankLine();
          this.emitMultiline(`function invalidValue(typ${anyAnnotation}, val${anyAnnotation}, key${anyAnnotation}, parent${anyAnnotation} = '')${neverAnnotation} {
    const prettyTyp = prettyTypeName(typ);
    const parentText = parent ? \` on \${parent}\` : '';
    const keyText = key ? \` for key "\${key}"\` : '';
    throw Error(\`Invalid value\${keyText}\${parentText}. Expected \${prettyTyp} but got \${JSON.stringify(val)}\`);
}

function prettyTypeName(typ${anyAnnotation})${stringAnnotation} {
    if (Array.isArray(typ)) {
        if (typ.length === 2 && typ[0] === undefined) {
            return \`an optional \${prettyTypeName(typ[1])}\`;
        } else {
            return \`one of [\${typ.map(a => { return prettyTypeName(a); }).join(", ")}]\`;
        }
    } else if (typeof typ === "object" && typ.literal !== undefined) {
        return typ.literal;
    } else {
        return typeof typ;
    }
}

function jsonToJSProps(typ${anyAnnotation})${anyAnnotation} {
    if (typ.jsonToJS === undefined) {
        const map${anyAnnotation} = {};
        typ.props.forEach((p${anyAnnotation}) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ${anyAnnotation})${anyAnnotation} {
    if (typ.jsToJSON === undefined) {
        const map${anyAnnotation} = {};
        typ.props.forEach((p${anyAnnotation}) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val${anyAnnotation}, typ${anyAnnotation}, getProps${anyAnnotation}, key${anyAnnotation} = '', parent${anyAnnotation} = '')${anyAnnotation} {
    function transformPrimitive(typ${stringAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key, parent);
    }

    function transformUnion(typs${anyArrayAnnotation}, val${anyAnnotation})${anyAnnotation} {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val, key, parent);
    }

    function transformEnum(cases${stringArrayAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases.map(a => { return l(a); }), val, key, parent);
    }

    function transformArray(typ${anyAnnotation}, val${anyAnnotation})${anyAnnotation} {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(l("array"), val, key, parent);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val${anyAnnotation})${anyAnnotation} {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(l("Date"), val, key, parent);
        }
        return d;
    }

    function transformObject(props${anyMapAnnotation}, additional${anyAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (val === null || typeof val !== "object" || Array.isArray(val)) {
            return invalidValue(l(ref || "object"), val, key, parent);
        }
        const result${anyAnnotation} = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, key, ref);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = ${this._jsOptions.runtimeTypecheckIgnoreUnknownProperties ? "val[key]" : "transform(val[key], additional, getProps, key, ref)"};
            }
        });
        return result;
    }

    if (typ === "any") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val, key, parent);
    }
    if (typ === false) return invalidValue(typ, val, key, parent);
    let ref${anyAnnotation} = undefined;
    while (typeof typ === "object" && typ.ref !== undefined) {
        ref = typ.ref;
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty("props")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val, key, parent);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== "number") return transformDate(val);
    return transformPrimitive(typ, val);
}

${this.castFunctionLines[0]} {
    return transform(val, typ, jsonToJSProps);
}

${this.castFunctionLines[1]} {
    return transform(val, typ, jsToJSONProps);
}

function l(typ${anyAnnotation}) {
    return { literal: typ };
}

function a(typ${anyAnnotation}) {
    return { arrayItems: typ };
}

function u(...typs${anyArrayAnnotation}) {
    return { unionMembers: typs };
}

function o(props${anyArrayAnnotation}, additional${anyAnnotation}) {
    return { props, additional };
}

function m(additional${anyAnnotation}) {
    return { props: [], additional };
}

function r(name${stringAnnotation}) {
    return { ref: name };
}
`);
          this.emitTypeMap();
        }
      }
      emitConvertModule() {
        this.ensureBlankLine();
        this.emitMultiline(`// Converts JSON ${this._jsOptions.rawType === "json" ? "strings" : "types"} to/from your types`);
        if (this._jsOptions.runtimeTypecheck) {
          this.emitMultiline(`// and asserts the results${this._jsOptions.rawType === "json" ? " of JSON.parse" : ""} at runtime`);
        }
        const moduleLine = this.moduleLine;
        if (moduleLine === void 0) {
          this.emitConvertModuleBody();
        } else {
          this.emitBlock([moduleLine, " "], "", () => this.emitConvertModuleBody());
        }
      }
      emitTypes() {
        return;
      }
      emitUsageImportComment() {
        this.emitLine('//   const Convert = require("./file");');
      }
      emitUsageComments() {
        this.emitMultiline(`// To parse this data:
//`);
        this.emitUsageImportComment();
        this.emitLine("//");
        this.forEachTopLevel("none", (_t, name) => {
          const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
          this.emitLine("//   const ", camelCaseName, " = Convert.to", name, "(json);");
        });
        if (this._jsOptions.runtimeTypecheck) {
          this.emitLine("//");
          this.emitLine("// These functions will throw an error if the JSON doesn't");
          this.emitLine("// match the expected interface, even if the JSON is valid.");
        }
      }
      emitModuleExports() {
        this.ensureBlankLine();
        this.emitBlock("module.exports = ", ";", () => {
          this.forEachTopLevel("none", (_, name) => {
            const serializer = this.serializerFunctionName(name);
            const deserializer = this.deserializerFunctionName(name);
            this.emitLine('"', serializer, '": ', serializer, ",");
            this.emitLine('"', deserializer, '": ', deserializer, ",");
          });
        });
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageComments();
        }
        this.emitTypes();
        this.emitConvertModule();
        this.emitConvertModuleHelpers();
        this.emitModuleExports();
      }
    };
    exports.JavaScriptRenderer = JavaScriptRenderer;
  }
});

// node_modules/@glideapps/ts-necessities/dist/default-map.js
var require_default_map = __commonJS({
  "node_modules/@glideapps/ts-necessities/dist/default-map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultMap = void 0;
    var DefaultMap = class extends Map {
      /**
       *
       * @param _defaultFunc Must return the default value for key `k`.  Will only be called when necessary.
       * @param initKVPs An array of [key, value] arrays to initialize the map with.
       */
      constructor(_defaultFunc, initKVPs) {
        super(initKVPs);
        this._defaultFunc = _defaultFunc;
      }
      /**
       * Returns the value for `k`.  If `k` is not present, creates
       * the default value via [[_defaultFunc]], sets that default
       * as the value for `k` and returns it.
       */
      get(k) {
        let v = super.get(k);
        if (v === void 0) {
          if (this.has(k))
            return v;
          v = this._defaultFunc(k);
          this.set(k, v);
        }
        return v;
      }
      /**
       * Sets the value for `k` to `f(v)` where `v` is the previous
       * value for `k`, or the default if not present.  Returns the new
       * value.
       *
       * These two lines are equivalent:
       *
       * ```
       * m.set("foo", m.get("foo") + 1);
       * m.update("foo", x => x + 1);
       * ```
       */
      update(k, f) {
        const v = f(this.get(k));
        this.set(k, v);
        return v;
      }
    };
    exports.DefaultMap = DefaultMap;
  }
});

// node_modules/@glideapps/ts-necessities/dist/branded-strings.js
var require_branded_strings = __commonJS({
  "node_modules/@glideapps/ts-necessities/dist/branded-strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeBrandString = exports.brandString = void 0;
    function brandString(s) {
      return s;
    }
    exports.brandString = brandString;
    function makeBrandString() {
      return brandString;
    }
    exports.makeBrandString = makeBrandString;
  }
});

// node_modules/@glideapps/ts-necessities/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@glideapps/ts-necessities/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeBrandString = exports.brandString = exports.DefaultMap = exports.exceptionToError = exports.exceptionToString = exports.filterUndefined = exports.mapFilterUndefined = exports.hasOwnProperty = exports.isArray = exports.isEnumValue = exports.definedMap = exports.reduceTwo = exports.sleep = exports.dontAwait = exports.defined = exports.assertNever = exports.assert = exports.panic = exports.proveNever = exports.proveType = void 0;
    function proveType(_val) {
    }
    exports.proveType = proveType;
    function proveNever(_never, message, result) {
      console.trace(message);
      return result;
    }
    exports.proveNever = proveNever;
    function panic(message = "This should not happen") {
      console.trace(message);
      debugger;
      throw new Error(message);
    }
    exports.panic = panic;
    function assert(fact, message = "Assertion failed") {
      if (fact)
        return;
      return panic(message);
    }
    exports.assert = assert;
    function assertNever(_never, message = "`never` happened") {
      return panic(message);
    }
    exports.assertNever = assertNever;
    function defined(v, reason) {
      if (v === void 0) {
        return panic("Value was undefined but should be defined" + (reason !== void 0 ? ` because: ${reason}` : ""));
      }
      return v;
    }
    exports.defined = defined;
    function dontAwait(p) {
      if (!(p instanceof Promise))
        return;
      p.catch((e) => {
        console.trace("Unhandled error from unawaited promise", e);
        throw e;
      });
    }
    exports.dontAwait = dontAwait;
    function sleep(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
    exports.sleep = sleep;
    function reduceTwo(a, b, f) {
      if (a === void 0)
        return b;
      if (b === void 0)
        return a;
      return f(a, b);
    }
    exports.reduceTwo = reduceTwo;
    function definedMap(x, f) {
      if (x === void 0)
        return void 0;
      return f(x);
    }
    exports.definedMap = definedMap;
    function isEnumValue(e, x) {
      return Object.keys(e).map((k) => e[k]).some((v) => v === x);
    }
    exports.isEnumValue = isEnumValue;
    function isArray(x) {
      return Array.isArray(x);
    }
    exports.isArray = isArray;
    function hasOwnProperty(obj, name) {
      if (obj === void 0 || obj === null)
        return false;
      return Object.prototype.hasOwnProperty.call(obj, name);
    }
    exports.hasOwnProperty = hasOwnProperty;
    function mapFilterUndefined(iterable, f) {
      const result = [];
      let i = 0;
      for (const x of iterable) {
        const y = f(x, i);
        i += 1;
        if (y === void 0)
          continue;
        result.push(y);
      }
      return result;
    }
    exports.mapFilterUndefined = mapFilterUndefined;
    function filterUndefined(arr) {
      const result = [];
      for (const x of arr) {
        if (x !== void 0) {
          result.push(x);
        }
      }
      return result;
    }
    exports.filterUndefined = filterUndefined;
    function exceptionToString(e) {
      if (e === void 0)
        return "";
      try {
        return e.toString();
      } catch (f) {
        try {
          return `Exception can't be stringified: ${exceptionToString(f)}`;
        } catch (_a) {
          return "Exception can't be stringified";
        }
      }
    }
    exports.exceptionToString = exceptionToString;
    function exceptionToError(e) {
      if (e instanceof Error) {
        return e;
      } else {
        return new Error(exceptionToString(e));
      }
    }
    exports.exceptionToError = exceptionToError;
    var default_map_1 = require_default_map();
    Object.defineProperty(exports, "DefaultMap", { enumerable: true, get: function() {
      return default_map_1.DefaultMap;
    } });
    var branded_strings_1 = require_branded_strings();
    Object.defineProperty(exports, "brandString", { enumerable: true, get: function() {
      return branded_strings_1.brandString;
    } });
    Object.defineProperty(exports, "makeBrandString", { enumerable: true, get: function() {
      return branded_strings_1.makeBrandString;
    } });
  }
});

// node_modules/quicktype-core/dist/language/JavaScriptPropTypes.js
var require_JavaScriptPropTypes = __commonJS({
  "node_modules/quicktype-core/dist/language/JavaScriptPropTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JavaScriptPropTypesRenderer = exports.JavaScriptPropTypesTargetLanguage = exports.javaScriptPropTypesOptions = void 0;
    var ts_necessities_1 = require_dist2();
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var Converters_1 = require_Converters();
    var Strings_1 = require_Strings();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var JavaScript_1 = require_JavaScript();
    var JavaScriptUnicodeMaps_1 = require_JavaScriptUnicodeMaps();
    exports.javaScriptPropTypesOptions = {
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      converters: (0, Converters_1.convertersOption)(),
      moduleSystem: new RendererOptions_1.EnumOption("module-system", "Which module system to use", [
        ["common-js", false],
        ["es6", true]
      ], "es6")
    };
    var JavaScriptPropTypesTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      getOptions() {
        return [exports.javaScriptPropTypesOptions.acronymStyle, exports.javaScriptPropTypesOptions.converters];
      }
      constructor(displayName = "JavaScript PropTypes", names = ["javascript-prop-types"], extension = "js") {
        super(displayName, names, extension);
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new JavaScriptPropTypesRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.javaScriptPropTypesOptions, untypedOptionValues));
      }
    };
    exports.JavaScriptPropTypesTargetLanguage = JavaScriptPropTypesTargetLanguage;
    var identityNamingFunction = (0, Naming_1.funPrefixNamer)("properties", (s) => s);
    var JavaScriptPropTypesRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _jsOptions) {
        super(targetLanguage, renderContext);
        this._jsOptions = _jsOptions;
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(this._jsOptions.acronymStyle);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, JavaScript_1.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", JavaScriptUnicodeMaps_1.isES3IdentifierStart);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return identityNamingFunction;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, false));
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNameForProperty(c, className, p, jsonName, _assignedName) {
        return super.makeNameForProperty(c, className, p, jsonName, void 0);
      }
      typeMapTypeFor(t, required = true) {
        if (["class", "object", "enum"].includes(t.kind)) {
          return ["_", this.nameForNamedType(t)];
        }
        const match = (0, TypeUtils_1.matchType)(t, (_anyType) => "PropTypes.any", (_nullType) => "PropTypes.any", (_boolType) => "PropTypes.bool", (_integerType) => "PropTypes.number", (_doubleType) => "PropTypes.number", (_stringType) => "PropTypes.string", (arrayType) => ["PropTypes.arrayOf(", this.typeMapTypeFor(arrayType.items, false), ")"], (_classType) => (0, ts_necessities_1.panic)("Should already be handled."), (_mapType) => "PropTypes.object", (_enumType) => (0, ts_necessities_1.panic)("Should already be handled."), (unionType) => {
          const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
          return ["PropTypes.oneOfType([", ...(0, collection_utils_1.arrayIntercalate)(", ", children), "])"];
        }, (_transformedStringType) => {
          return "PropTypes.string";
        });
        if (required) {
          return [match];
        }
        return match;
      }
      typeMapTypeForProperty(p) {
        return this.typeMapTypeFor(p.type);
      }
      importStatement(lhs, moduleName) {
        if (this._jsOptions.moduleSystem) {
          return ["import ", lhs, " from ", moduleName, ";"];
        } else {
          return ["const ", lhs, " = require(", moduleName, ");"];
        }
      }
      emitUsageComments() {
        this.emitCommentLines([
          "Example usage:",
          "",
          this.importStatement("{ MyShape }", "./myShape.js"),
          "",
          "class MyComponent extends React.Component {",
          "  //",
          "}",
          "",
          "MyComponent.propTypes = {",
          "  input: MyShape",
          "};"
        ], { lineStart: "// " });
      }
      emitBlock(source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
      }
      emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("PropTypes", '"prop-types"'));
      }
      emitExport(name, value) {
        if (this._jsOptions.moduleSystem) {
          this.emitLine("export const ", name, " = ", value, ";");
        } else {
          this.emitLine("module.exports = exports = { ", name, ": ", value, " };");
        }
      }
      emitTypes() {
        this.ensureBlankLine();
        this.forEachObject("none", (_type, name) => {
          this.emitLine("let _", name, ";");
        });
        this.forEachEnum("none", (enumType, enumName) => {
          const options = [];
          this.forEachEnumCase(enumType, "none", (name, _jsonName, _position) => {
            options.push("'");
            options.push(name);
            options.push("'");
            options.push(", ");
          });
          options.pop();
          this.emitLine(["const _", enumName, " = PropTypes.oneOfType([", ...options, "]);"]);
        });
        const order = [];
        const mapKey = [];
        const mapValue = [];
        this.forEachObject("none", (type, name) => {
          mapKey.push(name);
          mapValue.push(this.gatherSource(() => this.emitObject(name, type)));
        });
        mapKey.forEach((_, index) => {
          let ordinal = 0;
          const source = mapValue[index];
          const names = source.filter((value) => value);
          names.forEach((name) => {
            const depName = name;
            order.forEach((orderItem) => {
              const depIndex = orderItem;
              if (mapKey[depIndex] === depName) {
                ordinal = Math.max(ordinal, depIndex + 1);
              }
            });
          });
          order.splice(ordinal, 0, index);
        });
        order.forEach((i) => this.emitGatheredSource(mapValue[i]));
        this.forEachTopLevel("none", (type, name) => {
          if (type instanceof Type_1.PrimitiveType) {
            this.ensureBlankLine();
            this.emitExport(name, this.typeMapTypeFor(type));
          } else {
            if (type.kind === "array") {
              this.ensureBlankLine();
              this.emitExport(name, ["PropTypes.arrayOf(", this.typeMapTypeFor(type.items), ")"]);
            } else {
              this.ensureBlankLine();
              this.emitExport(name, ["_", name]);
            }
          }
        });
      }
      emitObject(name, t) {
        this.ensureBlankLine();
        this.emitLine("_", name, " = PropTypes.shape({");
        this.indent(() => {
          this.forEachClassProperty(t, "none", (_, jsonName, property) => {
            this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
          });
        });
        this.emitLine("});");
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageComments();
        }
        this.emitImports();
        this.emitTypes();
      }
    };
    exports.JavaScriptPropTypesRenderer = JavaScriptPropTypesRenderer;
  }
});

// node_modules/quicktype-core/dist/language/JSONSchema.js
var require_JSONSchema = __commonJS({
  "node_modules/quicktype-core/dist/language/JSONSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONSchemaRenderer = exports.JSONSchemaTargetLanguage = void 0;
    var collection_utils_1 = require_dist();
    var Description_1 = require_Description();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeBuilder_1 = require_TypeBuilder();
    var TypeUtils_1 = require_TypeUtils();
    var JSONSchemaTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("JSON Schema", ["schema", "json-schema"], "schema");
      }
      getOptions() {
        return [];
      }
      get stringTypeMapping() {
        return (0, TypeBuilder_1.getNoStringTypeMapping)();
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsFullObjectType() {
        return true;
      }
      makeRenderer(renderContext, _untypedOptionValues) {
        return new JSONSchemaRenderer(this, renderContext);
      }
    };
    exports.JSONSchemaTargetLanguage = JSONSchemaTargetLanguage;
    var namingFunction = (0, Naming_1.funPrefixNamer)("namer", jsonNameStyle);
    var legalizeName = (0, Strings_1.legalizeCharacters)(
      (cp) => cp >= 32 && cp < 128 && cp !== 47
      /* slash */
    );
    function jsonNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", (_) => true);
    }
    var JSONSchemaRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      makeNamedTypeNamer() {
        return namingFunction;
      }
      namerForObjectProperty() {
        return null;
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return null;
      }
      nameForType(t) {
        return (0, Support_1.defined)(this.names.get(this.nameForNamedType(t)));
      }
      makeOneOf(types) {
        const first = (0, collection_utils_1.iterableFirst)(types);
        if (first === void 0) {
          return (0, Support_1.panic)("Must have at least one type for oneOf");
        }
        if (types.size === 1) {
          return this.schemaForType(first);
        }
        return { anyOf: Array.from(types).map((t) => this.schemaForType(t)) };
      }
      makeRef(t) {
        return { $ref: `#/definitions/${this.nameForType(t)}` };
      }
      addAttributesToSchema(t, schema4) {
        const attributes = this.typeGraph.attributeStore.attributesForType(t);
        for (const [kind, attr] of attributes) {
          kind.addToSchema(schema4, t, attr);
        }
      }
      schemaForType(t) {
        const schema4 = (0, TypeUtils_1.matchTypeExhaustive)(t, (_noneType) => {
          return (0, Support_1.panic)("none type should have been replaced");
        }, (_anyType) => ({}), (_nullType) => ({ type: "null" }), (_boolType) => ({ type: "boolean" }), (_integerType) => ({ type: "integer" }), (_doubleType) => ({ type: "number" }), (_stringType) => ({ type: "string" }), (arrayType) => ({ type: "array", items: this.schemaForType(arrayType.items) }), (classType) => this.makeRef(classType), (mapType) => this.definitionForObject(mapType, void 0), (objectType) => this.makeRef(objectType), (enumType) => this.makeRef(enumType), (unionType) => {
          if (this.unionNeedsName(unionType)) {
            return this.makeRef(unionType);
          } else {
            return this.definitionForUnion(unionType);
          }
        }, (transformedStringType) => {
          const target = Type_1.transformedStringTypeTargetTypeKindsMap.get(transformedStringType.kind);
          if (target === void 0) {
            return (0, Support_1.panic)(`Unknown transformed string type ${transformedStringType.kind}`);
          }
          return { type: "string", format: target.jsonSchema };
        });
        if (schema4.$ref === void 0) {
          this.addAttributesToSchema(t, schema4);
        }
        return schema4;
      }
      definitionForObject(o, title) {
        let properties;
        let required;
        if (o.getProperties().size === 0) {
          properties = void 0;
          required = void 0;
        } else {
          const props = {};
          const req = [];
          for (const [name, p] of o.getProperties()) {
            const prop = this.schemaForType(p.type);
            if (prop.description === void 0) {
              (0, Description_1.addDescriptionToSchema)(prop, this.descriptionForClassProperty(o, name));
            }
            props[name] = prop;
            if (!p.isOptional) {
              req.push(name);
            }
          }
          properties = props;
          required = req.sort();
        }
        const additional = o.getAdditionalProperties();
        const additionalProperties = additional !== void 0 ? this.schemaForType(additional) : false;
        const schema4 = {
          type: "object",
          additionalProperties,
          properties,
          required,
          title
        };
        this.addAttributesToSchema(o, schema4);
        return schema4;
      }
      definitionForUnion(u, title) {
        const oneOf = this.makeOneOf(u.sortedMembers);
        if (title !== void 0) {
          oneOf.title = title;
        }
        this.addAttributesToSchema(u, oneOf);
        return oneOf;
      }
      definitionForEnum(e, title) {
        const schema4 = { type: "string", enum: Array.from(e.cases), title };
        this.addAttributesToSchema(e, schema4);
        return schema4;
      }
      emitSourceStructure() {
        const topLevelType = this.topLevels.size === 1 ? this.schemaForType((0, Support_1.defined)((0, collection_utils_1.mapFirst)(this.topLevels))) : {};
        const schema4 = Object.assign({ $schema: "http://json-schema.org/draft-06/schema#" }, topLevelType);
        const definitions = {};
        this.forEachObject("none", (o, name) => {
          const title = (0, Support_1.defined)(this.names.get(name));
          definitions[title] = this.definitionForObject(o, title);
        });
        this.forEachUnion("none", (u, name) => {
          if (!this.unionNeedsName(u))
            return;
          const title = (0, Support_1.defined)(this.names.get(name));
          definitions[title] = this.definitionForUnion(u, title);
        });
        this.forEachEnum("none", (e, name) => {
          const title = (0, Support_1.defined)(this.names.get(name));
          definitions[title] = this.definitionForEnum(e, title);
        });
        schema4.definitions = definitions;
        this.emitMultiline(JSON.stringify(schema4, void 0, "    "));
      }
    };
    exports.JSONSchemaRenderer = JSONSchemaRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Kotlin.js
var require_Kotlin = __commonJS({
  "node_modules/quicktype-core/dist/language/Kotlin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KotlinXRenderer = exports.KotlinJacksonRenderer = exports.KotlinKlaxonRenderer = exports.KotlinRenderer = exports.KotlinTargetLanguage = exports.kotlinOptions = exports.Framework = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var Framework;
    (function(Framework2) {
      Framework2["None"] = "None";
      Framework2["Jackson"] = "Jackson";
      Framework2["Klaxon"] = "Klaxon";
      Framework2["KotlinX"] = "KotlinX";
    })(Framework = exports.Framework || (exports.Framework = {}));
    exports.kotlinOptions = {
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", [
        ["just-types", Framework.None],
        ["jackson", Framework.Jackson],
        ["klaxon", Framework.Klaxon],
        ["kotlinx", Framework.KotlinX]
      ], "klaxon"),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      packageName: new RendererOptions_1.StringOption("package", "Package", "PACKAGE", "quicktype")
    };
    var KotlinTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Kotlin", ["kotlin"], "kt");
      }
      getOptions() {
        return [exports.kotlinOptions.framework, exports.kotlinOptions.acronymStyle, exports.kotlinOptions.packageName];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.kotlinOptions, untypedOptionValues);
        switch (options.framework) {
          case Framework.None:
            return new KotlinRenderer(this, renderContext, options);
          case Framework.Jackson:
            return new KotlinJacksonRenderer(this, renderContext, options);
          case Framework.Klaxon:
            return new KotlinKlaxonRenderer(this, renderContext, options);
          case Framework.KotlinX:
            return new KotlinXRenderer(this, renderContext, options);
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.KotlinTargetLanguage = KotlinTargetLanguage;
    var keywords = [
      "package",
      "as",
      "typealias",
      "class",
      "this",
      "super",
      "val",
      "var",
      "fun",
      "for",
      "null",
      "true",
      "false",
      "is",
      "in",
      "throw",
      "return",
      "break",
      "continue",
      "object",
      "if",
      "try",
      "else",
      "while",
      "do",
      "when",
      "interface",
      "typeof",
      "klaxon",
      "toJson",
      "Any",
      "Boolean",
      "Double",
      "Float",
      "Long",
      "Int",
      "Short",
      "System",
      "Byte",
      "String",
      "Array",
      "List",
      "Map",
      "Enum",
      "Class",
      "JsonObject",
      "JsonValue",
      "Converter",
      "Klaxon"
    ];
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function kotlinNameStyle(isUpper, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, "", isStartCharacter);
    }
    function unicodeEscape(codePoint) {
      return "\\u" + (0, Strings_1.intToHex)(codePoint, 4);
    }
    var _stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
    function stringEscape(s) {
      return _stringEscape(s).replace(/\$/g, "\\$");
    }
    var KotlinRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext);
        this._kotlinOptions = _kotlinOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords;
      }
      forbiddenForObjectProperties(_o, _classNamed) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
      }
      topLevelNameStyle(rawName) {
        return kotlinNameStyle(true, rawName);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => kotlinNameStyle(true, s, (0, Acronyms_1.acronymStyle)(this._kotlinOptions.acronymStyle)));
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("lower", (s) => kotlinNameStyle(false, s, (0, Acronyms_1.acronymStyle)(this._kotlinOptions.acronymStyle)));
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => kotlinNameStyle(true, s) + "Value");
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => kotlinNameStyle(true, s, (0, Acronyms_1.acronymStyle)(this._kotlinOptions.acronymStyle)));
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? ["{", "}"] : delimiter === "paren" ? ["(", ")"] : ["{", "})"];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
      }
      anySourceType(optional) {
        return ["Any", optional];
      }
      // (asarazan): I've broken out the following two functions
      // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
      arrayType(arrayType, withIssues = false, _noOptional = false) {
        return ["List<", this.kotlinType(arrayType.items, withIssues), ">"];
      }
      mapType(mapType, withIssues = false, _noOptional = false) {
        return ["Map<String, ", this.kotlinType(mapType.values, withIssues), ">"];
      }
      kotlinType(t, withIssues = false, noOptional = false) {
        const optional = noOptional ? "" : "?";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.anySourceType(optional));
        }, (_nullType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.anySourceType(optional));
        }, (_boolType) => "Boolean", (_integerType) => "Long", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => this.arrayType(arrayType, withIssues), (classType) => this.nameForNamedType(classType), (mapType) => this.mapType(mapType, withIssues), (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return [this.kotlinType(nullable, withIssues), optional];
          return this.nameForNamedType(unionType);
        });
      }
      emitUsageHeader() {
      }
      emitHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine("package ", this._kotlinOptions.packageName);
        this.ensureBlankLine();
      }
      emitTopLevelPrimitive(t, name) {
        const elementType = this.kotlinType(t);
        this.emitLine(["typealias ", name, " = ", elementType, ""]);
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitLine(["typealias ", name, " = ArrayList<", elementType, ">"]);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitLine(["typealias ", name, " = HashMap<String, ", elementType, ">"]);
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAnnotations(c, className);
        this.emitLine("class ", className, "()");
      }
      emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
          this.emitEmptyClassDefinition(c, className);
          return;
        }
        const kotlinType = (p) => {
          if (p.isOptional) {
            return [this.kotlinType(p.type, true, true), "?"];
          } else {
            return this.kotlinType(p.type, true);
          }
        };
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAnnotations(c, className);
        this.emitLine("data class ", className, " (");
        this.indent(() => {
          let count = c.getProperties().size;
          let first = true;
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const nullable = p.type.kind === "union" && (0, TypeUtils_1.nullableFromUnion)(p.type) !== null;
            const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
            const last = --count === 0;
            let meta = [];
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== void 0) {
              meta.push(() => this.emitDescription(description));
            }
            this.renameAttribute(name, jsonName, !nullableOrOptional, meta);
            if (meta.length > 0 && !first) {
              this.ensureBlankLine();
            }
            for (const emit of meta) {
              emit();
            }
            this.emitLine("val ", name, ": ", kotlinType(p), nullableOrOptional ? " = null" : "", last ? "" : ",");
            if (meta.length > 0 && !last) {
              this.ensureBlankLine();
            }
            first = false;
          });
        });
        this.emitClassDefinitionMethods(c, className);
      }
      emitClassDefinitionMethods(_c, _className) {
        this.emitLine(")");
      }
      emitClassAnnotations(_c, _className) {
      }
      renameAttribute(_name, _jsonName, _required, _meta) {
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum class ", enumName], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name) => {
            this.emitLine(name, --count === 0 ? "" : ",");
          });
        });
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class")
            return kind;
          return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        this.emitClassAnnotations(u, unionName);
        this.emitBlock(["sealed class ", unionName], () => {
          {
            let table = [];
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              table.push([
                ["class ", name, "(val value: ", this.kotlinType(t), ")"],
                [" : ", unionName, "()"]
              ]);
            });
            if (maybeNull !== null) {
              table.push([
                ["class ", this.nameForUnionMember(u, maybeNull), "()"],
                [" : ", unionName, "()"]
              ]);
            }
            this.emitTable(table);
          }
          this.emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName);
        });
      }
      emitUnionDefinitionMethods(_u, _nonNulls, _maybeNull, _unionName) {
      }
      emitSourceStructure() {
        this.emitHeader();
        this.forEachTopLevel("leading", (t, name) => {
          if (t instanceof Type_1.ArrayType) {
            this.emitTopLevelArray(t, name);
          } else if (t instanceof Type_1.MapType) {
            this.emitTopLevelMap(t, name);
          } else if (t.isPrimitive()) {
            this.emitTopLevelPrimitive(t, name);
          }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.KotlinRenderer = KotlinRenderer;
    var KotlinKlaxonRenderer = class extends KotlinRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
      }
      unionMemberFromJsonValue(t, e) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => [e, ".inside"], (_nullType) => "null", (_boolType) => [e, ".boolean"], (_integerType) => ["(", e, ".int?.toLong() ?: ", e, ".longValue)"], (_doubleType) => [e, ".double"], (_stringType) => [e, ".string"], (arrayType) => [e, ".array?.let { klaxon.parseFromJsonArray<", this.kotlinType(arrayType.items), ">(it) }"], (_classType) => [e, ".obj?.let { klaxon.parseFromJsonObject<", this.kotlinType(t), ">(it) }"], (_mapType) => [e, ".obj?.let { klaxon.parseFromJsonObject<", this.kotlinType(t), ">(it) }"], (enumType) => [e, ".string?.let { ", this.kotlinType(enumType), ".fromValue(it) }"], (_unionType) => (0, Support_1.mustNotHappen)());
      }
      unionMemberJsonValueGuard(t, _e) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => "is Any",
          (_nullType) => "null",
          (_boolType) => "is Boolean",
          (_integerType) => "is Int, is Long",
          (_doubleType) => "is Double",
          (_stringType) => "is String",
          (_arrayType) => "is JsonArray<*>",
          // These could be stricter, but for now we don't allow maps
          // and objects in the same union
          (_classType) => "is JsonObject",
          (_mapType) => "is JsonObject",
          // This could be stricter, but for now we don't allow strings
          // and enums in the same union
          (_enumType) => "is String",
          (_unionType) => (0, Support_1.mustNotHappen)()
        );
      }
      emitUsageHeader() {
        this.emitLine("// To parse the JSON, install Klaxon and do:");
        this.emitLine("//");
        this.forEachTopLevel("none", (_, name) => {
          this.emitLine("//   val ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = ", name, ".fromJson(jsonString)");
        });
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import com.beust.klaxon.*");
        const hasUnions = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (t) => t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) === null);
        const hasEmptyObjects = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (c) => c instanceof Type_1.ClassType && c.getProperties().size === 0);
        if (hasUnions || this.haveEnums || hasEmptyObjects) {
          this.emitGenericConverter();
        }
        let converters = [];
        if (hasEmptyObjects) {
          converters.push([[".convert(JsonObject::class,"], [" { it.obj!! },"], [" { it.toJsonString() })"]]);
        }
        this.forEachEnum("none", (_, name) => {
          converters.push([
            [".convert(", name, "::class,"],
            [" { ", name, ".fromValue(it.string!!) },"],
            [' { "\\"${it.value}\\"" })']
          ]);
        });
        this.forEachUnion("none", (_, name) => {
          converters.push([
            [".convert(", name, "::class,"],
            [" { ", name, ".fromJson(it) },"],
            [" { it.toJson() }, true)"]
          ]);
        });
        this.ensureBlankLine();
        this.emitLine("private val klaxon = Klaxon()");
        if (converters.length > 0) {
          this.indent(() => this.emitTable(converters));
        }
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitBlock(["class ", name, "(elements: Collection<", elementType, ">) : ArrayList<", elementType, ">(elements)"], () => {
          this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitLine("public fun fromJson(json: String) = ", name, "(klaxon.parseArray<", elementType, ">(json)!!)");
          });
        });
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitBlock([
          "class ",
          name,
          "(elements: Map<String, ",
          elementType,
          ">) : HashMap<String, ",
          elementType,
          ">(elements)"
        ], () => {
          this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitBlock(["public fun fromJson(json: String) = ", name], () => {
              this.emitLine("klaxon.parseJsonObject(java.io.StringReader(json)) as Map<String, ", elementType, ">");
            }, "paren");
          });
        });
      }
      klaxonRenameAttribute(propName, jsonName, ignore = false) {
        const escapedName = stringEscape(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        const properties = [];
        if (namesDiffer) {
          properties.push(['name = "', escapedName, '"']);
        }
        if (ignore) {
          properties.push("ignored = true");
        }
        return properties.length === 0 ? void 0 : ["@Json(", (0, collection_utils_1.arrayIntercalate)(", ", properties), ")"];
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("typealias ", className, " = JsonObject");
      }
      emitClassDefinitionMethods(c, className) {
        const isTopLevel = (0, collection_utils_1.iterableSome)(this.topLevels, ([_, top]) => top === c);
        if (isTopLevel) {
          this.emitBlock(")", () => {
            this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
              this.emitLine("public fun fromJson(json: String) = klaxon.parse<", className, ">(json)");
            });
          });
        } else {
          this.emitLine(")");
        }
      }
      renameAttribute(name, jsonName, _required, meta) {
        const rename = this.klaxonRenameAttribute(name, jsonName);
        if (rename !== void 0) {
          meta.push(() => this.emitLine(rename));
        }
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum class ", enumName, "(val value: String)"], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name, json) => {
            this.emitLine(name, `("${stringEscape(json)}")`, --count === 0 ? ";" : ",");
          });
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitBlock(["public fun fromValue(value: String): ", enumName, " = when (value)"], () => {
              let table = [];
              this.forEachEnumCase(e, "none", (name, json) => {
                table.push([[`"${stringEscape(json)}"`], [" -> ", name]]);
              });
              table.push([["else"], [" -> throw IllegalArgumentException()"]]);
              this.emitTable(table);
            });
          });
        });
      }
      emitGenericConverter() {
        this.ensureBlankLine();
        this.emitLine("private fun <T> Klaxon.convert(k: kotlin.reflect.KClass<*>, fromJson: (JsonValue) -> T, toJson: (T) -> String, isUnion: Boolean = false) =");
        this.indent(() => {
          this.emitLine("this.converter(object: Converter {");
          this.indent(() => {
            this.emitLine('@Suppress("UNCHECKED_CAST")');
            this.emitTable([
              ["override fun toJson(value: Any)", " = toJson(value as T)"],
              ["override fun fromJson(jv: JsonValue)", " = fromJson(jv) as Any"],
              [
                "override fun canConvert(cls: Class<*>)",
                " = cls == k.java || (isUnion && cls.superclass == k.java)"
              ]
            ]);
          });
          this.emitLine("})");
        });
      }
      emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName) {
        this.ensureBlankLine();
        this.emitLine("public fun toJson(): String = klaxon.toJsonString(when (this) {");
        this.indent(() => {
          let toJsonTable = [];
          this.forEachUnionMember(u, nonNulls, "none", null, (name) => {
            toJsonTable.push([["is ", name], [" -> this.value"]]);
          });
          if (maybeNull !== null) {
            const name = this.nameForUnionMember(u, maybeNull);
            toJsonTable.push([["is ", name], [' -> "null"']]);
          }
          this.emitTable(toJsonTable);
        });
        this.emitLine("})");
        this.ensureBlankLine();
        this.emitBlock("companion object", () => {
          this.emitLine("public fun fromJson(jv: JsonValue): ", unionName, " = when (jv.inside) {");
          this.indent(() => {
            let table = [];
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              table.push([
                [this.unionMemberJsonValueGuard(t, "jv.inside")],
                [" -> ", name, "(", this.unionMemberFromJsonValue(t, "jv"), "!!)"]
              ]);
            });
            if (maybeNull !== null) {
              const name = this.nameForUnionMember(u, maybeNull);
              table.push([[this.unionMemberJsonValueGuard(maybeNull, "jv.inside")], [" -> ", name, "()"]]);
            }
            table.push([["else"], [" -> throw IllegalArgumentException()"]]);
            this.emitTable(table);
          });
          this.emitLine("}");
        });
      }
    };
    exports.KotlinKlaxonRenderer = KotlinKlaxonRenderer;
    var KotlinJacksonRenderer = class extends KotlinRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
      }
      unionMemberJsonValueGuard(t, _e) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => "is Any",
          (_nullType) => "null",
          (_boolType) => "is BooleanNode",
          (_integerType) => "is IntNode, is LongNode",
          (_doubleType) => "is DoubleNode",
          (_stringType) => "is TextNode",
          (_arrayType) => "is ArrayNode",
          // These could be stricter, but for now we don't allow maps
          // and objects in the same union
          (_classType) => "is ObjectNode",
          (_mapType) => "is ObjectNode",
          // This could be stricter, but for now we don't allow strings
          // and enums in the same union
          (_enumType) => "is TextNode",
          (_unionType) => (0, Support_1.mustNotHappen)()
        );
      }
      emitUsageHeader() {
        this.emitLine("// To parse the JSON, install jackson-module-kotlin and do:");
        this.emitLine("//");
        this.forEachTopLevel("none", (_, name) => {
          this.emitLine("//   val ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = ", name, ".fromJson(jsonString)");
        });
      }
      emitHeader() {
        super.emitHeader();
        this.emitMultiline(`import com.fasterxml.jackson.annotation.*
import com.fasterxml.jackson.core.*
import com.fasterxml.jackson.databind.*
import com.fasterxml.jackson.databind.deser.std.StdDeserializer
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.databind.node.*
import com.fasterxml.jackson.databind.ser.std.StdSerializer
import com.fasterxml.jackson.module.kotlin.*`);
        const hasUnions = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (t) => t instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(t) === null);
        const hasEmptyObjects = (0, collection_utils_1.iterableSome)(this.typeGraph.allNamedTypes(), (c) => c instanceof Type_1.ClassType && c.getProperties().size === 0);
        if (hasUnions || this.haveEnums || hasEmptyObjects) {
          this.emitGenericConverter();
        }
        let converters = [];
        this.forEachEnum("none", (_, name) => {
          converters.push([
            ["convert(", name, "::class,"],
            [" { ", name, ".fromValue(it.asText()) },"],
            [' { "\\"${it.value}\\"" })']
          ]);
        });
        this.forEachUnion("none", (_, name) => {
          converters.push([
            ["convert(", name, "::class,"],
            [" { ", name, ".fromJson(it) },"],
            [" { it.toJson() }, true)"]
          ]);
        });
        this.ensureBlankLine();
        this.emitLine("val mapper = jacksonObjectMapper().apply {");
        this.indent(() => {
          this.emitLine("propertyNamingStrategy = PropertyNamingStrategy.LOWER_CAMEL_CASE");
          this.emitLine("setSerializationInclusion(JsonInclude.Include.NON_NULL)");
        });
        if (converters.length > 0) {
          this.indent(() => this.emitTable(converters));
        }
        this.emitLine("}");
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitBlock(["class ", name, "(elements: Collection<", elementType, ">) : ArrayList<", elementType, ">(elements)"], () => {
          this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitLine("fun fromJson(json: String) = mapper.readValue<", name, ">(json)");
          });
        });
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitBlock([
          "class ",
          name,
          "(elements: Map<String, ",
          elementType,
          ">) : HashMap<String, ",
          elementType,
          ">(elements)"
        ], () => {
          this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitLine("fun fromJson(json: String) = mapper.readValue<", name, ">(json)");
          });
        });
      }
      jacksonRenameAttribute(propName, jsonName, required, ignore = false) {
        const escapedName = stringEscape(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        const properties = [];
        const isPrefixBool = jsonName.startsWith("is");
        const propertyOpts = [];
        if (namesDiffer || isPrefixBool) {
          propertyOpts.push('"' + escapedName + '"');
        }
        if (required) {
          propertyOpts.push("required=true");
        }
        if (propertyOpts.length > 0) {
          properties.push(["@get:JsonProperty(", (0, collection_utils_1.arrayIntercalate)(", ", propertyOpts), ")"]);
          properties.push(["@field:JsonProperty(", (0, collection_utils_1.arrayIntercalate)(", ", propertyOpts), ")"]);
        }
        if (ignore) {
          properties.push("@get:JsonIgnore");
          properties.push("@field:JsonIgnore");
        }
        return properties.length === 0 ? void 0 : properties;
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("typealias ", className, " = JsonNode");
      }
      emitClassDefinitionMethods(c, className) {
        const isTopLevel = (0, collection_utils_1.iterableSome)(this.topLevels, ([_, top]) => top === c);
        if (isTopLevel) {
          this.emitBlock(")", () => {
            this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
              this.emitLine("fun fromJson(json: String) = mapper.readValue<", className, ">(json)");
            });
          });
        } else {
          this.emitLine(")");
        }
      }
      renameAttribute(name, jsonName, required, meta) {
        const rename = this.jacksonRenameAttribute(name, jsonName, required);
        if (rename !== void 0) {
          meta.push(() => this.emitLine(rename));
        }
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum class ", enumName, "(val value: String)"], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name, json) => {
            this.emitLine(name, `("${stringEscape(json)}")`, --count === 0 ? ";" : ",");
          });
          this.ensureBlankLine();
          this.emitBlock("companion object", () => {
            this.emitBlock(["fun fromValue(value: String): ", enumName, " = when (value)"], () => {
              let table = [];
              this.forEachEnumCase(e, "none", (name, json) => {
                table.push([[`"${stringEscape(json)}"`], [" -> ", name]]);
              });
              table.push([["else"], [" -> throw IllegalArgumentException()"]]);
              this.emitTable(table);
            });
          });
        });
      }
      emitGenericConverter() {
        this.ensureBlankLine();
        this.emitMultiline(`
@Suppress("UNCHECKED_CAST")
private fun <T> ObjectMapper.convert(k: kotlin.reflect.KClass<*>, fromJson: (JsonNode) -> T, toJson: (T) -> String, isUnion: Boolean = false) = registerModule(SimpleModule().apply {
    addSerializer(k.java as Class<T>, object : StdSerializer<T>(k.java as Class<T>) {
        override fun serialize(value: T, gen: JsonGenerator, provider: SerializerProvider) = gen.writeRawValue(toJson(value))
    })
    addDeserializer(k.java as Class<T>, object : StdDeserializer<T>(k.java as Class<T>) {
        override fun deserialize(p: JsonParser, ctxt: DeserializationContext) = fromJson(p.readValueAsTree())
    })
})`);
      }
      emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName) {
        this.ensureBlankLine();
        this.emitLine("fun toJson(): String = mapper.writeValueAsString(when (this) {");
        this.indent(() => {
          let toJsonTable = [];
          this.forEachUnionMember(u, nonNulls, "none", null, (name) => {
            toJsonTable.push([["is ", name], [" -> this.value"]]);
          });
          if (maybeNull !== null) {
            const name = this.nameForUnionMember(u, maybeNull);
            toJsonTable.push([["is ", name], [' -> "null"']]);
          }
          this.emitTable(toJsonTable);
        });
        this.emitLine("})");
        this.ensureBlankLine();
        this.emitBlock("companion object", () => {
          this.emitLine("fun fromJson(jn: JsonNode): ", unionName, " = when (jn) {");
          this.indent(() => {
            let table = [];
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              table.push([[this.unionMemberJsonValueGuard(t, "jn")], [" -> ", name, "(mapper.treeToValue(jn))"]]);
            });
            if (maybeNull !== null) {
              const name = this.nameForUnionMember(u, maybeNull);
              table.push([[this.unionMemberJsonValueGuard(maybeNull, "jn")], [" -> ", name, "()"]]);
            }
            table.push([["else"], [" -> throw IllegalArgumentException()"]]);
            this.emitTable(table);
          });
          this.emitLine("}");
        });
      }
    };
    exports.KotlinJacksonRenderer = KotlinJacksonRenderer;
    var KotlinXRenderer = class extends KotlinRenderer {
      constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
      }
      anySourceType(optional) {
        return ["JsonElement", optional];
      }
      arrayType(arrayType, withIssues = false, noOptional = false) {
        const valType = this.kotlinType(arrayType.items, withIssues, true);
        const name = this.sourcelikeToString(valType);
        if (name === "JsonObject" || name === "JsonElement") {
          return "JsonArray";
        }
        return super.arrayType(arrayType, withIssues, noOptional);
      }
      mapType(mapType, withIssues = false, noOptional = false) {
        const valType = this.kotlinType(mapType.values, withIssues, true);
        const name = this.sourcelikeToString(valType);
        if (name === "JsonObject" || name === "JsonElement") {
          return "JsonObject";
        }
        return super.mapType(mapType, withIssues, noOptional);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        if (elementType === "JsonObject") {
          this.emitLine(["typealias ", name, " = JsonObject"]);
        } else {
          super.emitTopLevelMap(t, name);
        }
      }
      emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitLine(["typealias ", name, " = JsonArray<", elementType, ">"]);
      }
      emitUsageHeader() {
        this.emitLine("// To parse the JSON, install kotlin's serialization plugin and do:");
        this.emitLine("//");
        const table = [];
        table.push(["// val ", "json", " = Json { allowStructuredMapKeys = true }"]);
        this.forEachTopLevel("none", (_, name) => {
          table.push([
            "// val ",
            (0, Source_1.modifySource)(Strings_1.camelCase, name),
            ` = json.parse(${this.sourcelikeToString(name)}.serializer(), jsonString)`
          ]);
        });
        this.emitTable(table);
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import kotlinx.serialization.*");
        this.emitLine("import kotlinx.serialization.json.*");
        this.emitLine("import kotlinx.serialization.descriptors.*");
        this.emitLine("import kotlinx.serialization.encoding.*");
      }
      emitClassAnnotations(_c, _className) {
        this.emitLine("@Serializable");
      }
      renameAttribute(name, jsonName, _required, meta) {
        const rename = this._rename(name, jsonName);
        if (rename !== void 0) {
          meta.push(() => this.emitLine(rename));
        }
      }
      _rename(propName, jsonName) {
        const escapedName = stringEscape(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        if (namesDiffer) {
          return ['@SerialName("', escapedName, '")'];
        }
        return void 0;
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine(["@Serializable"]);
        this.emitBlock(["enum class ", enumName, "(val value: String)"], () => {
          let count = e.cases.size;
          this.forEachEnumCase(e, "none", (name, json) => {
            const jsonEnum = stringEscape(json);
            this.emitLine(`@SerialName("${jsonEnum}") `, name, `("${jsonEnum}")`, --count === 0 ? ";" : ",");
          });
        });
      }
    };
    exports.KotlinXRenderer = KotlinXRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Objective-C.js
var require_Objective_C = __commonJS({
  "node_modules/quicktype-core/dist/language/Objective-C.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectiveCRenderer = exports.ObjectiveCTargetLanguage = exports.objcOptions = void 0;
    var collection_utils_1 = require_dist();
    var unicode_properties_1 = __importDefault(require_main());
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var DEBUG = false;
    var DEFAULT_CLASS_PREFIX = "QT";
    exports.objcOptions = {
      features: new RendererOptions_1.EnumOption("features", "Interface and implementation", [
        ["all", { interface: true, implementation: true }],
        ["interface", { interface: true, implementation: false }],
        ["implementation", { interface: false, implementation: true }]
      ]),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      marshallingFunctions: new RendererOptions_1.BooleanOption("functions", "C-style functions", false),
      classPrefix: new RendererOptions_1.StringOption("class-prefix", "Class prefix", "PREFIX", DEFAULT_CLASS_PREFIX),
      extraComments: new RendererOptions_1.BooleanOption("extra-comments", "Extra comments", false)
    };
    var ObjectiveCTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Objective-C", ["objc", "objective-c", "objectivec"], "m");
      }
      getOptions() {
        return [
          exports.objcOptions.justTypes,
          exports.objcOptions.classPrefix,
          exports.objcOptions.features,
          exports.objcOptions.extraComments,
          exports.objcOptions.marshallingFunctions
        ];
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new ObjectiveCRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.objcOptions, untypedOptionValues));
      }
    };
    exports.ObjectiveCTargetLanguage = ObjectiveCTargetLanguage;
    function typeNameStyle(prefix, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const result = (0, Strings_1.combineWords)(words, legalizeName, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
      return (0, Strings_1.addPrefixIfNecessary)(prefix, result);
    }
    function propertyNameStyle(original, isBool = false) {
      if (original === "id") {
        original = "identifier";
      }
      let words = (0, Strings_1.splitIntoWords)(original);
      if (isBool) {
        if (words.length === 0) {
          words = [{ word: "flag", isAcronym: false }];
        } else if (!words[0].isAcronym && !booleanPrefixes.includes(words[0].word)) {
          words = [{ word: "is", isAcronym: false }, ...words];
        }
      }
      if (words.length > 0 && forbiddenPropertyNames.includes(words[0].word)) {
        words = [{ word: "the", isAcronym: false }, ...words];
      }
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    var keywords = [
      /*
      "_Bool",
      "_Complex",
      "_Imaginary",
      */
      "asm",
      "atomic",
      "auto",
      "bool",
      "break",
      "case",
      "char",
      "const",
      "continue",
      "default",
      "do",
      "double",
      "else",
      "enum",
      "extern",
      "false",
      "float",
      "for",
      "goto",
      "if",
      "inline",
      "int",
      "long",
      "nil",
      "nonatomic",
      "register",
      "restrict",
      "retain",
      "return",
      "short",
      "signed",
      "sizeof",
      "static",
      "struct",
      "switch",
      "typedef",
      "typeof",
      "true",
      "union",
      "unsigned",
      "void",
      "volatile",
      "while"
    ];
    var forbiddenPropertyNames = [
      "id",
      "hash",
      "description",
      "init",
      "copy",
      "mutableCopy",
      "superclass",
      "debugDescription",
      "new"
    ];
    var booleanPrefixes = [
      "is",
      "are",
      "were",
      "was",
      "will",
      "all",
      "some",
      "many",
      "has",
      "have",
      "had",
      "does",
      "do",
      "requires",
      "require",
      "needs",
      "need"
    ];
    function isStartCharacter(utf16Unit) {
      return unicode_properties_1.default.isAlphabetic(utf16Unit) || utf16Unit === 95;
    }
    function isPartCharacter(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return ["Nd", "Pc", "Mn", "Mc"].includes(category) || isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    var staticEnumValuesIdentifier = "values";
    var forbiddenForEnumCases = ["new", staticEnumValuesIdentifier];
    function splitExtension(filename) {
      const i = filename.lastIndexOf(".");
      const extension = i !== -1 ? filename.split(".").pop() : "m";
      filename = i !== -1 ? filename.slice(0, i) : filename;
      return [filename, extension !== null && extension !== void 0 ? extension : "m"];
    }
    var ObjectiveCRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        if (_options.classPrefix === DEFAULT_CLASS_PREFIX) {
          const aTopLevel = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(this.topLevels.keys()));
          this._classPrefix = this.inferClassPrefix(aTopLevel);
        } else {
          this._classPrefix = _options.classPrefix;
        }
      }
      inferClassPrefix(name) {
        const l = name.length;
        let firstNonUpper = 0;
        while (firstNonUpper < l && (0, Strings_1.fastIsUpperCase)(name.charCodeAt(firstNonUpper))) {
          firstNonUpper += 1;
        }
        if (firstNonUpper < 2)
          return DEFAULT_CLASS_PREFIX;
        return name.slice(0, firstNonUpper - 1);
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: forbiddenPropertyNames, includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: forbiddenForEnumCases, includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (rawName) => typeNameStyle(this._classPrefix, rawName));
      }
      namerForObjectProperty(_, p) {
        return new Naming_1.Namer("properties", (s) => propertyNameStyle(s, p.type.kind === "bool"), [
          "_",
          "the",
          "one",
          "some",
          "another"
        ]);
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return new Naming_1.Namer("enum-cases", propertyNameStyle, []);
      }
      namedTypeToNameForTopLevel(type) {
        return type;
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: "/// " });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitMethod(declaration, f) {
        this.emitLine(declaration);
        this.emitLine("{");
        this.indent(f);
        this.emitLine("}");
      }
      emitExtraComments(...comments) {
        if (!this._options.extraComments)
          return;
        for (const comment of comments) {
          this.emitLine("// ", comment);
        }
      }
      startFile(basename, extension) {
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished");
        this._currentFilename = `${this.sourcelikeToString(basename)}.${extension}`;
      }
      finishFile() {
        super.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      memoryAttribute(t, isNullable) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => "copy", (_nullType) => "copy", (_boolType) => isNullable ? "strong" : "assign", (_integerType) => isNullable ? "strong" : "assign", (_doubleType) => isNullable ? "strong" : "assign", (_stringType) => "copy", (_arrayType) => "copy", (_classType) => "strong", (_mapType) => "copy", (_enumType) => "assign", (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          return nullable !== null ? this.memoryAttribute(nullable, true) : "copy";
        });
      }
      objcType(t, nullableOrBoxed = false) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => ["id", ""],
          // For now, we're treating nulls just like any
          (_nullType) => ["id", ""],
          (_boolType) => nullableOrBoxed ? ["NSNumber", " *"] : ["BOOL", ""],
          (_integerType) => nullableOrBoxed ? ["NSNumber", " *"] : ["NSInteger", ""],
          (_doubleType) => nullableOrBoxed ? ["NSNumber", " *"] : ["double", ""],
          (_stringType) => ["NSString", " *"],
          (arrayType) => {
            const itemType = arrayType.items;
            const itemTypeName = this.objcType(itemType, true);
            if ((0, TypeUtils_1.isAnyOrNull)(itemType)) {
              return ["NSArray", " *"];
            }
            return [["NSArray<", itemTypeName, ">"], " *"];
          },
          (classType) => [this.nameForNamedType(classType), " *"],
          (mapType) => [["NSDictionary<NSString *, ", this.objcType(mapType.values, true), ">"], " *"],
          (enumType) => [this.nameForNamedType(enumType), " *"],
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            return nullable !== null ? this.objcType(nullable, true) : ["id", ""];
          }
        );
      }
      jsonType(t) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => ["id", ""],
          // For now, we're treating nulls just like any
          (_nullType) => ["id", ""],
          (_boolType) => ["NSNumber", " *"],
          (_integerType) => ["NSNumber", " *"],
          (_doubleType) => ["NSNumber", " *"],
          (_stringType) => ["NSString", " *"],
          (_arrayType) => ["NSArray", " *"],
          (_classType) => ["NSDictionary<NSString *, id>", " *"],
          (mapType) => [["NSDictionary<NSString *, ", this.jsonType(mapType.values), ">"], " *"],
          (_enumType) => ["NSString", " *"],
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            return nullable !== null ? this.jsonType(nullable) : ["id", ""];
          }
        );
      }
      fromDynamicExpression(t, ...dynamic) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => dynamic, (_nullType) => dynamic, (_boolType) => dynamic, (_integerType) => dynamic, (_doubleType) => dynamic, (_stringType) => dynamic, (arrayType) => ["map(", dynamic, ", Î»(id x, ", this.fromDynamicExpression(arrayType.items, "x"), "))"], (classType) => ["[", this.nameForNamedType(classType), " fromJSONDictionary:", dynamic, "]"], (mapType) => ["map(", dynamic, ", Î»(id x, ", this.fromDynamicExpression(mapType.values, "x"), "))"], (enumType) => ["[", this.nameForNamedType(enumType), " withValue:", dynamic, "]"], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          return nullable !== null ? this.fromDynamicExpression(nullable, dynamic) : dynamic;
        });
      }
      toDynamicExpression(t, typed) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => ["NSNullify(", typed, ")"],
          (_nullType) => ["NSNullify(", typed, ")"],
          // Sadly, KVC
          (_boolType) => [typed, " ? @YES : @NO"],
          (_integerType) => typed,
          (_doubleType) => typed,
          (_stringType) => typed,
          (arrayType) => {
            if (this.implicitlyConvertsFromJSON(arrayType)) {
              return typed;
            }
            return ["map(", typed, ", Î»(id x, ", this.toDynamicExpression(arrayType.items, "x"), "))"];
          },
          (_classType) => ["[", typed, " JSONDictionary]"],
          (mapType) => {
            if (this.implicitlyConvertsFromJSON(mapType)) {
              return typed;
            }
            return ["map(", typed, ", Î»(id x, ", this.toDynamicExpression(mapType.values, "x"), "))"];
          },
          (_enumType) => ["[", typed, " value]"],
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            if (nullable !== null) {
              if (this.implicitlyConvertsFromJSON(nullable)) {
                return ["NSNullify(", typed, ")"];
              } else {
                return ["NSNullify(", this.toDynamicExpression(nullable, typed), ")"];
              }
            } else {
              return typed;
            }
          }
        );
      }
      implicitlyConvertsFromJSON(t) {
        if (t instanceof Type_1.ClassType) {
          return false;
        } else if (t instanceof Type_1.EnumType) {
          return false;
        } else if (t instanceof Type_1.ArrayType) {
          return this.implicitlyConvertsFromJSON(t.items);
        } else if (t instanceof Type_1.MapType) {
          return this.implicitlyConvertsFromJSON(t.values);
        } else if (t.isPrimitive()) {
          return true;
        } else if (t instanceof Type_1.UnionType) {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (nullable !== null) {
            return this.implicitlyConvertsFromJSON(nullable);
          } else {
            return true;
          }
        } else {
          return false;
        }
      }
      implicitlyConvertsToJSON(t) {
        return this.implicitlyConvertsFromJSON(t) && "bool" !== t.kind;
      }
      emitPropertyAssignment(propertyName, jsonName, propertyType) {
        const name = ["_", propertyName];
        (0, TypeUtils_1.matchType)(propertyType, (anyType) => this.emitLine(name, " = ", this.fromDynamicExpression(anyType, name), ";"), (nullType) => this.emitLine(name, " = ", this.fromDynamicExpression(nullType, name), ";"), (boolType) => this.emitLine(name, " = ", this.fromDynamicExpression(boolType, name), ";"), (integerType) => this.emitLine(name, " = ", this.fromDynamicExpression(integerType, name), ";"), (doubleType) => this.emitLine(name, " = ", this.fromDynamicExpression(doubleType, name), ";"), (stringType) => this.emitLine(name, " = ", this.fromDynamicExpression(stringType, name), ";"), (arrayType) => this.emitLine(name, " = ", this.fromDynamicExpression(arrayType, name), ";"), (classType) => this.emitLine(name, " = ", this.fromDynamicExpression(classType, ["(id)", name]), ";"), (mapType) => {
          const itemType = mapType.values;
          this.emitLine(name, " = map(", name, ", ", ["Î»(id x, ", this.fromDynamicExpression(itemType, "x"), ")"], ");");
        }, (enumType) => this.emitLine(name, " = ", this.fromDynamicExpression(enumType, ["(id)", name]), ";"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitPropertyAssignment(propertyName, jsonName, nullable);
          } else {
            this.emitLine(name, " = ", this.fromDynamicExpression(unionType, name), ";");
          }
        });
      }
      emitPrivateClassInterface(_, name) {
        this.emitLine("@interface ", name, " (JSONConversion)");
        this.emitLine("+ (instancetype)fromJSONDictionary:(NSDictionary *)dict;");
        this.emitLine("- (NSDictionary *)JSONDictionary;");
        this.emitLine("@end");
      }
      pointerAwareTypeName(t) {
        const name = t instanceof Type_1.Type ? this.objcType(t) : t;
        const isPointer = name[1] !== "";
        return isPointer ? name : [name, " "];
      }
      emitNonClassTopLevelTypedef(t, name) {
        let nonPointerTypeName = this.objcType(t)[0];
        this.emitLine("typedef ", nonPointerTypeName, " ", name, ";");
      }
      topLevelFromDataPrototype(name) {
        return [name, " *_Nullable ", name, "FromData(NSData *data, NSError **error)"];
      }
      topLevelFromJSONPrototype(name) {
        return [name, " *_Nullable ", name, "FromJSON(NSString *json, NSStringEncoding encoding, NSError **error)"];
      }
      topLevelToDataPrototype(name, pad = false) {
        const parameter = this.variableNameForTopLevel(name);
        const padding = pad ? (0, Strings_1.repeatString)(" ", this.sourcelikeToString(name).length - "NSData".length) : "";
        return ["NSData", padding, " *_Nullable ", name, "ToData(", name, " *", parameter, ", NSError **error)"];
      }
      topLevelToJSONPrototype(name, pad = false) {
        const parameter = this.variableNameForTopLevel(name);
        const padding = pad ? (0, Strings_1.repeatString)(" ", this.sourcelikeToString(name).length - "NSString".length) : "";
        return [
          "NSString",
          padding,
          " *_Nullable ",
          name,
          "ToJSON(",
          name,
          " *",
          parameter,
          ", NSStringEncoding encoding, NSError **error)"
        ];
      }
      emitTopLevelFunctionDeclarations(_, name) {
        this.emitLine(this.topLevelFromDataPrototype(name), ";");
        this.emitLine(this.topLevelFromJSONPrototype(name), ";");
        this.emitLine(this.topLevelToDataPrototype(name, true), ";");
        this.emitLine(this.topLevelToJSONPrototype(name, true), ";");
      }
      emitTryCatchAsError(inTry, inCatch) {
        this.emitLine("@try {");
        this.indent(inTry);
        this.emitLine("} @catch (NSException *exception) {");
        this.indent(() => {
          this.emitLine('*error = [NSError errorWithDomain:@"JSONSerialization" code:-1 userInfo:@{ @"exception": exception }];');
          inCatch();
        });
        this.emitLine("}");
      }
      emitTopLevelFunctions(t, name) {
        const parameter = this.variableNameForTopLevel(name);
        this.ensureBlankLine();
        this.emitMethod(this.topLevelFromDataPrototype(name), () => {
          this.emitTryCatchAsError(() => {
            this.emitLine("id json = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:error];");
            this.emitLine("return *error ? nil : ", this.fromDynamicExpression(t, "json"), ";");
          }, () => this.emitLine("return nil;"));
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelFromJSONPrototype(name), () => {
          this.emitLine("return ", name, "FromData([json dataUsingEncoding:encoding], error);");
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelToDataPrototype(name), () => {
          this.emitTryCatchAsError(() => {
            this.emitLine("id json = ", this.toDynamicExpression(t, parameter), ";");
            this.emitLine("NSData *data = [NSJSONSerialization dataWithJSONObject:json options:kNilOptions error:error];");
            this.emitLine("return *error ? nil : data;");
          }, () => this.emitLine("return nil;"));
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelToJSONPrototype(name), () => {
          this.emitLine("NSData *data = ", name, "ToData(", parameter, ", error);");
          this.emitLine("return data ? [[NSString alloc] initWithData:data encoding:encoding] : nil;");
        });
      }
      emitClassInterface(t, className) {
        const isTopLevel = (0, collection_utils_1.mapContains)(this.topLevels, t);
        this.emitDescription(this.descriptionForType(t));
        this.emitLine("@interface ", className, " : NSObject");
        if (DEBUG)
          this.emitLine("@property NSDictionary<NSString *, id> *_json;");
        this.emitPropertyTable(t, (name, _json, property) => {
          let attributes = ["nonatomic"];
          if (property.type.isNullable) {
            attributes.push("nullable");
          }
          attributes.push(this.memoryAttribute(property.type, property.type.isNullable));
          return [
            ["@property ", ["(", attributes.join(", "), ")"], " "],
            [this.pointerAwareTypeName(property.type), name, ";"]
          ];
        });
        if (!this._options.justTypes && isTopLevel) {
          if (t.getProperties().size > 0)
            this.ensureBlankLine();
          this.emitLine("+ (_Nullable instancetype)fromJSON:(NSString *)json encoding:(NSStringEncoding)encoding error:(NSError *_Nullable *)error;");
          this.emitLine("+ (_Nullable instancetype)fromData:(NSData *)data error:(NSError *_Nullable *)error;");
          this.emitLine("- (NSString *_Nullable)toJSON:(NSStringEncoding)encoding error:(NSError *_Nullable *)error;");
          this.emitLine("- (NSData *_Nullable)toData:(NSError *_Nullable *)error;");
        }
        this.emitLine("@end");
      }
      hasIrregularProperties(t) {
        let irregular = false;
        this.forEachClassProperty(t, "none", (name, jsonName) => {
          irregular = irregular || (0, Strings_1.stringEscape)(jsonName) !== this.sourcelikeToString(name);
        });
        return irregular;
      }
      hasUnsafeProperties(t) {
        let unsafe = false;
        this.forEachClassProperty(t, "none", (_, __, property) => {
          unsafe = unsafe || !this.implicitlyConvertsToJSON(property.type);
        });
        return unsafe;
      }
      // TODO Implement NSCopying
      emitClassImplementation(t, className) {
        const isTopLevel = (0, collection_utils_1.mapContains)(this.topLevels, t);
        const hasIrregularProperties = this.hasIrregularProperties(t);
        const hasUnsafeProperties = this.hasUnsafeProperties(t);
        this.emitLine("@implementation ", className);
        if (!this._options.justTypes) {
          this.emitMethod("+ (NSDictionary<NSString *, NSString *> *)properties", () => {
            this.emitLine("static NSDictionary<NSString *, NSString *> *properties;");
            this.emitLine("return properties = properties ? properties : @{");
            this.indent(() => {
              this.forEachClassProperty(t, "none", (name, jsonName) => this.emitLine(`@"${(0, Strings_1.stringEscape)(jsonName)}": @"`, name, '",'));
            });
            this.emitLine("};");
          });
          this.ensureBlankLine();
          if (isTopLevel) {
            this.emitMethod("+ (_Nullable instancetype)fromData:(NSData *)data error:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "FromData(data, error);");
            });
            this.ensureBlankLine();
            this.emitMethod("+ (_Nullable instancetype)fromJSON:(NSString *)json encoding:(NSStringEncoding)encoding error:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "FromJSON(json, encoding, error);");
            });
            this.ensureBlankLine();
          }
          this.emitMethod("+ (instancetype)fromJSONDictionary:(NSDictionary *)dict", () => {
            this.emitLine("return dict ? [[", className, " alloc] initWithJSONDictionary:dict] : nil;");
          });
          this.ensureBlankLine();
          this.emitMethod("- (instancetype)initWithJSONDictionary:(NSDictionary *)dict", () => {
            this.emitBlock("if (self = [super init])", () => {
              if (DEBUG)
                this.emitLine("__json = dict;");
              this.emitLine("[self setValuesForKeysWithDictionary:dict];");
              this.forEachClassProperty(t, "none", (name, jsonName, property) => {
                if (!this.implicitlyConvertsFromJSON(property.type)) {
                  this.emitPropertyAssignment(name, jsonName, property.type);
                }
              });
            });
            this.emitLine("return self;");
          });
          this.ensureBlankLine();
          this.emitMethod("- (void)setValue:(nullable id)value forKey:(NSString *)key", () => {
            this.emitLine("id resolved = ", className, ".properties[key];");
            this.emitLine("if (resolved) [super setValue:value forKey:resolved];");
          });
          this.ensureBlankLine();
          this.emitMethod("- (void)setNilValueForKey:(NSString *)key", () => {
            this.emitLine("id resolved = ", className, ".properties[key];");
            this.emitLine("if (resolved) [super setValue:@(0) forKey:resolved];");
          });
          this.ensureBlankLine();
          this.emitMethod("- (NSDictionary *)JSONDictionary", () => {
            if (!hasIrregularProperties && !hasUnsafeProperties) {
              this.emitLine("return [self dictionaryWithValuesForKeys:", className, ".properties.allValues];");
              return;
            }
            this.emitLine("id dict = [[self dictionaryWithValuesForKeys:", className, ".properties.allValues] mutableCopy];");
            this.ensureBlankLine();
            if (hasIrregularProperties) {
              this.emitExtraComments("Rewrite property names that differ in JSON");
              this.emitBlock(["for (id jsonName in ", className, ".properties)"], () => {
                this.emitLine("id propertyName = ", className, ".properties[jsonName];");
                this.emitBlock("if (![jsonName isEqualToString:propertyName])", () => {
                  this.emitLine("dict[jsonName] = dict[propertyName];");
                  this.emitLine("[dict removeObjectForKey:propertyName];");
                });
              });
            }
            if (hasUnsafeProperties) {
              this.ensureBlankLine();
              this.emitExtraComments("Map values that need translation");
              this.emitLine("[dict addEntriesFromDictionary:@{");
              this.indent(() => {
                this.forEachClassProperty(t, "none", (propertyName, jsonKey, property) => {
                  if (!this.implicitlyConvertsToJSON(property.type)) {
                    const key = (0, Strings_1.stringEscape)(jsonKey);
                    const name = ["_", propertyName];
                    this.emitLine('@"', key, '": ', this.toDynamicExpression(property.type, name), ",");
                  }
                });
              });
              this.emitLine("}];");
            }
            this.ensureBlankLine();
            this.emitLine("return dict;");
          });
          if (isTopLevel) {
            this.ensureBlankLine();
            this.emitMethod("- (NSData *_Nullable)toData:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "ToData(self, error);");
            });
            this.ensureBlankLine();
            this.emitMethod("- (NSString *_Nullable)toJSON:(NSStringEncoding)encoding error:(NSError *_Nullable *)error", () => {
              this.emitLine("return ", className, "ToJSON(self, encoding, error);");
            });
          }
        }
        this.emitLine("@end");
      }
      emitMark(label) {
        this.ensureBlankLine();
        this.emitLine(`#pragma mark - ${label}`);
        this.ensureBlankLine();
      }
      variableNameForTopLevel(name) {
        const camelCaseName = (0, Source_1.modifySource)((serialized) => {
          serialized = serialized.slice(this._classPrefix.length);
          return (0, Strings_1.camelCase)(serialized);
        }, name);
        return camelCaseName;
      }
      emitPseudoEnumInterface(enumType, enumName) {
        this.emitDescription(this.descriptionForType(enumType));
        this.emitLine("@interface ", enumName, " : NSObject");
        this.emitLine("@property (nonatomic, readonly, copy) NSString *value;");
        this.emitLine("+ (instancetype _Nullable)withValue:(NSString *)value;");
        this.forEachEnumCase(enumType, "none", (name, _) => {
          this.emitLine("+ (", enumName, " *)", name, ";");
        });
        this.emitLine("@end");
      }
      emitPseudoEnumImplementation(enumType, enumName) {
        this.emitLine("@implementation ", enumName);
        const instances = [enumName, ".", staticEnumValuesIdentifier];
        this.emitMethod(["+ (NSDictionary<NSString *, ", enumName, " *> *)", staticEnumValuesIdentifier], () => {
          this.emitLine("static NSDictionary<NSString *, ", enumName, " *> *", staticEnumValuesIdentifier, ";");
          this.emitLine("return ", staticEnumValuesIdentifier, " = ", staticEnumValuesIdentifier, " ? ", staticEnumValuesIdentifier, " : @{");
          this.indent(() => {
            this.forEachEnumCase(enumType, "none", (_, jsonValue) => {
              const value = ['@"', (0, Strings_1.stringEscape)(jsonValue), '"'];
              this.emitLine(value, ": [[", enumName, " alloc] initWithValue:", value, "],");
            });
          });
          this.emitLine("};");
        });
        this.ensureBlankLine();
        this.forEachEnumCase(enumType, "none", (name, jsonValue) => {
          this.emitLine("+ (", enumName, " *)", name, " { return ", instances, '[@"', (0, Strings_1.stringEscape)(jsonValue), '"]; }');
        });
        this.ensureBlankLine();
        this.emitMethod("+ (instancetype _Nullable)withValue:(NSString *)value", () => this.emitLine("return ", instances, "[value];"));
        this.ensureBlankLine();
        this.emitMethod("- (instancetype)initWithValue:(NSString *)value", () => {
          this.emitLine("if (self = [super init]) _value = value;");
          this.emitLine("return self;");
        });
        this.ensureBlankLine();
        this.emitLine("- (NSUInteger)hash { return _value.hash; }");
        this.emitLine("@end");
      }
      emitSourceStructure(proposedFilename) {
        const fileMode = proposedFilename !== "stdout";
        if (!fileMode) {
          const firstTopLevel = (0, Support_1.defined)((0, collection_utils_1.mapFirst)(this.topLevels));
          proposedFilename = this.sourcelikeToString(this.nameForNamedType(firstTopLevel)) + ".m";
        }
        const [filename, extension] = splitExtension(proposedFilename);
        if (this._options.features.interface) {
          this.startFile(filename, "h");
          if (this.leadingComments !== void 0) {
            this.emitComments(this.leadingComments);
          } else if (!this._options.justTypes) {
            this.emitCommentLines(["To parse this JSON:", ""]);
            this.emitLine("//   NSError *error;");
            this.forEachTopLevel("none", (t, topLevelName) => {
              const fromJsonExpression = t instanceof Type_1.ClassType ? ["[", topLevelName, " fromJSON:json encoding:NSUTF8Encoding error:&error];"] : [topLevelName, "FromJSON(json, NSUTF8Encoding, &error);"];
              this.emitLine("//   ", topLevelName, " *", this.variableNameForTopLevel(topLevelName), " = ", fromJsonExpression);
            });
          }
          this.ensureBlankLine();
          this.emitLine("#import <Foundation/Foundation.h>");
          this.ensureBlankLine();
          this.forEachNamedType("none", (_, className) => this.emitLine("@class ", className, ";"), (_, enumName) => this.emitLine("@class ", enumName, ";"), () => null);
          this.ensureBlankLine();
          this.ensureBlankLine();
          this.emitLine("NS_ASSUME_NONNULL_BEGIN");
          this.ensureBlankLine();
          if (this.haveEnums) {
            this.emitMark("Boxed enums");
            this.forEachEnum("leading-and-interposing", (t, n) => this.emitPseudoEnumInterface(t, n));
          }
          this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitNonClassTopLevelTypedef(t, n), (t) => !(t instanceof Type_1.ClassType));
          const hasTopLevelNonClassTypes = (0, collection_utils_1.iterableSome)(this.topLevels, ([_, t]) => !(t instanceof Type_1.ClassType));
          if (!this._options.justTypes && (hasTopLevelNonClassTypes || this._options.marshallingFunctions)) {
            this.ensureBlankLine();
            this.emitMark("Top-level marshaling functions");
            this.forEachTopLevel(
              "leading-and-interposing",
              (t, n) => this.emitTopLevelFunctionDeclarations(t, n),
              // Objective-C developers get freaked out by C functions, so we don't
              // declare them for top-level object types (we always need them for non-object types)
              (t) => this._options.marshallingFunctions || !(t instanceof Type_1.ClassType)
            );
          }
          this.emitMark("Object interfaces");
          this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassInterface(c, className), () => null, () => null);
          this.ensureBlankLine();
          this.emitLine("NS_ASSUME_NONNULL_END");
          this.finishFile();
        }
        if (this._options.features.implementation) {
          this.startFile(filename, extension);
          this.emitLine(`#import "${filename}.h"`);
          this.ensureBlankLine();
          if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitExtraComments("Shorthand for simple blocks");
            this.emitLine("#define Î»(decl, expr) (^(decl) { return (expr); })");
            this.ensureBlankLine();
            this.emitExtraComments("nil â NSNull conversion for JSON dictionaries");
            this.emitBlock("static id NSNullify(id _Nullable x)", () => this.emitLine("return (x == nil || x == NSNull.null) ? NSNull.null : x;"));
            this.ensureBlankLine();
            this.emitLine("NS_ASSUME_NONNULL_BEGIN");
            this.ensureBlankLine();
            if (this._options.extraComments) {
              this.emitMark("Private model interfaces");
            }
            this.forEachNamedType("leading-and-interposing", (c, className) => this.emitPrivateClassInterface(c, className), () => null, () => null);
            if (this.haveEnums) {
              if (this._options.extraComments) {
                this.ensureBlankLine();
                this.emitExtraComments("These enum-like reference types are needed so that enum", "values can be contained by NSArray and NSDictionary.");
                this.ensureBlankLine();
              }
              this.forEachEnum("leading-and-interposing", (t, n) => this.emitPseudoEnumImplementation(t, n));
            }
            this.ensureBlankLine();
            this.emitMapFunction();
            this.ensureBlankLine();
            this.emitMark("JSON serialization");
            this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitTopLevelFunctions(t, n));
          }
          this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassImplementation(c, className), () => null, () => null);
          if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitLine("NS_ASSUME_NONNULL_END");
          }
          this.finishFile();
        }
      }
      get needsMap() {
        function needsMap(t) {
          return t instanceof Type_1.MapType || t instanceof Type_1.ArrayType || t instanceof Type_1.ClassType && (0, collection_utils_1.mapSome)(t.getProperties(), (p) => needsMap(p.type));
        }
        return (0, collection_utils_1.iterableSome)(this.typeGraph.allTypesUnordered(), needsMap);
      }
      emitMapFunction() {
        if (this.needsMap) {
          this.emitMultiline(`static id map(id collection, id (^f)(id value)) {
    id result = nil;
    if ([collection isKindOfClass:NSArray.class]) {
        result = [NSMutableArray arrayWithCapacity:[collection count]];
        for (id x in collection) [result addObject:f(x)];
    } else if ([collection isKindOfClass:NSDictionary.class]) {
        result = [NSMutableDictionary dictionaryWithCapacity:[collection count]];
        for (id key in collection) [result setObject:f([collection objectForKey:key]) forKey:key];
    }
    return result;
}`);
        }
      }
    };
    exports.ObjectiveCRenderer = ObjectiveCRenderer;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['â]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag2] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã": "A",
        "Ã ": "a",
        "Ã¡": "a",
        "Ã¢": "a",
        "Ã£": "a",
        "Ã¤": "a",
        "Ã¥": "a",
        "Ã": "C",
        "Ã§": "c",
        "Ã": "D",
        "Ã°": "d",
        "Ã": "E",
        "Ã": "E",
        "Ã": "E",
        "Ã": "E",
        "Ã¨": "e",
        "Ã©": "e",
        "Ãª": "e",
        "Ã«": "e",
        "Ã": "I",
        "Ã": "I",
        "Ã": "I",
        "Ã": "I",
        "Ã¬": "i",
        "Ã­": "i",
        "Ã®": "i",
        "Ã¯": "i",
        "Ã": "N",
        "Ã±": "n",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã": "O",
        "Ã²": "o",
        "Ã³": "o",
        "Ã´": "o",
        "Ãµ": "o",
        "Ã¶": "o",
        "Ã¸": "o",
        "Ã": "U",
        "Ã": "U",
        "Ã": "U",
        "Ã": "U",
        "Ã¹": "u",
        "Ãº": "u",
        "Ã»": "u",
        "Ã¼": "u",
        "Ã": "Y",
        "Ã½": "y",
        "Ã¿": "y",
        "Ã": "Ae",
        "Ã¦": "ae",
        "Ã": "Th",
        "Ã¾": "th",
        "Ã": "ss",
        // Latin Extended-A block.
        "Ä": "A",
        "Ä": "A",
        "Ä": "A",
        "Ä": "a",
        "Ä": "a",
        "Ä": "a",
        "Ä": "C",
        "Ä": "C",
        "Ä": "C",
        "Ä": "C",
        "Ä": "c",
        "Ä": "c",
        "Ä": "c",
        "Ä": "c",
        "Ä": "D",
        "Ä": "D",
        "Ä": "d",
        "Ä": "d",
        "Ä": "E",
        "Ä": "E",
        "Ä": "E",
        "Ä": "E",
        "Ä": "E",
        "Ä": "e",
        "Ä": "e",
        "Ä": "e",
        "Ä": "e",
        "Ä": "e",
        "Ä": "G",
        "Ä": "G",
        "Ä ": "G",
        "Ä¢": "G",
        "Ä": "g",
        "Ä": "g",
        "Ä¡": "g",
        "Ä£": "g",
        "Ä¤": "H",
        "Ä¦": "H",
        "Ä¥": "h",
        "Ä§": "h",
        "Ä¨": "I",
        "Äª": "I",
        "Ä¬": "I",
        "Ä®": "I",
        "Ä°": "I",
        "Ä©": "i",
        "Ä«": "i",
        "Ä­": "i",
        "Ä¯": "i",
        "Ä±": "i",
        "Ä´": "J",
        "Äµ": "j",
        "Ä¶": "K",
        "Ä·": "k",
        "Ä¸": "k",
        "Ä¹": "L",
        "Ä»": "L",
        "Ä½": "L",
        "Ä¿": "L",
        "Å": "L",
        "Äº": "l",
        "Ä¼": "l",
        "Ä¾": "l",
        "Å": "l",
        "Å": "l",
        "Å": "N",
        "Å": "N",
        "Å": "N",
        "Å": "N",
        "Å": "n",
        "Å": "n",
        "Å": "n",
        "Å": "n",
        "Å": "O",
        "Å": "O",
        "Å": "O",
        "Å": "o",
        "Å": "o",
        "Å": "o",
        "Å": "R",
        "Å": "R",
        "Å": "R",
        "Å": "r",
        "Å": "r",
        "Å": "r",
        "Å": "S",
        "Å": "S",
        "Å": "S",
        "Å ": "S",
        "Å": "s",
        "Å": "s",
        "Å": "s",
        "Å¡": "s",
        "Å¢": "T",
        "Å¤": "T",
        "Å¦": "T",
        "Å£": "t",
        "Å¥": "t",
        "Å§": "t",
        "Å¨": "U",
        "Åª": "U",
        "Å¬": "U",
        "Å®": "U",
        "Å°": "U",
        "Å²": "U",
        "Å©": "u",
        "Å«": "u",
        "Å­": "u",
        "Å¯": "u",
        "Å±": "u",
        "Å³": "u",
        "Å´": "W",
        "Åµ": "w",
        "Å¶": "Y",
        "Å·": "y",
        "Å¸": "Y",
        "Å¹": "Z",
        "Å»": "Z",
        "Å½": "Z",
        "Åº": "z",
        "Å¼": "z",
        "Å¾": "z",
        "Ä²": "IJ",
        "Ä³": "ij",
        "Å": "Oe",
        "Å": "oe",
        "Å": "'n",
        "Å¿": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs2 = data.__data__;
            if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
              pairs2.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs2);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap2(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag2;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string2, n) {
          var result2 = "";
          if (!string2 || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string2;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string2 += string2;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string2) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string2) {
            return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag2:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag2:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs2) {
          var index = -1, length = pairs2 == null ? 0 : pairs2.length, result2 = {};
          while (++index < length) {
            var pair = pairs2[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag2;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string2) {
          return upperFirst(toString(string2).toLowerCase());
        }
        function deburr(string2) {
          string2 = toString(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string2, target, position) {
          string2 = toString(string2);
          target = baseToString(target);
          var length = string2.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        function escape2(string2) {
          string2 = toString(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        function escapeRegExp(string2) {
          string2 = toString(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          if (!length || strLength >= length) {
            return string2;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
        }
        function padStart(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
        }
        function parseInt2(string2, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string2).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string2, n, guard) {
          if (guard ? isIterateeCall(string2, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string2), n);
        }
        function replace() {
          var args = arguments, string2 = toString(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string2, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString(string2);
          if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString(string2);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        function template(string2, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string2, options, guard)) {
            options = undefined2;
          }
          string2 = toString(string2);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string2, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string2 = toString(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string2;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string2.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string2) {
          string2 = toString(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string2, pattern, guard) {
          string2 = toString(string2);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs2) {
          var length = pairs2 == null ? 0 : pairs2.length, toIteratee = getIteratee();
          pairs2 = !length ? [] : arrayMap(pairs2, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs2[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map2;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set2;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty2;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap2;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/quicktype-core/dist/language/Php.js
var require_Php = __commonJS({
  "node_modules/quicktype-core/dist/language/Php.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PhpRenderer = exports.phpNameStyle = exports.stringEscape = exports.PhpTargetLanguage = exports.phpOptions = void 0;
    var _ = __importStar(require_lodash());
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var TypeUtils_1 = require_TypeUtils();
    exports.phpOptions = {
      withGet: new RendererOptions_1.BooleanOption("with-get", "Create Getter", true),
      fastGet: new RendererOptions_1.BooleanOption("fast-get", "getter without validation", false),
      withSet: new RendererOptions_1.BooleanOption("with-set", "Create Setter", false),
      withClosing: new RendererOptions_1.BooleanOption("with-closing", "PHP Closing Tag", false),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal)
    };
    var PhpTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("PHP", ["php"], "php");
      }
      getOptions() {
        return _.values(exports.phpOptions);
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.phpOptions, untypedOptionValues);
        return new PhpRenderer(this, renderContext, options);
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date", "date");
        mapping.set("time", "time");
        mapping.set("uuid", "uuid");
        mapping.set("date-time", "date-time");
        return mapping;
      }
    };
    exports.PhpTargetLanguage = PhpTargetLanguage;
    exports.stringEscape = (0, Strings_1.utf16ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isAscii, Strings_1.standardUnicodeHexEscape));
    function isStartCharacter(codePoint) {
      if (codePoint === 95)
        return true;
      return (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isLetter)(codePoint);
    }
    function isPartCharacter(codePoint) {
      return isStartCharacter(codePoint) || (0, Strings_1.isAscii)(codePoint) && (0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter);
    function phpNameStyle(startWithUpper, upperUnderscore, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, upperUnderscore ? Strings_1.allUpperWordStyle : startWithUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, upperUnderscore ? Strings_1.allUpperWordStyle : Strings_1.firstUpperWordStyle, upperUnderscore || startWithUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, upperUnderscore ? "_" : "", isStartCharacter);
    }
    exports.phpNameStyle = phpNameStyle;
    var PhpRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = /* @__PURE__ */ new Map();
        this._haveEmittedLeadingComments = false;
        this._converterClassname = "Converter";
        this._converterKeywords = [];
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return this.getNameStyling("typeNamingFunction");
      }
      namerForObjectProperty() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeUnionMemberNamer() {
        return this.getNameStyling("propertyNamingFunction");
      }
      makeEnumCaseNamer() {
        return this.getNameStyling("enumCaseNamingFunction");
      }
      unionNeedsName(u) {
        return (0, TypeUtils_1.nullableFromUnion)(u) === null;
      }
      namedTypeToNameForTopLevel(type) {
        return (0, TypeUtils_1.directlyReachableSingleNamedType)(type);
      }
      makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `get_${lookup(name)}`);
        const setterName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `set_${lookup(name)}`);
        const validateName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `validate_${lookup(name)}`);
        const fromName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `from_${lookup(name)}`);
        const toName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `to_${lookup(name)}`);
        const sampleName = new Naming_1.DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, (lookup) => `sample_${lookup(name)}`);
        return {
          getter: getterName,
          setter: setterName,
          validate: validateName,
          from: fromName,
          to: toName,
          sample: sampleName
        };
      }
      makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return [
          getterAndSetterNames.getter,
          getterAndSetterNames.setter,
          getterAndSetterNames.validate,
          getterAndSetterNames.to,
          getterAndSetterNames.from,
          getterAndSetterNames.sample
        ];
      }
      getNameStyling(convention) {
        const styling = {
          typeNamingFunction: (0, Naming_1.funPrefixNamer)("types", (n) => phpNameStyle(true, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          propertyNamingFunction: (0, Naming_1.funPrefixNamer)("properties", (n) => phpNameStyle(false, false, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle))),
          enumCaseNamingFunction: (0, Naming_1.funPrefixNamer)("enum-cases", (n) => phpNameStyle(true, true, n, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)))
        };
        return styling[convention];
      }
      startFile(_basename) {
        this.ensureBlankLine();
        if (!this._haveEmittedLeadingComments && this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          this.ensureBlankLine();
          this._haveEmittedLeadingComments = true;
        }
      }
      finishFile() {
      }
      emitFileHeader(fileName, _imports) {
        this.startFile(fileName);
        this.emitLine("// This is a autogenerated file:", fileName);
        this.ensureBlankLine();
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      phpType(_reference, t, isOptional = false, prefix = "?", suffix = "") {
        function optionalize(s) {
          return [isOptional ? prefix : "", s, isOptional ? suffix : ""];
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(isOptional, Annotation_1.anyTypeIssueAnnotation, "Object"), (_nullType) => (0, Source_1.maybeAnnotated)(isOptional, Annotation_1.nullTypeIssueAnnotation, "Object"), (_boolType) => optionalize("bool"), (_integerType) => optionalize("int"), (_doubleType) => optionalize("float"), (_stringType) => optionalize("string"), (_arrayType) => optionalize("array"), (classType) => optionalize(this.nameForNamedType(classType)), (_mapType) => optionalize("stdClass"), (enumType) => optionalize(this.nameForNamedType(enumType)), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return this.phpType(true, nullable, true, prefix, suffix);
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "time") {
            throw Error('transformedStringType.kind === "time"');
          }
          if (transformedStringType.kind === "date") {
            throw Error('transformedStringType.kind === "date"');
          }
          if (transformedStringType.kind === "date-time") {
            return "DateTime";
          }
          if (transformedStringType.kind === "uuid") {
            throw Error('transformedStringType.kind === "uuid"');
          }
          return "string";
        });
      }
      phpDocConvertType(className, t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => "any", (_nullType) => "null", (_boolType) => "bool", (_integerType) => "int", (_doubleType) => "float", (_stringType) => "string", (arrayType) => [this.phpDocConvertType(className, arrayType.items), "[]"], (_classType) => _classType.getCombinedName(), (_mapType) => "stdClass", (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return [this.phpDocConvertType(className, nullable), "|null"];
          }
          throw Error("union are not supported");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "DateTime";
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      phpConvertType(className, t) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => "any",
          (_nullType) => "null",
          (_boolType) => "bool",
          (_integerType) => "int",
          (_doubleType) => "float",
          (_stringType) => "string",
          (_arrayType) => "array",
          (_classType) => "stdClass",
          (_mapType) => "stdClass",
          (_enumType) => "string",
          // TODO number this.nameForNamedType(enumType),
          // TODO number this.nameForNamedType(enumType),
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            if (nullable !== null) {
              return ["?", this.phpConvertType(className, nullable)];
            }
            throw Error("union are not supported");
          },
          (transformedStringType) => {
            if (transformedStringType.kind === "date-time") {
              return "string";
            }
            throw Error('transformedStringType.kind === "unknown"');
          }
        );
      }
      phpToObjConvert(className, t, lhs, args) {
        (0, TypeUtils_1.matchType)(t, (_anyType) => this.emitLine(...lhs, ...args, "; /*any*/"), (_nullType) => this.emitLine(...lhs, ...args, "; /*null*/"), (_boolType) => this.emitLine(...lhs, ...args, "; /*bool*/"), (_integerType) => this.emitLine(...lhs, ...args, "; /*int*/"), (_doubleType) => this.emitLine(...lhs, ...args, "; /*float*/"), (_stringType) => this.emitLine(...lhs, ...args, "; /*string*/"), (arrayType) => {
          this.emitLine(...lhs, "array_map(function ($value) {");
          this.indent(() => {
            this.phpToObjConvert(className, arrayType.items, ["return "], ["$value"]);
          });
          this.emitLine("}, ", ...args, ");");
        }, (_classType) => this.emitLine(...lhs, ...args, "->to(); ", "/*class*/"), (mapType) => {
          this.emitBlock(["function to($my): stdClass"], () => {
            this.emitLine("$out = new stdClass();");
            this.emitBlock(["foreach ($my as $k => $v)"], () => {
              this.phpToObjConvert(className, mapType.values, ["$my->$k = "], ["$v"]);
            });
            this.emitLine("return $out;");
          });
          this.emitLine("return to(", ...args, ");");
        }, (enumType) => this.emitLine(...lhs, this.nameForNamedType(enumType), "::to(", ...args, "); ", "/*enum*/"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitLine("if (!is_null(", ...args, ")) {");
            this.indent(() => this.phpToObjConvert(className, nullable, lhs, args));
            this.emitLine("} else {");
            this.indent(() => this.emitLine(...lhs, " null;"));
            this.emitLine("}");
            return;
          }
          throw Error("union are not supported");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            this.emitLine(...lhs, ...args, "->format(DateTimeInterface::ISO8601);");
            return;
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      transformDateTime(className, attrName, scopeAttrName) {
        this.emitBlock(["if (!is_a(", scopeAttrName, ", 'DateTime'))"], () => this.emitLine("throw new Exception('Attribute Error:", className, "::", attrName, "');"));
      }
      phpFromObjConvert(className, t, lhs, args) {
        (0, TypeUtils_1.matchType)(t, (_anyType) => this.emitLine(...lhs, ...args, "; /*any*/"), (_nullType) => this.emitLine(...lhs, ...args, "; /*null*/"), (_boolType) => this.emitLine(...lhs, ...args, "; /*bool*/"), (_integerType) => this.emitLine(...lhs, ...args, "; /*int*/"), (_doubleType) => this.emitLine(...lhs, ...args, "; /*float*/"), (_stringType) => this.emitLine(...lhs, ...args, "; /*string*/"), (arrayType) => {
          this.emitLine(...lhs, " array_map(function ($value) {");
          this.indent(() => {
            this.phpFromObjConvert(className, arrayType.items, ["return "], ["$value"]);
          });
          this.emitLine("}, ", ...args, ");");
        }, (classType) => this.emitLine(...lhs, this.nameForNamedType(classType), "::from(", ...args, "); ", "/*class*/"), (mapType) => {
          this.emitBlock(["function from($my): stdClass"], () => {
            this.emitLine("$out = new stdClass();");
            this.emitBlock(["foreach ($my as $k => $v)"], () => {
              this.phpFromObjConvert(className, mapType.values, ["$out->$k = "], ["$v"]);
            });
            this.emitLine("return $out;");
          });
          this.emitLine("return from(", ...args, ");");
        }, (enumType) => this.emitLine(...lhs, this.nameForNamedType(enumType), "::from(", ...args, "); ", "/*enum*/"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitLine("if (!is_null(", ...args, ")) {");
            this.indent(() => this.phpFromObjConvert(className, nullable, lhs, args));
            this.emitLine("} else {");
            this.indent(() => this.emitLine("return null;"));
            this.emitLine("}");
            return;
          }
          throw Error("union are not supported");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            this.emitLine("$tmp = ", "DateTime::createFromFormat(DateTimeInterface::ISO8601, ", args, ");");
            this.transformDateTime(className, "", ["$tmp"]);
            this.emitLine("return $tmp;");
            return;
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      phpSampleConvert(className, t, lhs, args, idx, suffix) {
        (0, TypeUtils_1.matchType)(t, (_anyType) => this.emitLine(...lhs, "'AnyType::", className, "::", args, "::" + idx, "'", suffix, "/*", "" + idx, ":", args, "*/"), (_nullType) => this.emitLine(...lhs, "null", suffix, " /*", "" + idx, ":", args, "*/"), (_boolType) => this.emitLine(...lhs, "true", suffix, " /*", "" + idx, ":", args, "*/"), (_integerType) => this.emitLine(...lhs, "" + idx, suffix, " /*", "" + idx, ":", args, "*/"), (_doubleType) => this.emitLine(...lhs, "" + (idx + idx / 1e3), suffix, " /*", "" + idx, ":", args, "*/"), (_stringType) => this.emitLine(...lhs, "'", className, "::", args, "::" + idx, "'", suffix, " /*", "" + idx, ":", args, "*/"), (arrayType) => {
          this.emitLine(...lhs, " array(");
          this.indent(() => {
            this.phpSampleConvert(className, arrayType.items, [], [], idx, "");
          });
          this.emitLine("); /* ", "" + idx, ":", args, "*/");
        }, (classType) => this.emitLine(...lhs, this.nameForNamedType(classType), "::sample()", suffix, " /*", "" + idx, ":", args, "*/"), (mapType) => {
          this.emitBlock(["function sample(): stdClass"], () => {
            this.emitLine("$out = new stdClass();");
            this.phpSampleConvert(className, mapType.values, ["$out->{'", className, "'} = "], args, idx, ";");
            this.emitLine("return $out;");
          });
          this.emitLine("return sample();");
        }, (enumType) => this.emitLine(...lhs, this.nameForNamedType(enumType), "::sample()", suffix, " /*enum*/"), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.phpSampleConvert(className, nullable, lhs, args, idx, suffix);
            return;
          }
          throw Error("union are not supported:" + unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            const x = _.pad("" + (1 + idx % 31), 2, "0");
            this.emitLine(...lhs, "DateTime::createFromFormat(DateTimeInterface::ISO8601, '", `2020-12-${x}T12:${x}:${x}+00:00`, "')", suffix);
            return;
          }
          throw Error('transformedStringType.kind === "unknown"');
        });
      }
      phpValidate(className, t, attrName, scopeAttrName) {
        const is = (isfn, myT = className) => {
          this.emitBlock(["if (!", isfn, "(", scopeAttrName, "))"], () => this.emitLine('throw new Exception("Attribute Error:', myT, "::", attrName, '");'));
        };
        (0, TypeUtils_1.matchType)(t, (_anyType) => is("defined"), (_nullType) => is("is_null"), (_boolType) => is("is_bool"), (_integerType) => is("is_integer"), (_doubleType) => is("is_float"), (_stringType) => is("is_string"), (arrayType) => {
          is("is_array");
          this.emitLine("array_walk(", scopeAttrName, ", function(", scopeAttrName, "_v) {");
          this.indent(() => {
            this.phpValidate(className, arrayType.items, attrName, `${scopeAttrName}_v`);
          });
          this.emitLine("});");
        }, (_classType) => {
          this.emitLine(scopeAttrName, "->validate();");
        }, (mapType) => {
          this.emitLine("foreach (", scopeAttrName, " as $k => $v) {");
          this.indent(() => {
            this.phpValidate(className, mapType.values, attrName, "$v");
          });
          this.emitLine("}");
        }, (enumType) => {
          this.emitLine(this.phpType(false, enumType), "::to(", scopeAttrName, ");");
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            this.emitBlock(["if (!is_null(", scopeAttrName, "))"], () => {
              this.phpValidate(className, nullable, attrName, scopeAttrName);
            });
            return;
          }
          throw Error("not implemented");
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            this.transformDateTime(className, attrName, [scopeAttrName]);
            return;
          }
          throw Error(`transformedStringType.kind === ${transformedStringType.kind}`);
        });
      }
      emitFromMethod(names, p, className, _name, desc) {
        this.emitLine("/**");
        if (desc !== void 0) {
          this.emitLine(" * ", desc);
          this.emitLine(" *");
        }
        this.emitLine(" * @param ", this.phpConvertType(className, p.type), " $value");
        this.emitLine(" * @throws Exception");
        this.emitLine(" * @return ", this.phpType(false, p.type));
        this.emitLine(" */");
        this.emitBlock([
          "public static function ",
          names.from,
          "(",
          this.phpConvertType(className, p.type),
          " $value): ",
          this.phpType(false, p.type)
        ], () => {
          this.phpFromObjConvert(className, p.type, ["return "], ["$value"]);
        });
      }
      emitToMethod(names, p, className, name, desc) {
        this.emitLine("/**");
        if (desc !== void 0) {
          this.emitLine(" * ", desc);
          this.emitLine(" *");
        }
        this.emitLine(" * @throws Exception");
        this.emitLine(" * @return ", this.phpConvertType(className, p.type));
        this.emitLine(" */");
        this.emitBlock(["public function ", names.to, "(): ", this.phpConvertType(className, p.type)], () => {
          this.emitBlock(["if (", className, "::", names.validate, "($this->", name, ")) "], () => {
            this.phpToObjConvert(className, p.type, ["return "], ["$this->", name]);
          });
          this.emitLine("throw new Exception('never get to this ", className, "::", name, "');");
        });
      }
      emitValidateMethod(names, p, className, name, desc) {
        this.emitLine("/**");
        if (desc !== void 0) {
          this.emitLine(" * ", desc);
          this.emitLine(" *");
        }
        this.emitLine(" * @param ", this.phpType(false, p.type, false, "", "|null"));
        this.emitLine(" * @return bool");
        this.emitLine(" * @throws Exception");
        this.emitLine(" */");
        this.emitBlock(["public static function ", names.validate, "(", this.phpType(false, p.type), " $value): bool"], () => {
          this.phpValidate(className, p.type, name, "$value");
          this.emitLine("return true;");
        });
      }
      emitGetMethod(names, p, className, name, desc) {
        if (this._options.withGet) {
          this.emitLine("/**");
          if (desc !== void 0) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
          }
          if (!this._options.fastGet) {
            this.emitLine(" * @throws Exception");
          }
          const rendered = this.phpType(false, p.type);
          this.emitLine(" * @return ", rendered);
          this.emitLine(" */");
          this.emitBlock(["public function ", names.getter, "(): ", rendered], () => {
            if (!this._options.fastGet) {
              this.emitBlock(["if (", className, "::", names.validate, "($this->", name, ")) "], () => {
                this.emitLine("return $this->", name, ";");
              });
              this.emitLine("throw new Exception('never get to ", names.getter, " ", className, "::", name, "');");
            } else {
              this.emitLine("return $this->", name, ";");
            }
          });
        }
      }
      emitSetMethod(names, p, className, name, desc) {
        if (this._options.withSet) {
          this.emitLine("/**");
          if (desc !== void 0) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
          }
          this.emitLine(" * @param ", this.phpType(false, p.type, false, "", "|null"));
          this.emitLine(" * @throws Exception");
          this.emitLine(" */");
          this.emitBlock(["public function ", names.setter, "(", this.phpType(false, p.type), " $value)"], () => {
            this.emitBlock(["if (", className, "::", names.validate, "($value)) "], () => {
              this.emitLine("$this->", name, " = $value;");
            });
          });
        }
      }
      emitSampleMethod(names, p, className, name, desc, idx) {
        if (this._options.withGet) {
          this.emitLine("/**");
          if (desc !== void 0) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
          }
          const rendered = this.phpType(false, p.type);
          this.emitLine(" * @return ", rendered);
          this.emitLine(" */");
          this.emitBlock(["public static function ", names.sample, "(): ", rendered], () => {
            this.phpSampleConvert(className, p.type, ["return "], [name], idx, ";");
          });
        }
      }
      emitClassDefinition(c, className) {
        this.emitFileHeader(className, []);
        this.emitBlock(["class ", className], () => {
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            this.emitLine("private ", this.phpType(false, p.type), " $", name, "; // json:", jsonName, " ", p.type.isNullable ? "Optional" : "Required");
          });
          this.ensureBlankLine();
          const comments = [];
          const args = [];
          let prefix = "";
          this.forEachClassProperty(c, "none", (name, __, p) => {
            args.push([prefix, this.phpType(false, p.type), " $", name]);
            prefix = ", ";
            comments.push([" * @param ", this.phpType(false, p.type, false, "", "|null"), " $", name, "\n"]);
          });
          this.emitBlock(["/**\n", ...comments, " */\n", "public function __construct(", ...args, ")"], () => {
            this.forEachClassProperty(c, "none", (name) => {
              this.emitLine("$this->", name, " = $", name, ";");
            });
          });
          let idx = 31;
          this.forEachClassProperty(c, "leading-and-interposing", (name, jsonName, p) => {
            const desc = this.descriptionForClassProperty(c, jsonName);
            const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
            this.ensureBlankLine();
            this.emitFromMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitToMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitValidateMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitGetMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitSetMethod(names, p, className, name, desc);
            this.ensureBlankLine();
            this.emitSampleMethod(names, p, className, name, desc, idx++);
          });
          this.ensureBlankLine();
          this.emitBlock(["/**\n", " * @throws Exception\n", " * @return bool\n", " */\n", "public function validate(): bool"], () => {
            let lines = [];
            let p = "return ";
            this.forEachClassProperty(c, "none", (name, _jsonName, _p) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              lines.push([p, className, "::", names.validate, "($this->", name, ")"]);
              p = "|| ";
            });
            lines.forEach((line, jdx) => {
              this.emitLine(...line, lines.length === jdx + 1 ? ";" : "");
            });
          });
          this.ensureBlankLine();
          this.emitBlock([
            "/**\n",
            " * @return stdClass\n",
            " * @throws Exception\n",
            " */\n",
            "public function to(): stdClass "
          ], () => {
            this.emitLine("$out = new stdClass();");
            this.forEachClassProperty(c, "none", (name, jsonName) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              this.emitLine("$out->{'", jsonName, "'} = $this->", names.to, "();");
            });
            this.emitLine("return $out;");
          });
          this.ensureBlankLine();
          this.emitBlock([
            "/**\n",
            " * @param stdClass $obj\n",
            " * @return ",
            className,
            "\n",
            " * @throws Exception\n",
            " */\n",
            "public static function from(stdClass $obj): ",
            className
          ], () => {
            if (this._options.fastGet) {
              this.forEachClassProperty(c, "none", (name) => {
                const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
                this.emitLine(className, "::", names.validate, "($this->", name, ", true);");
              });
            }
            this.emitLine("return new ", className, "(");
            let comma = " ";
            this.forEachClassProperty(c, "none", (name, jsonName) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              this.emitLine(comma, className, "::", names.from, "($obj->{'", jsonName, "'})");
              comma = ",";
            });
            this.emitLine(");");
          });
          this.ensureBlankLine();
          this.emitBlock(["/**\n", " * @return ", className, "\n", " */\n", "public static function sample(): ", className], () => {
            this.emitLine("return new ", className, "(");
            let comma = " ";
            this.forEachClassProperty(c, "none", (name) => {
              const names = (0, Support_1.defined)(this._gettersAndSettersForPropertyName.get(name));
              this.emitLine(comma, className, "::", names.sample, "()");
              comma = ",";
            });
            this.emitLine(");");
          });
        });
        this.finishFile();
      }
      emitUnionAttributes(_u, _unionName) {
      }
      emitUnionSerializer(_u, _unionName) {
      }
      emitUnionDefinition(_u, _unionName) {
        throw Error("emitUnionDefinition not implemented");
      }
      emitEnumSerializationAttributes(_e) {
      }
      emitEnumDeserializationAttributes(_e) {
      }
      emitEnumDefinition(e, enumName) {
        this.emitFileHeader(enumName, []);
        this.emitDescription(this.descriptionForType(e));
        const caseNames = [];
        caseNames.push(";");
        const enumSerdeType = "string";
        this.emitBlock(["class ", enumName], () => {
          this.forEachEnumCase(e, "none", (name, _jsonName) => {
            this.emitLine("public static ", enumName, " $", name, ";");
          });
          this.emitBlock("public static function init()", () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine(enumName, "::$", name, " = new ", enumName, "('", jsonName, "');");
            });
          });
          this.emitLine("private ", enumSerdeType, " $enum;");
          this.emitBlock(["public function __construct(", enumSerdeType, " $enum)"], () => {
            this.emitLine("$this->enum = $enum;");
          });
          this.ensureBlankLine();
          this.emitEnumSerializationAttributes(e);
          this.emitBlock([
            "/**\n",
            " * @param ",
            enumName,
            "\n",
            " * @return ",
            enumSerdeType,
            "\n",
            " * @throws Exception\n",
            " */\n",
            "public static function to(",
            enumName,
            " $obj): ",
            enumSerdeType
          ], () => {
            this.emitLine("switch ($obj->enum) {");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("case ", enumName, "::$", name, "->enum: return '", (0, exports.stringEscape)(jsonName), "';");
              });
            });
            this.emitLine("}");
            this.emitLine("throw new Exception('the give value is not an enum-value.');");
          });
          this.ensureBlankLine();
          this.emitEnumDeserializationAttributes(e);
          this.emitBlock([
            "/**\n",
            " * @param mixed\n",
            " * @return ",
            enumName,
            "\n",
            " * @throws Exception\n",
            " */\n",
            "public static function from($obj): ",
            enumName
          ], () => {
            this.emitLine("switch ($obj) {");
            this.indent(() => {
              this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("case '", (0, exports.stringEscape)(jsonName), "': return ", enumName, "::$", name, ";");
              });
            });
            this.emitLine("}");
            this.emitLine('throw new Exception("Cannot deserialize ', enumName, '");');
          });
          this.ensureBlankLine();
          this.emitBlock(["/**\n", " * @return ", enumName, "\n", " */\n", "public static function sample(): ", enumName], () => {
            const lines = [];
            this.forEachEnumCase(e, "none", (name) => {
              lines.push([enumName, "::$", name]);
            });
            this.emitLine("return ", lines[0], ";");
          });
        });
        this.emitLine(enumName, "::init();");
        this.finishFile();
      }
      emitSourceStructure(givenFilename) {
        this.emitLine("<?php");
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
        if (this._options.withClosing) {
          this.emitLine("?>");
        }
        super.finishFile((0, Support_1.defined)(givenFilename));
      }
    };
    exports.PhpRenderer = PhpRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Pike.js
var require_Pike = __commonJS({
  "node_modules/quicktype-core/dist/language/Pike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PikeRenderer = exports.PikeTargetLanguage = exports.pikeOptions = void 0;
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    exports.pikeOptions = {};
    var keywords = [
      "auto",
      "nomask",
      "final",
      "static",
      "extern",
      "private",
      "local",
      "public",
      "protected",
      "inline",
      "optional",
      "variant",
      "void",
      "mixed",
      "array",
      "__attribute__",
      "__deprecated__",
      "mapping",
      "multiset",
      "object",
      "function",
      "__func__",
      "program",
      "string",
      "float",
      "int",
      "enum",
      "typedef",
      "if",
      "do",
      "for",
      "while",
      "else",
      "foreach",
      "catch",
      "gauge",
      "class",
      "break",
      "case",
      "const",
      "constant",
      "continue",
      "default",
      "import",
      "inherit",
      "lambda",
      "predef",
      "return",
      "sscanf",
      "switch",
      "typeof",
      "global"
    ];
    var legalizeName = (0, Strings_1.legalizeCharacters)(Strings_1.isLetterOrUnderscoreOrDigit);
    var enumNamingFunction = (0, Naming_1.funPrefixNamer)("enumNamer", (0, Strings_1.makeNameStyle)("upper-underscore", legalizeName));
    var namingFunction = (0, Naming_1.funPrefixNamer)("genericNamer", (0, Strings_1.makeNameStyle)("underscore", legalizeName));
    var namedTypeNamingFunction = (0, Naming_1.funPrefixNamer)("typeNamer", (0, Strings_1.makeNameStyle)("pascal", legalizeName));
    var PikeTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Pike", ["pike", "pikelang"], "pmod");
      }
      getOptions() {
        return [];
      }
      makeRenderer(renderContext) {
        return new PikeRenderer(this, renderContext);
      }
    };
    exports.PikeTargetLanguage = PikeTargetLanguage;
    var PikeRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      emitSourceStructure() {
        this.emitInformationComment();
        this.ensureBlankLine();
        this.forEachTopLevel("leading", (t, name) => {
          this.emitTopLevelTypedef(t, name);
          this.ensureBlankLine();
          this.emitTopLevelConverter(t, name);
          this.ensureBlankLine();
        }, (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.ensureBlankLine();
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
      }
      get enumCasesInGlobalNamespace() {
        return true;
      }
      makeEnumCaseNamer() {
        return enumNamingFunction;
      }
      makeNamedTypeNamer() {
        return namedTypeNamingFunction;
      }
      makeUnionMemberNamer() {
        return namingFunction;
      }
      namerForObjectProperty() {
        return namingFunction;
      }
      forbiddenNamesForGlobalNamespace() {
        return [...keywords];
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
      }
      sourceFor(t) {
        if (["class", "object", "enum"].includes(t.kind)) {
          return (0, Source_1.singleWord)(this.nameForNamedType(t));
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("mixed"), (_nullType) => (0, Source_1.singleWord)("mixed"), (_boolType) => (0, Source_1.singleWord)("bool"), (_integerType) => (0, Source_1.singleWord)("int"), (_doubleType) => (0, Source_1.singleWord)("float"), (_stringType) => (0, Source_1.singleWord)("string"), (arrayType) => (0, Source_1.singleWord)(["array(", this.sourceFor(arrayType.items).source, ")"]), (_classType) => (0, Source_1.singleWord)(this.nameForNamedType(_classType)), (mapType) => {
          let valueSource;
          const v = mapType.values;
          valueSource = this.sourceFor(v).source;
          return (0, Source_1.singleWord)(["mapping(string:", valueSource, ")"]);
        }, (_enumType) => (0, Source_1.singleWord)("enum"), (unionType) => {
          if ((0, TypeUtils_1.nullableFromUnion)(unionType) !== null) {
            const children = Array.from(unionType.getChildren()).map((c) => (0, Source_1.parenIfNeeded)(this.sourceFor(c)));
            return (0, Source_1.multiWord)("|", ...children);
          } else {
            return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
          }
        });
      }
      emitClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock(["class ", className], () => {
          this.emitClassMembers(c);
          this.ensureBlankLine();
          this.emitEncodingFunction(c);
        });
        this.ensureBlankLine();
        this.emitDecodingFunction(className, c);
      }
      emitEnum(e, enumName) {
        this.emitBlock([e.kind, " ", enumName], () => {
          let table = [];
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            table.push([
              [name, ' = "', (0, Strings_1.stringEscape)(jsonName), '", '],
              ['// json: "', jsonName, '"']
            ]);
          });
          this.emitTable(table);
        });
      }
      emitUnion(u, unionName) {
        const isMaybeWithSingleType = (0, TypeUtils_1.nullableFromUnion)(u);
        if (isMaybeWithSingleType !== null) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        let types = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_name, t) => {
          const pikeType = this.sourceFor(t).source;
          types.push([pikeType]);
        });
        this.emitLine([
          "typedef ",
          types.map((r) => r.map((sl) => this.sourcelikeToString(sl))).join("|"),
          " ",
          unionName,
          ";"
        ]);
        this.ensureBlankLine();
        this.emitBlock([unionName, " ", unionName, "_from_JSON(mixed json)"], () => {
          this.emitLine(["return json;"]);
        });
      }
      emitBlock(line, f, opening = " {", closing = "}") {
        this.emitLine(line, opening);
        this.indent(f);
        this.emitLine(closing);
      }
      emitMappingBlock(line, f) {
        this.emitBlock(line, f, "([", "]);");
      }
      emitClassMembers(c) {
        let table = [];
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
          const pikeType = this.sourceFor(p.type).source;
          table.push([
            [pikeType, " "],
            [name, "; "],
            ['// json: "', jsonName, '"']
          ]);
        });
        this.emitTable(table);
      }
      emitInformationComment() {
        this.emitCommentLines([
          "This source has been automatically generated by quicktype.",
          "( https://github.com/quicktype/quicktype )",
          "",
          "To use this code, simply import it into your project as a Pike module.",
          "To JSON-encode your object, you can pass it to `Standards.JSON.encode`",
          "or call `encode_json` on it.",
          "",
          "To decode a JSON string, first pass it to `Standards.JSON.decode`,",
          "and then pass the result to `<YourClass>_from_JSON`.",
          "It will return an instance of <YourClass>.",
          "Bear in mind that these functions have unexpected behavior,",
          "and will likely throw an error, if the JSON string does not",
          "match the expected interface, even if the JSON itself is valid."
        ], { lineStart: "// " });
      }
      emitTopLevelTypedef(t, name) {
        this.emitLine("typedef ", this.sourceFor(t).source, " ", name, ";");
      }
      emitTopLevelConverter(t, name) {
        this.emitBlock([name, " ", name, "_from_JSON(mixed json)"], () => {
          if (t instanceof Type_1.PrimitiveType) {
            this.emitLine(["return json;"]);
          } else if (t instanceof Type_1.ArrayType) {
            if (t.items instanceof Type_1.PrimitiveType)
              this.emitLine(["return json;"]);
            else
              this.emitLine(["return map(json, ", this.sourceFor(t.items).source, "_from_JSON);"]);
          } else if (t instanceof Type_1.MapType) {
            const type = this.sourceFor(t.values).source;
            this.emitLine(["mapping(string:", type, ") retval = ([]);"]);
            let assignmentRval;
            if (t.values instanceof Type_1.PrimitiveType)
              assignmentRval = ["(", type, ") v"];
            else
              assignmentRval = [type, "_from_JSON(v)"];
            this.emitBlock(["foreach (json; string k; mixed v)"], () => {
              this.emitLine(["retval[k] = ", assignmentRval, ";"]);
            });
            this.emitLine(["return retval;"]);
          }
        });
      }
      emitEncodingFunction(c) {
        this.emitBlock(["string encode_json()"], () => {
          this.emitMappingBlock(["mapping(string:mixed) json = "], () => {
            this.forEachClassProperty(c, "none", (name, jsonName) => {
              this.emitLine(['"', (0, Strings_1.stringEscape)(jsonName), '" : ', name, ","]);
            });
          });
          this.ensureBlankLine();
          this.emitLine(["return Standards.JSON.encode(json);"]);
        });
      }
      emitDecodingFunction(className, c) {
        this.emitBlock([className, " ", className, "_from_JSON(mixed json)"], () => {
          this.emitLine([className, " retval = ", className, "();"]);
          this.ensureBlankLine();
          this.forEachClassProperty(c, "none", (name, jsonName) => {
            this.emitLine(["retval.", name, ' = json["', (0, Strings_1.stringEscape)(jsonName), '"];']);
          });
          this.ensureBlankLine();
          this.emitLine(["return retval;"]);
        });
      }
    };
    exports.PikeRenderer = PikeRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Python.js
var require_Python = __commonJS({
  "node_modules/quicktype-core/dist/language/Python.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONPythonRenderer = exports.PythonRenderer = exports.PythonTargetLanguage = exports.pythonOptions = void 0;
    var collection_utils_1 = require_dist();
    var unicode_properties_1 = __importDefault(require_main());
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var forbiddenTypeNames = [
      "Any",
      "True",
      "False",
      "None",
      "Enum",
      "List",
      "Dict",
      "Optional",
      "Union",
      "Iterable",
      "Type",
      "TypeVar",
      "T",
      "EnumT"
    ];
    var forbiddenPropertyNames = [
      "and",
      "as",
      "assert",
      "async",
      "await",
      "bool",
      "break",
      "class",
      "continue",
      "datetime",
      "def",
      "del",
      "dict",
      "elif",
      "else",
      "except",
      "finally",
      "float",
      "for",
      "from",
      "global",
      "if",
      "import",
      "in",
      "int",
      "is",
      "lambda",
      "nonlocal",
      "not",
      "or",
      "pass",
      "print",
      "raise",
      "return",
      "self",
      "str",
      "try",
      "while",
      "with",
      "yield"
    ];
    exports.pythonOptions = {
      features: new RendererOptions_1.EnumOption("python-version", "Python version", [
        ["3.5", { typeHints: false, dataClasses: false }],
        ["3.6", { typeHints: true, dataClasses: false }],
        ["3.7", { typeHints: true, dataClasses: true }]
      ], "3.6"),
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Classes only", false),
      nicePropertyNames: new RendererOptions_1.BooleanOption("nice-property-names", "Transform property names to be Pythonic", true)
    };
    var PythonTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      getOptions() {
        return [exports.pythonOptions.features, exports.pythonOptions.justTypes, exports.pythonOptions.nicePropertyNames];
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("time", dateTimeType);
        mapping.set("date-time", dateTimeType);
        mapping.set("uuid", "uuid");
        mapping.set("integer-string", "integer-string");
        mapping.set("bool-string", "bool-string");
        return mapping;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      get supportsOptionalClassProperties() {
        return false;
      }
      needsTransformerForType(t) {
        if (t instanceof Type_1.UnionType) {
          return (0, collection_utils_1.iterableSome)(t.members, (m) => this.needsTransformerForType(m));
        }
        return t.kind === "integer-string" || t.kind === "bool-string";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.pythonOptions, untypedOptionValues);
        if (options.justTypes) {
          return new PythonRenderer(this, renderContext, options);
        } else {
          return new JSONPythonRenderer(this, renderContext, options);
        }
      }
    };
    exports.PythonTargetLanguage = PythonTargetLanguage;
    function isNormalizedStartCharacter3(utf16Unit) {
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return ["Lu", "Ll", "Lt", "Lm", "Lo", "Nl"].includes(category);
    }
    function isNormalizedPartCharacter3(utf16Unit) {
      if (isNormalizedStartCharacter3(utf16Unit))
        return true;
      const category = unicode_properties_1.default.getCategory(utf16Unit);
      return ["Mn", "Mc", "Nd", "Pc"].includes(category);
    }
    function isStartCharacter3(utf16Unit) {
      const s = String.fromCharCode(utf16Unit).normalize("NFKC");
      const l = s.length;
      if (l === 0 || !isNormalizedStartCharacter3(s.charCodeAt(0)))
        return false;
      for (let i = 1; i < l; i++) {
        if (!isNormalizedPartCharacter3(s.charCodeAt(i)))
          return false;
      }
      return true;
    }
    function isPartCharacter3(utf16Unit) {
      const s = String.fromCharCode(utf16Unit).normalize("NFKC");
      const l = s.length;
      for (let i = 0; i < l; i++) {
        if (!isNormalizedPartCharacter3(s.charCodeAt(i)))
          return false;
      }
      return true;
    }
    var legalizeName3 = (0, Strings_1.utf16LegalizeCharacters)(isPartCharacter3);
    function classNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName3, Strings_1.firstUpperWordStyle, Strings_1.firstUpperWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter3);
    }
    function getWordStyle(uppercase, forceSnakeNameStyle) {
      if (!forceSnakeNameStyle) {
        return Strings_1.originalWord;
      }
      return uppercase ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle;
    }
    function snakeNameStyle(original, uppercase, forceSnakeNameStyle) {
      const wordStyle = getWordStyle(uppercase, forceSnakeNameStyle);
      const separator = forceSnakeNameStyle ? "_" : "";
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName3, wordStyle, wordStyle, wordStyle, wordStyle, separator, isStartCharacter3);
    }
    var PythonRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, pyOptions) {
        super(targetLanguage, renderContext);
        this.pyOptions = pyOptions;
        this.imports = /* @__PURE__ */ new Map();
        this.declaredTypes = /* @__PURE__ */ new Set();
      }
      forbiddenNamesForGlobalNamespace() {
        return forbiddenTypeNames;
      }
      forbiddenForObjectProperties(_, _classNamed) {
        return { names: forbiddenPropertyNames, includeGlobalForbidden: false };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("type", classNameStyle);
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("property", (s) => snakeNameStyle(s, false, this.pyOptions.nicePropertyNames));
      }
      makeUnionMemberNamer() {
        return null;
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-case", (s) => snakeNameStyle(s, true, this.pyOptions.nicePropertyNames));
      }
      get commentLineStart() {
        return "# ";
      }
      emitDescriptionBlock(lines) {
        if (lines.length === 1) {
          const docstring = (0, Source_1.modifySource)((content) => {
            if (content.endsWith('"')) {
              return content.slice(0, -1) + '\\"';
            }
            return content;
          }, lines[0]);
          this.emitComments([{ customLines: [docstring], lineStart: '"""', lineEnd: '"""' }]);
        } else {
          this.emitCommentLines(lines, {
            firstLineStart: '"""',
            lineStart: "",
            afterComment: '"""'
          });
        }
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        const kind = t.kind;
        return kind === "class" || kind === "enum";
      }
      emitBlock(line, f) {
        this.emitLine(line);
        this.indent(f);
      }
      string(s) {
        const openQuote = '"';
        return [openQuote, (0, Strings_1.stringEscape)(s), '"'];
      }
      withImport(module2, name) {
        if (this.pyOptions.features.typeHints || module2 !== "typing") {
          (0, collection_utils_1.mapUpdateInto)(this.imports, module2, (s) => s ? (0, collection_utils_1.setUnionInto)(s, [name]) : /* @__PURE__ */ new Set([name]));
        }
        return name;
      }
      withTyping(name) {
        return this.withImport("typing", name);
      }
      namedType(t) {
        const name = this.nameForNamedType(t);
        if (this.declaredTypes.has(t))
          return name;
        return ["'", name, "'"];
      }
      pythonType(t, _isRootTypeDef = false) {
        const actualType = (0, Transformers_1.followTargetType)(t);
        return (0, TypeUtils_1.matchType)(actualType, (_anyType) => this.withTyping("Any"), (_nullType) => "None", (_boolType) => "bool", (_integerType) => "int", (_doubletype) => "float", (_stringType) => "str", (arrayType) => [this.withTyping("List"), "[", this.pythonType(arrayType.items), "]"], (classType) => this.namedType(classType), (mapType) => [this.withTyping("Dict"), "[str, ", this.pythonType(mapType.values), "]"], (enumType) => this.namedType(enumType), (unionType) => {
          const [hasNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
          const memberTypes = Array.from(nonNulls).map((m) => this.pythonType(m));
          if (hasNull !== null) {
            let rest = [];
            if (!this.getAlphabetizeProperties() && this.pyOptions.features.dataClasses && _isRootTypeDef) {
              rest.push(" = None");
            }
            if (nonNulls.size > 1) {
              this.withImport("typing", "Union");
              return [
                this.withTyping("Optional"),
                "[Union[",
                (0, collection_utils_1.arrayIntercalate)(", ", memberTypes),
                "]]",
                ...rest
              ];
            } else {
              return [this.withTyping("Optional"), "[", (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(memberTypes)), "]", ...rest];
            }
          } else {
            return [this.withTyping("Union"), "[", (0, collection_utils_1.arrayIntercalate)(", ", memberTypes), "]"];
          }
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return this.withImport("datetime", "datetime");
          }
          if (transformedStringType.kind === "uuid") {
            return this.withImport("uuid", "UUID");
          }
          return (0, Support_1.panic)(`Transformed type ${transformedStringType.kind} not supported`);
        });
      }
      declarationLine(t) {
        if (t instanceof Type_1.ClassType) {
          return ["class ", this.nameForNamedType(t), ":"];
        }
        if (t instanceof Type_1.EnumType) {
          return ["class ", this.nameForNamedType(t), "(", this.withImport("enum", "Enum"), "):"];
        }
        return (0, Support_1.panic)(`Can't declare type ${t.kind}`);
      }
      declareType(t, emitter) {
        this.emitBlock(this.declarationLine(t), () => {
          this.emitDescription(this.descriptionForType(t));
          emitter();
        });
        this.declaredTypes.add(t);
      }
      emitClassMembers(t) {
        if (this.pyOptions.features.dataClasses)
          return;
        const args = [];
        this.forEachClassProperty(t, "none", (name, _, cp) => {
          args.push([name, this.typeHint(": ", this.pythonType(cp.type))]);
        });
        this.emitBlock(["def __init__(self, ", (0, collection_utils_1.arrayIntercalate)(", ", args), ")", this.typeHint(" -> None"), ":"], () => {
          if (args.length === 0) {
            this.emitLine("pass");
          } else {
            this.forEachClassProperty(t, "none", (name) => {
              this.emitLine("self.", name, " = ", name);
            });
          }
        });
      }
      typeHint(...sl) {
        if (this.pyOptions.features.typeHints) {
          return sl;
        }
        return [];
      }
      typingDecl(name, type) {
        return [name, this.typeHint(": ", this.withTyping(type))];
      }
      typingReturn(type) {
        return this.typeHint(" -> ", this.withTyping(type));
      }
      sortClassProperties(properties, propertyNames) {
        if (this.pyOptions.features.dataClasses) {
          return (0, collection_utils_1.mapSortBy)(properties, (p) => {
            return p.type instanceof Type_1.UnionType && (0, TypeUtils_1.nullableFromUnion)(p.type) != null || p.isOptional ? 1 : 0;
          });
        } else {
          return super.sortClassProperties(properties, propertyNames);
        }
      }
      emitClass(t) {
        if (this.pyOptions.features.dataClasses) {
          this.emitLine("@", this.withImport("dataclasses", "dataclass"));
        }
        this.declareType(t, () => {
          if (this.pyOptions.features.typeHints) {
            if (t.getProperties().size === 0) {
              this.emitLine("pass");
            } else {
              this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
                this.emitLine(name, this.typeHint(": ", this.pythonType(cp.type, true)));
                this.emitDescription(this.descriptionForClassProperty(t, jsonName));
              });
            }
            this.ensureBlankLine();
          }
          this.emitClassMembers(t);
        });
      }
      emitEnum(t) {
        this.declareType(t, () => {
          this.forEachEnumCase(t, "none", (name, jsonName) => {
            this.emitLine([name, " = ", this.string(jsonName)]);
          });
        });
      }
      emitImports() {
        this.imports.forEach((names, module2) => {
          this.emitLine("from ", module2, " import ", Array.from(names).join(", "));
        });
      }
      emitSupportCode() {
        return;
      }
      emitClosingCode() {
        return;
      }
      emitSourceStructure(_givenOutputFilename) {
        const declarationLines = this.gatherSource(() => {
          this.forEachNamedType(["interposing", 2], (c) => this.emitClass(c), (e) => this.emitEnum(e), (_u) => {
            return;
          });
        });
        const closingLines = this.gatherSource(() => this.emitClosingCode());
        const supportLines = this.gatherSource(() => this.emitSupportCode());
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        this.ensureBlankLine();
        this.emitImports();
        this.ensureBlankLine(2);
        this.emitGatheredSource(supportLines);
        this.ensureBlankLine(2);
        this.emitGatheredSource(declarationLines);
        this.ensureBlankLine(2);
        this.emitGatheredSource(closingLines);
      }
    };
    exports.PythonRenderer = PythonRenderer;
    function compose(input, f) {
      if (typeof f === "function") {
        if (input.value !== void 0) {
          return { value: f(makeValue(input)) };
        }
        if (input.lambda !== void 0) {
          return { lambda: (0, Source_1.multiWord)(" ", "lambda x:", f([(0, Source_1.parenIfNeeded)(input.lambda), "(x)"])), value: void 0 };
        }
        return { lambda: (0, Source_1.multiWord)(" ", "lambda x:", f("x")), value: void 0 };
      }
      if (f.value !== void 0) {
        return (0, Support_1.panic)("Cannot compose into a value");
      }
      if (f.lambda === void 0) {
        return input;
      }
      if (input.value === void 0) {
        if (input.lambda === void 0) {
          return f;
        }
        return {
          lambda: (0, Source_1.multiWord)("", "lambda x: ", (0, Source_1.parenIfNeeded)(f.lambda), "(", (0, Source_1.parenIfNeeded)(input.lambda), "(x))"),
          value: void 0
        };
      }
      return { lambda: f.lambda, value: makeValue(input) };
    }
    var identity = { value: void 0 };
    function makeLambda(vol) {
      if (vol.lambda !== void 0) {
        if (vol.value === void 0) {
          return vol.lambda;
        }
        return (0, Source_1.multiWord)("", "lambda x: ", (0, Source_1.parenIfNeeded)(vol.lambda), "(", vol.value, ")");
      } else if (vol.value !== void 0) {
        return (0, Source_1.multiWord)(" ", "lambda x:", vol.value);
      }
      return (0, Source_1.multiWord)(" ", "lambda x:", "x");
    }
    function makeValue(vol) {
      if (vol.value === void 0) {
        return (0, Support_1.panic)("Cannot make value from lambda without value");
      }
      if (vol.lambda !== void 0) {
        return [(0, Source_1.parenIfNeeded)(vol.lambda), "(", vol.value, ")"];
      }
      return vol.value;
    }
    var JSONPythonRenderer = class extends PythonRenderer {
      constructor() {
        super(...arguments);
        this._deserializerFunctions = /* @__PURE__ */ new Set();
        this._converterNamer = (0, Naming_1.funPrefixNamer)("converter", (s) => snakeNameStyle(s, false, this.pyOptions.nicePropertyNames));
        this._topLevelConverterNames = /* @__PURE__ */ new Map();
        this._haveTypeVar = false;
        this._haveEnumTypeVar = false;
        this._haveDateutil = false;
      }
      emitTypeVar(tvar, constraints) {
        if (!this.pyOptions.features.typeHints) {
          return;
        }
        this.emitLine(tvar, " = ", this.withTyping("TypeVar"), "(", this.string(tvar), constraints, ")");
      }
      typeVar() {
        this._haveTypeVar = true;
        this.withTyping("TypeVar");
        return "T";
      }
      enumTypeVar() {
        this._haveEnumTypeVar = true;
        this.withTyping("TypeVar");
        this.withImport("enum", "Enum");
        return "EnumT";
      }
      cast(type, v) {
        if (!this.pyOptions.features.typeHints) {
          return v;
        }
        return [this.withTyping("cast"), "(", type, ", ", v, ")"];
      }
      emitNoneConverter() {
        this.emitBlock(["def from_none(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> ", this.withTyping("Any")), ":"], () => {
          this.emitLine("assert x is None");
          this.emitLine("return x");
        });
      }
      emitBoolConverter() {
        this.emitBlock(["def from_bool(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> bool"), ":"], () => {
          this.emitLine("assert isinstance(x, bool)");
          this.emitLine("return x");
        });
      }
      emitIntConverter() {
        this.emitBlock(["def from_int(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> int"), ":"], () => {
          this.emitLine("assert isinstance(x, int) and not isinstance(x, bool)");
          this.emitLine("return x");
        });
      }
      emitFromFloatConverter() {
        this.emitBlock(["def from_float(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> float"), ":"], () => {
          this.emitLine("assert isinstance(x, (float, int)) and not isinstance(x, bool)");
          this.emitLine("return float(x)");
        });
      }
      emitToFloatConverter() {
        this.emitBlock(["def to_float(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> float"), ":"], () => {
          this.emitLine("assert isinstance(x, (int, float))");
          this.emitLine("return x");
        });
      }
      emitStrConverter() {
        this.emitBlock(["def from_str(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> str"), ":"], () => {
          const strType = "str";
          this.emitLine("assert isinstance(x, ", strType, ")");
          this.emitLine("return x");
        });
      }
      emitToEnumConverter() {
        const tvar = this.enumTypeVar();
        this.emitBlock([
          "def to_enum(c",
          this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", tvar),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, c)");
          this.emitLine("return x.value");
        });
      }
      emitListConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def from_list(f",
          this.typeHint(": ", this.withTyping("Callable"), "[[", this.withTyping("Any"), "], ", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", this.withTyping("List"), "[", tvar, "]"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, list)");
          this.emitLine("return [f(y) for y in x]");
        });
      }
      emitToClassConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def to_class(c",
          this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> dict"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, c)");
          this.emitLine("return ", this.cast(this.withTyping("Any"), "x"), ".to_dict()");
        });
      }
      emitDictConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def from_dict(f",
          this.typeHint(": ", this.withTyping("Callable"), "[[", this.withTyping("Any"), "], ", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", this.withTyping("Dict"), "[str, ", tvar, "]"),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, dict)");
          this.emitLine("return { k: f(v) for (k, v) in x.items() }");
        });
      }
      // This is not easily idiomatically typeable in Python.  See
      // https://stackoverflow.com/questions/51066468/computed-types-in-mypy/51084497
      emitUnionConverter() {
        this.emitMultiline(`def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False`);
      }
      emitFromDatetimeConverter() {
        this.emitBlock([
          "def from_datetime(",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", this.withImport("datetime", "datetime")),
          ":"
        ], () => {
          this._haveDateutil = true;
          this.emitLine("return dateutil.parser.parse(x)");
        });
      }
      emitFromStringifiedBoolConverter() {
        this.emitBlock(["def from_stringified_bool(x", this.typeHint(": str"), ")", this.typeHint(" -> bool"), ":"], () => {
          this.emitBlock('if x == "true":', () => this.emitLine("return True"));
          this.emitBlock('if x == "false":', () => this.emitLine("return False"));
          this.emitLine("assert False");
        });
      }
      emitIsTypeConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
          "def is_type(t",
          this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
          ", ",
          this.typingDecl("x", "Any"),
          ")",
          this.typeHint(" -> ", tvar),
          ":"
        ], () => {
          this.emitLine("assert isinstance(x, t)");
          this.emitLine("return x");
        });
      }
      emitConverter(cf) {
        switch (cf) {
          case "none": {
            this.emitNoneConverter();
            return;
          }
          case "bool": {
            this.emitBoolConverter();
            return;
          }
          case "int": {
            this.emitIntConverter();
            return;
          }
          case "from-float": {
            this.emitFromFloatConverter();
            return;
          }
          case "to-float": {
            this.emitToFloatConverter();
            return;
          }
          case "str": {
            this.emitStrConverter();
            return;
          }
          case "to-enum": {
            this.emitToEnumConverter();
            return;
          }
          case "list": {
            this.emitListConverter();
            return;
          }
          case "to-class": {
            this.emitToClassConverter();
            return;
          }
          case "dict": {
            this.emitDictConverter();
            return;
          }
          case "union": {
            this.emitUnionConverter();
            return;
          }
          case "from-datetime": {
            this.emitFromDatetimeConverter();
            return;
          }
          case "from-stringified-bool": {
            this.emitFromStringifiedBoolConverter();
            return;
          }
          case "is-type": {
            this.emitIsTypeConverter();
            return;
          }
          default:
            return (0, Support_1.assertNever)(cf);
        }
      }
      // Return the name of the Python converter function `cf`.
      conv(cf) {
        this._deserializerFunctions.add(cf);
        const name = cf.replace(/-/g, "_");
        if (cf.startsWith("from-") || cf.startsWith("to-") || cf.startsWith("is-"))
          return name;
        return ["from_", name];
      }
      // Applies the converter function to `arg`
      convFn(cf, arg) {
        return compose(arg, { lambda: (0, Source_1.singleWord)(this.conv(cf)), value: void 0 });
      }
      typeObject(t) {
        const s = (0, TypeUtils_1.matchType)(t, (_anyType) => void 0, (_nullType) => "type(None)", (_boolType) => "bool", (_integerType) => "int", (_doubleType) => "float", (_stringType) => "str", (_arrayType) => "List", (classType) => this.nameForNamedType(classType), (_mapType) => "dict", (enumType) => this.nameForNamedType(enumType), (_unionType) => void 0, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return this.withImport("datetime", "datetime");
          }
          if (transformedStringType.kind === "uuid") {
            return this.withImport("uuid", "UUID");
          }
          return void 0;
        });
        if (s === void 0) {
          return (0, Support_1.panic)(`No type object for ${t.kind}`);
        }
        return s;
      }
      transformer(inputTransformer, xfer, targetType) {
        const consume = (consumer, vol) => {
          if (consumer === void 0) {
            return vol;
          }
          return this.transformer(vol, consumer, targetType);
        };
        const isType = (t, valueToCheck) => {
          return compose(valueToCheck, (v) => [this.conv("is-type"), "(", this.typeObject(t), ", ", v, ")"]);
        };
        if (xfer instanceof Transformers_1.DecodingChoiceTransformer || xfer instanceof Transformers_1.ChoiceTransformer) {
          const lambdas = xfer.transformers.map((x) => makeLambda(this.transformer(identity, x, targetType)).source);
          return compose(inputTransformer, (v) => [
            this.conv("union"),
            "([",
            (0, collection_utils_1.arrayIntercalate)(", ", lambdas),
            "], ",
            v,
            ")"
          ]);
        } else if (xfer instanceof Transformers_1.DecodingTransformer) {
          const consumer = xfer.consumer;
          const vol = this.deserializer(inputTransformer, xfer.sourceType);
          return consume(consumer, vol);
        } else if (xfer instanceof Transformers_1.EncodingTransformer) {
          return this.serializer(inputTransformer, xfer.sourceType);
        } else if (xfer instanceof Transformers_1.UnionInstantiationTransformer) {
          return inputTransformer;
        } else if (xfer instanceof Transformers_1.UnionMemberMatchTransformer) {
          const consumer = xfer.transformer;
          const vol = isType(xfer.memberType, inputTransformer);
          return consume(consumer, vol);
        } else if (xfer instanceof Transformers_1.ParseStringTransformer) {
          const consumer = xfer.consumer;
          const immediateTargetType = consumer === void 0 ? targetType : consumer.sourceType;
          let vol;
          switch (immediateTargetType.kind) {
            case "integer":
              vol = compose(inputTransformer, (v) => ["int(", v, ")"]);
              break;
            case "bool":
              vol = this.convFn("from-stringified-bool", inputTransformer);
              break;
            case "enum":
              vol = this.deserializer(inputTransformer, immediateTargetType);
              break;
            case "date-time":
              vol = this.convFn("from-datetime", inputTransformer);
              break;
            case "uuid":
              vol = compose(inputTransformer, (v) => [this.withImport("uuid", "UUID"), "(", v, ")"]);
              break;
            default:
              return (0, Support_1.panic)(`Parsing of ${immediateTargetType.kind} in a transformer is not supported`);
          }
          return consume(consumer, vol);
        } else if (xfer instanceof Transformers_1.StringifyTransformer) {
          const consumer = xfer.consumer;
          let vol;
          switch (xfer.sourceType.kind) {
            case "integer":
              vol = compose(inputTransformer, (v) => ["str(", v, ")"]);
              break;
            case "bool":
              vol = compose(inputTransformer, (v) => ["str(", v, ").lower()"]);
              break;
            case "enum":
              vol = this.serializer(inputTransformer, xfer.sourceType);
              break;
            case "date-time":
              vol = compose(inputTransformer, (v) => [v, ".isoformat()"]);
              break;
            case "uuid":
              vol = compose(inputTransformer, (v) => ["str(", v, ")"]);
              break;
            default:
              return (0, Support_1.panic)(`Parsing of ${xfer.sourceType.kind} in a transformer is not supported`);
          }
          return consume(consumer, vol);
        } else {
          return (0, Support_1.panic)(`Transformer ${xfer.kind} is not supported`);
        }
      }
      // Returns the code to deserialize `value` as type `t`.  If `t` has
      // an associated transformer, the code for that transformer is
      // returned.
      deserializer(value, t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf !== void 0) {
          return this.transformer(value, xf.transformer, xf.targetType);
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => value, (_nullType) => this.convFn("none", value), (_boolType) => this.convFn("bool", value), (_integerType) => this.convFn("int", value), (_doubleType) => this.convFn("from-float", value), (_stringType) => this.convFn("str", value), (arrayType) => compose(value, (v) => [
          this.conv("list"),
          "(",
          makeLambda(this.deserializer(identity, arrayType.items)).source,
          ", ",
          v,
          ")"
        ]), (classType) => compose(value, {
          lambda: (0, Source_1.singleWord)(this.nameForNamedType(classType), ".from_dict"),
          value: void 0
        }), (mapType) => compose(value, (v) => [
          this.conv("dict"),
          "(",
          makeLambda(this.deserializer(identity, mapType.values)).source,
          ", ",
          v,
          ")"
        ]), (enumType) => compose(value, { lambda: (0, Source_1.singleWord)(this.nameForNamedType(enumType)), value: void 0 }), (unionType) => {
          const deserializers = Array.from(unionType.members).map((m) => makeLambda(this.deserializer(identity, m)).source);
          return compose(value, (v) => [
            this.conv("union"),
            "([",
            (0, collection_utils_1.arrayIntercalate)(", ", deserializers),
            "], ",
            v,
            ")"
          ]);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return this.convFn("from-datetime", value);
          }
          if (transformedStringType.kind === "uuid") {
            return compose(value, (v) => [this.withImport("uuid", "UUID"), "(", v, ")"]);
          }
          return (0, Support_1.panic)(`Transformed type ${transformedStringType.kind} not supported`);
        });
      }
      serializer(value, t) {
        const xf = (0, Transformers_1.transformationForType)(t);
        if (xf !== void 0) {
          const reverse = xf.reverse;
          return this.transformer(value, reverse.transformer, reverse.targetType);
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => value, (_nullType) => this.convFn("none", value), (_boolType) => this.convFn("bool", value), (_integerType) => this.convFn("int", value), (_doubleType) => this.convFn("to-float", value), (_stringType) => this.convFn("str", value), (arrayType) => compose(value, (v) => [
          this.conv("list"),
          "(",
          makeLambda(this.serializer(identity, arrayType.items)).source,
          ", ",
          v,
          ")"
        ]), (classType) => compose(value, (v) => [this.conv("to-class"), "(", this.nameForNamedType(classType), ", ", v, ")"]), (mapType) => compose(value, (v) => [
          this.conv("dict"),
          "(",
          makeLambda(this.serializer(identity, mapType.values)).source,
          ", ",
          v,
          ")"
        ]), (enumType) => compose(value, (v) => [this.conv("to-enum"), "(", this.nameForNamedType(enumType), ", ", v, ")"]), (unionType) => {
          const serializers = Array.from(unionType.members).map((m) => makeLambda(this.serializer(identity, m)).source);
          return compose(value, (v) => [
            this.conv("union"),
            "([",
            (0, collection_utils_1.arrayIntercalate)(", ", serializers),
            "], ",
            v,
            ")"
          ]);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return compose(value, (v) => [v, ".isoformat()"]);
          }
          if (transformedStringType.kind === "uuid") {
            return compose(value, (v) => ["str(", v, ")"]);
          }
          return (0, Support_1.panic)(`Transformed type ${transformedStringType.kind} not supported`);
        });
      }
      emitClassMembers(t) {
        super.emitClassMembers(t);
        this.ensureBlankLine();
        const className = this.nameForNamedType(t);
        this.emitLine("@staticmethod");
        this.emitBlock(["def from_dict(", this.typingDecl("obj", "Any"), ")", this.typeHint(" -> ", this.namedType(t)), ":"], () => {
          const args = [];
          this.emitLine("assert isinstance(obj, dict)");
          this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
            const property = { value: ["obj.get(", this.string(jsonName), ")"] };
            this.emitLine(name, " = ", makeValue(this.deserializer(property, cp.type)));
            args.push(name);
          });
          this.emitLine("return ", className, "(", (0, collection_utils_1.arrayIntercalate)(", ", args), ")");
        });
        this.ensureBlankLine();
        this.emitBlock(["def to_dict(self)", this.typeHint(" -> dict"), ":"], () => {
          this.emitLine("result", this.typeHint(": dict"), " = {}");
          this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
            const property = { value: ["self.", name] };
            if (cp.isOptional) {
              this.emitBlock(["if self.", name, " is not None:"], () => {
                this.emitLine("result[", this.string(jsonName), "] = ", makeValue(this.serializer(property, cp.type)));
              });
            } else {
              this.emitLine("result[", this.string(jsonName), "] = ", makeValue(this.serializer(property, cp.type)));
            }
          });
          this.emitLine("return result");
        });
      }
      emitImports() {
        super.emitImports();
        if (this._haveDateutil) {
          this.emitLine("import dateutil.parser");
        }
        if (!this._haveTypeVar && !this._haveEnumTypeVar)
          return;
        this.ensureBlankLine(2);
        if (this._haveTypeVar) {
          this.emitTypeVar(this.typeVar(), []);
        }
        if (this._haveEnumTypeVar) {
          this.emitTypeVar(this.enumTypeVar(), [", bound=", this.withImport("enum", "Enum")]);
        }
      }
      emitSupportCode() {
        const map2 = Array.from(this._deserializerFunctions).map((f) => [f, f]);
        this.forEachWithBlankLines(map2, ["interposing", 2], (cf) => {
          this.emitConverter(cf);
        });
      }
      makeTopLevelDependencyNames(_t, topLevelName) {
        const fromDict = new Naming_1.DependencyName(this._converterNamer, ConvenienceRenderer_1.topLevelNameOrder, (l) => `${l(topLevelName)}_from_dict`);
        const toDict = new Naming_1.DependencyName(this._converterNamer, ConvenienceRenderer_1.topLevelNameOrder, (l) => `${l(topLevelName)}_to_dict`);
        this._topLevelConverterNames.set(topLevelName, { fromDict, toDict });
        return [fromDict, toDict];
      }
      emitDefaultLeadingComments() {
        this.ensureBlankLine();
        if (this._haveDateutil) {
          this.emitCommentLines([
            "This code parses date/times, so please",
            "",
            "    pip install python-dateutil",
            ""
          ]);
        }
        this.emitCommentLines([
          "To use this code, make sure you",
          "",
          "    import json",
          "",
          "and then, to convert JSON from a string, do",
          ""
        ]);
        this.forEachTopLevel("none", (_, name) => {
          const { fromDict } = (0, Support_1.defined)(this._topLevelConverterNames.get(name));
          this.emitLine(this.commentLineStart, "    result = ", fromDict, "(json.loads(json_string))");
        });
      }
      emitClosingCode() {
        this.forEachTopLevel(["interposing", 2], (t, name) => {
          const { fromDict, toDict } = (0, Support_1.defined)(this._topLevelConverterNames.get(name));
          const pythonType = this.pythonType(t);
          this.emitBlock(["def ", fromDict, "(", this.typingDecl("s", "Any"), ")", this.typeHint(" -> ", pythonType), ":"], () => {
            this.emitLine("return ", makeValue(this.deserializer({ value: "s" }, t)));
          });
          this.ensureBlankLine(2);
          this.emitBlock(["def ", toDict, "(x", this.typeHint(": ", pythonType), ")", this.typingReturn("Any"), ":"], () => {
            this.emitLine("return ", makeValue(this.serializer({ value: "x" }, t)));
          });
        });
      }
    };
    exports.JSONPythonRenderer = JSONPythonRenderer;
  }
});

// node_modules/quicktype-core/dist/language/ruby/keywords.js
var require_keywords = __commonJS({
  "node_modules/quicktype-core/dist/language/ruby/keywords.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reservedProperties = exports.globals = exports.keywords = void 0;
    exports.keywords = [
      "__ENCODING__",
      "__FILE__",
      "__LINE__",
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "def",
      "defined?",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "false",
      "for",
      "if",
      "in",
      "module",
      "next",
      "nil",
      "not",
      "or",
      "redo",
      "rescue",
      "retry",
      "return",
      "self",
      "super",
      "then",
      "true",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield"
    ];
    var globalClasses = [
      "ArgumentError",
      "Array",
      "BasicObject",
      "Class",
      "ClosedQueueError",
      "Comparable",
      "Complex",
      "ConditionVariable",
      "Continuation",
      "Data",
      "Date",
      "Dir",
      "ENV",
      "EOFError",
      "Encoding",
      "EncodingError",
      "Enumerable",
      "Enumerator",
      "Errno",
      "Exception",
      "FalseClass",
      "Fiber",
      "FiberError",
      "File",
      "FileTest",
      "Float",
      "FloatDomainError",
      "FrozenError",
      "GC",
      "Hash",
      "IO",
      "IOError",
      "IndexError",
      "Integer",
      "Interrupt",
      "KeyError",
      "LoadError",
      "LocalJumpError",
      "Marshal",
      "MatchData",
      "Math",
      "Method",
      "Module",
      "Mutex",
      "NameError",
      "NilClass",
      "NoMemoryError",
      "NoMethodError",
      "NotImplementedError",
      "Numeric",
      "Object",
      "ObjectSpace",
      "Proc",
      "Process",
      "Queue",
      "Random",
      "Range",
      "RangeError",
      "Rational",
      "Regexp",
      "RegexpError",
      "RubyVM",
      "RuntimeError",
      "ScriptError",
      "SecurityError",
      "Set",
      "Signal",
      "SignalException",
      "SizedQueue",
      "StandardError",
      "StopIteration",
      "String",
      "Struct",
      "Symbol",
      "SyntaxError",
      "SystemCallError",
      "SystemExit",
      "SystemStackError",
      "Thread",
      "ThreadError",
      "ThreadGroup",
      "Time",
      "TracePoint",
      "TrueClass",
      "TypeError",
      "UnboundMethod",
      "UncaughtThrowError",
      "Undefined",
      "UnicodeNormalize",
      "Warning",
      "ZeroDivisionError"
    ];
    var kernel = [
      "__callee__",
      "__dir__",
      "__id__",
      "__method__",
      "__send__",
      "!",
      "!=",
      "!~",
      "<",
      "<=",
      "<=>",
      "==",
      "===",
      "=~",
      ">",
      ">=",
      "abort",
      "ancestors",
      "at_exit",
      "autoload",
      "autoload?",
      "binding",
      "block_given?",
      "caller",
      "caller_locations",
      "catch",
      "class",
      "class_eval",
      "class_exec",
      "class_variable_defined?",
      "class_variable_get",
      "class_variable_set",
      "class_variables",
      "clone",
      "const_defined?",
      "const_get",
      "const_missing",
      "const_set",
      "constants",
      "define_singleton_method",
      "deprecate_constant",
      "display",
      "dup",
      "enum_for",
      "eql?",
      "equal?",
      "eval",
      "exec",
      "exit",
      "exit!",
      "extend",
      "fail",
      "fork",
      "format",
      "freeze",
      "frozen?",
      "gets",
      "global_variables",
      "hash",
      "include",
      "include?",
      "included_modules",
      "inspect",
      "instance_eval",
      "instance_exec",
      "instance_method",
      "instance_methods",
      "instance_of?",
      "instance_variable_defined?",
      "instance_variable_get",
      "instance_variable_set",
      "instance_variables",
      "is_a?",
      "iterator?",
      "itself",
      "kind_of?",
      "lambda",
      "load",
      "local_variables",
      "loop",
      "method",
      "method_defined?",
      "methods",
      "module_eval",
      "module_exec",
      "name",
      "new",
      "nil?",
      "object_id",
      "open",
      "p",
      "prepend",
      "print",
      "printf",
      "private_class_method",
      "private_constant",
      "private_instance_methods",
      "private_method_defined?",
      "private_methods",
      "proc",
      "protected_instance_methods",
      "protected_method_defined?",
      "protected_methods",
      "public_class_method",
      "public_constant",
      "public_instance_method",
      "public_instance_methods",
      "public_method",
      "public_method_defined?",
      "public_methods",
      "public_send",
      "putc",
      "puts",
      "raise",
      "rand",
      "readline",
      "readlines",
      "remove_class_variable",
      "remove_instance_variable",
      "require",
      "require_relative",
      "respond_to?",
      "select",
      "send",
      "set_trace_func",
      "singleton_class",
      "singleton_class?",
      "singleton_method",
      "singleton_methods",
      "sleep",
      "spawn",
      "sprintf",
      "srand",
      "syscall",
      "system",
      "taint",
      "tainted?",
      "tap",
      "test",
      "throw",
      "to_enum",
      "to_s",
      "trace_var",
      "trap",
      "trust",
      "untaint",
      "untrace_var",
      "untrust",
      "untrusted?",
      "warn"
    ];
    exports.globals = kernel.concat(globalClasses);
    exports.reservedProperties = [
      "__id__",
      "__send__",
      "break",
      "call",
      "case",
      "class",
      "clone",
      "constrained_type",
      "constrained?",
      "constrained",
      "constructor",
      "default",
      "define_singleton_method",
      "display",
      "dup",
      "enum_for",
      "enum",
      "extend",
      "freeze",
      "gem",
      "hash",
      "inspect",
      "instance_eval",
      "instance_exec",
      "instance_variable_defined?",
      "instance_variable_get",
      "instance_variable_set",
      "instance_variables",
      "itself",
      "meta",
      "method",
      "methods",
      "next",
      "object_id",
      "optional",
      "options",
      "pristine",
      "private_methods",
      "protected_methods",
      "public_method",
      "public_methods",
      "public_send",
      "remove_instance_variable",
      "rule",
      "safe",
      "self",
      "send",
      "singleton_class",
      "singleton_method",
      "singleton_methods",
      "taint",
      "tap",
      "to_ast",
      "to_enum",
      "to_json",
      "to_s",
      "trust",
      "try",
      "type",
      "untaint",
      "undef",
      "untrust",
      "while",
      "with"
    ];
  }
});

// node_modules/quicktype-core/dist/language/ruby/index.js
var require_ruby = __commonJS({
  "node_modules/quicktype-core/dist/language/ruby/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RubyRenderer = exports.RubyTargetLanguage = exports.rubyOptions = exports.Strictness = void 0;
    var unicode = __importStar(require_main());
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var keywords = __importStar(require_keywords());
    var forbiddenForObjectProperties = Array.from(/* @__PURE__ */ new Set([...keywords.keywords, ...keywords.reservedProperties]));
    function unicodeEscape(codePoint) {
      return "\\u{" + (0, Strings_1.intToHex)(codePoint, 0) + "}";
    }
    var stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
    var Strictness;
    (function(Strictness2) {
      Strictness2["Coercible"] = "Coercible::";
      Strictness2["None"] = "Types::";
      Strictness2["Strict"] = "Strict::";
    })(Strictness = exports.Strictness || (exports.Strictness = {}));
    exports.rubyOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      strictness: new RendererOptions_1.EnumOption("strictness", "Type strictness", [
        ["strict", Strictness.Strict],
        ["coercible", Strictness.Coercible],
        ["none", Strictness.None]
      ]),
      namespace: new RendererOptions_1.StringOption("namespace", "Specify a wrapping Namespace", "NAME", "", "secondary")
    };
    var RubyTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Ruby", ["ruby"], "rb");
      }
      getOptions() {
        return [exports.rubyOptions.justTypes, exports.rubyOptions.strictness, exports.rubyOptions.namespace];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get defaultIndentation() {
        return "  ";
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new RubyRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.rubyOptions, untypedOptionValues));
      }
    };
    exports.RubyTargetLanguage = RubyTargetLanguage;
    var isStartCharacter = Strings_1.isLetterOrUnderscore;
    function isPartCharacter(utf16Unit) {
      const category = unicode.getCategory(utf16Unit);
      return ["Nd", "Pc", "Mn", "Mc"].includes(category) || isStartCharacter(utf16Unit);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function simpleNameStyle(original, uppercase) {
      if (/^[0-9]+$/.test(original)) {
        original = original + "N";
      }
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, uppercase ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    function memberNameStyle(original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, Strings_1.allLowerWordStyle, "_", isStartCharacter);
    }
    var RubyRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      get commentLineStart() {
        return "# ";
      }
      get needsTypeDeclarationBeforeUse() {
        return true;
      }
      canBeForwardDeclared(t) {
        return "class" === t.kind;
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords.globals.concat(["Types", "JSON", "Dry", "Constructor", "Self"]);
      }
      forbiddenForObjectProperties(_c, _classNamed) {
        return { names: forbiddenForObjectProperties, includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return new Naming_1.Namer("types", (n) => simpleNameStyle(n, true), []);
      }
      namerForObjectProperty() {
        return new Naming_1.Namer("properties", memberNameStyle, []);
      }
      makeUnionMemberNamer() {
        return new Naming_1.Namer("properties", memberNameStyle, []);
      }
      makeEnumCaseNamer() {
        return new Naming_1.Namer("enum-cases", (n) => simpleNameStyle(n, true), []);
      }
      dryType(t, isOptional = false) {
        const optional = isOptional ? ".optional" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => ["Types::Any", optional], (_nullType) => ["Types::Nil", optional], (_boolType) => ["Types::Bool", optional], (_integerType) => ["Types::Integer", optional], (_doubleType) => ["Types::Double", optional], (_stringType) => ["Types::String", optional], (arrayType) => ["Types.Array(", this.dryType(arrayType.items), ")", optional], (classType) => [this.nameForNamedType(classType), optional], (mapType) => ["Types::Hash.meta(of: ", this.dryType(mapType.values), ")", optional], (enumType) => ["Types::", this.nameForNamedType(enumType), optional], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return [this.dryType(nullable), ".optional"];
          }
          return ["Types.Instance(", this.nameForNamedType(unionType), ")", optional];
        });
      }
      exampleUse(t, exp, depth = 6, optional = false) {
        if (depth-- <= 0) {
          return exp;
        }
        const safeNav = optional ? "&" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => exp, (_nullType) => [exp, ".nil?"], (_boolType) => exp, (_integerType) => [exp, ".even?"], (_doubleType) => exp, (_stringType) => exp, (arrayType) => this.exampleUse(arrayType.items, [exp, safeNav, ".first"], depth), (classType) => {
          let info;
          this.forEachClassProperty(classType, "none", (name, _json, prop) => {
            if (["class", "map", "array"].includes(prop.type.kind)) {
              info = { name, prop };
            } else if (info === void 0) {
              info = { name, prop };
            }
          });
          if (info !== void 0) {
            return this.exampleUse(info.prop.type, [exp, safeNav, ".", info.name], depth, info.prop.isOptional);
          }
          return exp;
        }, (mapType) => this.exampleUse(mapType.values, [exp, safeNav, '["â¦"]'], depth), (enumType) => {
          let name;
          this.forEachEnumCase(enumType, "none", (theName) => {
            if (name === void 0) {
              name = theName;
            }
          });
          if (name !== void 0) {
            return [exp, " == ", this.nameForNamedType(enumType), "::", name];
          }
          return exp;
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (["class", "map", "array"].includes(nullable.kind)) {
              return this.exampleUse(nullable, exp, depth, true);
            }
            return [exp, ".nil?"];
          }
          return exp;
        });
      }
      jsonSample(t) {
        function inner() {
          if (t instanceof Type_1.ArrayType) {
            return "[â¦]";
          } else if (t instanceof Type_1.MapType) {
            return "{â¦}";
          } else if (t instanceof Type_1.ClassType) {
            return "{â¦}";
          } else {
            return "â¦";
          }
        }
        return `"${inner()}"`;
      }
      fromDynamic(t, e, optional = false, castPrimitives = false) {
        const primitiveCast = [this.dryType(t, optional), "[", e, "]"];
        const primitive = castPrimitives ? primitiveCast : e;
        const safeAccess = optional ? "&" : "";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => primitive, (_nullType) => primitive, (_boolType) => primitive, (_integerType) => primitive, (_doubleType) => primitive, (_stringType) => primitive, (arrayType) => [e, safeAccess, ".map { |x| ", this.fromDynamic(arrayType.items, "x", false, true), " }"], (classType) => {
          const expression = [this.nameForNamedType(classType), ".from_dynamic!(", e, ")"];
          return optional ? [e, " ? ", expression, " : nil"] : expression;
        }, (mapType) => [
          ["Types::Hash", optional ? ".optional" : "", "[", e, "]"],
          safeAccess,
          ".map { |k, v| [k, ",
          this.fromDynamic(mapType.values, "v", false, true),
          "] }",
          safeAccess,
          ".to_h"
        ], (enumType) => {
          const expression = ["Types::", this.nameForNamedType(enumType), "[", e, "]"];
          return optional ? [e, ".nil? ? nil : ", expression] : expression;
        }, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.fromDynamic(nullable, e, true);
          }
          const expression = [this.nameForNamedType(unionType), ".from_dynamic!(", e, ")"];
          return optional ? [e, " ? ", expression, " : nil"] : expression;
        });
      }
      toDynamic(t, e, optional = false) {
        if (this.marshalsImplicitlyToDynamic(t)) {
          return e;
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => e, (_nullType) => e, (_boolType) => e, (_integerType) => e, (_doubleType) => e, (_stringType) => e, (arrayType) => [e, optional ? "&" : "", ".map { |x| ", this.toDynamic(arrayType.items, "x"), " }"], (_classType) => [e, optional ? "&" : "", ".to_dynamic"], (mapType) => [e, optional ? "&" : "", ".map { |k, v| [k, ", this.toDynamic(mapType.values, "v"), "] }.to_h"], (_enumType) => e, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.toDynamic(nullable, e, true);
          }
          if (this.marshalsImplicitlyToDynamic(unionType)) {
            return e;
          }
          return [e, optional ? "&" : "", ".to_dynamic"];
        });
      }
      marshalsImplicitlyToDynamic(t) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => true, (_nullType) => true, (_boolType) => true, (_integerType) => true, (_doubleType) => true, (_stringType) => true, (arrayType) => this.marshalsImplicitlyToDynamic(arrayType.items), (_classType) => false, (mapType) => this.marshalsImplicitlyToDynamic(mapType.values), (_enumType) => true, (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return this.marshalsImplicitlyToDynamic(nullable);
          }
          return false;
        });
      }
      // This is only to be used to allow class properties to possibly
      // marshal implicitly. They are allowed to do this because they will
      // be checked in Dry::Struct.new
      propertyTypeMarshalsImplicitlyFromDynamic(t) {
        return (0, TypeUtils_1.matchType)(
          t,
          (_anyType) => true,
          (_nullType) => true,
          (_boolType) => true,
          (_integerType) => true,
          (_doubleType) => true,
          (_stringType) => true,
          (arrayType) => this.propertyTypeMarshalsImplicitlyFromDynamic(arrayType.items),
          (_classType) => false,
          // Map properties must be checked because Dry:Types doesn't have a generic Map
          (_mapType) => false,
          (_enumType) => true,
          (unionType) => {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
            if (nullable !== null) {
              return this.propertyTypeMarshalsImplicitlyFromDynamic(nullable);
            }
            return false;
          }
        );
      }
      emitBlock(source, emit) {
        this.emitLine(source);
        this.indent(emit);
        this.emitLine("end");
      }
      emitModule(emit) {
        const emitModuleInner = (moduleName) => {
          const [firstModule, ...subModules] = moduleName.split("::");
          if (subModules.length > 0) {
            this.emitBlock(["module ", firstModule], () => {
              emitModuleInner(subModules.join("::"));
            });
          } else {
            this.emitBlock(["module ", moduleName], emit);
          }
        };
        if (this._options.namespace !== void 0 && this._options.namespace !== "") {
          emitModuleInner(this._options.namespace);
        } else {
          emit();
        }
      }
      emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock(["class ", className, " < Dry::Struct"], () => {
          let table = [];
          let count = c.getProperties().size;
          this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const last = --count === 0;
            const description = this.descriptionForClassProperty(c, jsonName);
            const attribute = [
              ["attribute :", name, ","],
              [" ", this.dryType(p.type), p.isOptional ? ".optional" : ""]
            ];
            if (description !== void 0) {
              if (table.length > 0) {
                this.emitTable(table);
                table = [];
              }
              this.ensureBlankLine();
              this.emitDescriptionBlock(description);
              this.emitLine(attribute);
              if (!last) {
                this.ensureBlankLine();
              }
            } else {
              table.push(attribute);
            }
          });
          if (table.length > 0) {
            this.emitTable(table);
          }
          if (this._options.justTypes) {
            return;
          }
          this.ensureBlankLine();
          this.emitBlock(["def self.from_dynamic!(d)"], () => {
            this.emitLine("d = Types::Hash[d]");
            this.emitLine("new(");
            this.indent(() => {
              const inits = [];
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const dynamic = p.isOptional ? (
                  // If key is not found in hash, this will be nil
                  `d["${stringEscape(jsonName)}"]`
                ) : (
                  // This will raise a runtime error if the key is not found in the hash
                  `d.fetch("${stringEscape(jsonName)}")`
                );
                if (this.propertyTypeMarshalsImplicitlyFromDynamic(p.type)) {
                  inits.push([
                    [name, ": "],
                    [dynamic, ","]
                  ]);
                } else {
                  const expression = this.fromDynamic(p.type, dynamic, p.isOptional);
                  inits.push([
                    [name, ": "],
                    [expression, ","]
                  ]);
                }
              });
              this.emitTable(inits);
            });
            this.emitLine(")");
          });
          this.ensureBlankLine();
          this.emitBlock("def self.from_json!(json)", () => {
            this.emitLine("from_dynamic!(JSON.parse(json))");
          });
          this.ensureBlankLine();
          this.emitBlock(["def to_dynamic"], () => {
            this.emitLine("{");
            this.indent(() => {
              const inits = [];
              this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const expression = this.toDynamic(p.type, name, p.isOptional);
                inits.push([[`"${stringEscape(jsonName)}"`], [" => ", expression, ","]]);
              });
              this.emitTable(inits);
            });
            this.emitLine("}");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_json(options = nil)", () => {
            this.emitLine("JSON.generate(to_dynamic, options)");
          });
        });
      }
      emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["module ", enumName], () => {
          const table = [];
          this.forEachEnumCase(e, "none", (name, json) => {
            table.push([[name], [` = "${stringEscape(json)}"`]]);
          });
          this.emitTable(table);
        });
      }
      emitUnion(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitBlock(["class ", unionName, " < Dry::Struct"], () => {
          const table = [];
          this.forEachUnionMember(u, u.getChildren(), "none", null, (name, t) => {
            table.push([["attribute :", name, ", "], [this.dryType(t, true)]]);
          });
          this.emitTable(table);
          if (this._options.justTypes) {
            return;
          }
          this.ensureBlankLine();
          const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, false);
          this.emitBlock("def self.from_dynamic!(d)", () => {
            const memberNames = Array.from(u.getChildren()).map((member) => this.nameForUnionMember(u, member));
            this.forEachUnionMember(u, u.getChildren(), "none", null, (name, t) => {
              const nilMembers = memberNames.filter((n) => n !== name).map((memberName) => [", ", memberName, ": nil"]);
              if (this.propertyTypeMarshalsImplicitlyFromDynamic(t)) {
                this.emitBlock(["if schema[:", name, "].right.valid? d"], () => {
                  this.emitLine("return new(", name, ": d", nilMembers, ")");
                });
              } else {
                this.emitLine("begin");
                this.indent(() => {
                  this.emitLine("value = ", this.fromDynamic(t, "d"));
                  this.emitBlock(["if schema[:", name, "].right.valid? value"], () => {
                    this.emitLine("return new(", name, ": value", nilMembers, ")");
                  });
                });
                this.emitLine("rescue");
                this.emitLine("end");
              }
            });
            this.emitLine('raise "Invalid union"');
          });
          this.ensureBlankLine();
          this.emitBlock("def self.from_json!(json)", () => {
            this.emitLine("from_dynamic!(JSON.parse(json))");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_dynamic", () => {
            let first = true;
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
              this.emitLine(first ? "if" : "elsif", " ", name, " != nil");
              this.indent(() => {
                this.emitLine(this.toDynamic(t, name));
              });
              first = false;
            });
            if (maybeNull !== null) {
              this.emitLine("else");
              this.indent(() => {
                this.emitLine("nil");
              });
            }
            this.emitLine("end");
          });
          this.ensureBlankLine();
          this.emitBlock("def to_json(options = nil)", () => {
            this.emitLine("JSON.generate(to_dynamic, options)");
          });
        });
      }
      emitTypesModule() {
        this.emitBlock(["module Types"], () => {
          this.emitLine("include Dry.Types(default: :nominal)");
          const declarations = [];
          if (this._options.strictness !== Strictness.None) {
            let has = { int: false, nil: false, bool: false, hash: false, string: false, double: false };
            this.forEachType((t) => {
              has = {
                int: has.int || t.kind === "integer",
                nil: has.nil || t.kind === "null",
                bool: has.bool || t.kind === "bool",
                hash: has.hash || t.kind === "map" || t.kind === "class",
                string: has.string || t.kind === "string" || t.kind === "enum",
                double: has.double || t.kind === "double"
              };
            });
            if (has.int)
              declarations.push([["Integer"], [` = ${this._options.strictness}Integer`]]);
            if (this._options.strictness === Strictness.Strict) {
              if (has.nil)
                declarations.push([["Nil"], [` = ${this._options.strictness}Nil`]]);
            }
            if (has.bool)
              declarations.push([["Bool"], [` = ${this._options.strictness}Bool`]]);
            if (has.hash)
              declarations.push([["Hash"], [` = ${this._options.strictness}Hash`]]);
            if (has.string)
              declarations.push([["String"], [` = ${this._options.strictness}String`]]);
            if (has.double)
              declarations.push([
                ["Double"],
                [` = ${this._options.strictness}Float | ${this._options.strictness}Integer`]
              ]);
          }
          this.forEachEnum("none", (enumType, enumName) => {
            const cases = [];
            this.forEachEnumCase(enumType, "none", (_name, json) => {
              cases.push([cases.length === 0 ? "" : ", ", `"${stringEscape(json)}"`]);
            });
            declarations.push([[enumName], [" = ", this._options.strictness, "String.enum(", ...cases, ")"]]);
          });
          if (declarations.length > 0) {
            this.ensureBlankLine();
            this.emitTable(declarations);
          }
        });
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          this.emitLine("# This code may look unusually verbose for Ruby (and it is), but");
          this.emitLine("# it performs some subtle and complex validation of JSON data.");
          this.emitLine("#");
          this.emitLine("# To parse this JSON, add 'dry-struct' and 'dry-types' gems, then do:");
          this.emitLine("#");
          this.forEachTopLevel("none", (topLevel, name) => {
            const variable = (0, Source_1.modifySource)(Strings_1.snakeCase, name);
            this.emitLine("#   ", variable, " = ", name, ".from_json! ", this.jsonSample(topLevel));
            this.emitLine("#   puts ", this.exampleUse(topLevel, variable));
            this.emitLine("#");
          });
          this.emitLine("# If from_json! succeeds, the value returned matches the schema.");
        }
        this.ensureBlankLine();
        this.emitLine("require 'json'");
        this.emitLine("require 'dry-types'");
        this.emitLine("require 'dry-struct'");
        this.ensureBlankLine();
        this.emitModule(() => {
          this.emitTypesModule();
          this.forEachDeclaration("leading-and-interposing", (decl) => {
            if (decl.kind === "forward") {
              this.emitCommentLines(["(forward declaration)"]);
              this.emitModule(() => {
                this.emitLine("class ", this.nameForNamedType(decl.type), " < Dry::Struct; end");
              });
            }
          });
          this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClass(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
          if (!this._options.justTypes) {
            this.forEachTopLevel("leading-and-interposing", (topLevel, name) => {
              const self2 = (0, Source_1.modifySource)(Strings_1.snakeCase, name);
              const needsToJsonDefined = "array" === topLevel.kind;
              const classDeclaration = () => {
                this.emitBlock(["class ", name], () => {
                  this.emitBlock(["def self.from_json!(json)"], () => {
                    if (needsToJsonDefined) {
                      this.emitLine(self2, " = ", this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                      this.emitBlock([self2, ".define_singleton_method(:to_json) do"], () => {
                        this.emitLine("JSON.generate(", this.toDynamic(topLevel, "self"), ")");
                      });
                      this.emitLine(self2);
                    } else {
                      this.emitLine(this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                    }
                  });
                });
              };
              this.emitModule(() => {
                classDeclaration();
              });
            }, (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          }
        });
      }
    };
    exports.RubyRenderer = RubyRenderer;
  }
});

// node_modules/quicktype-core/dist/language/Rust.js
var require_Rust = __commonJS({
  "node_modules/quicktype-core/dist/language/Rust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RustRenderer = exports.RustTargetLanguage = exports.rustOptions = exports.Visibility = exports.Density = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var Density;
    (function(Density2) {
      Density2["Normal"] = "Normal";
      Density2["Dense"] = "Dense";
    })(Density = exports.Density || (exports.Density = {}));
    var Visibility;
    (function(Visibility2) {
      Visibility2["Private"] = "Private";
      Visibility2["Crate"] = "Crate";
      Visibility2["Public"] = "Public";
    })(Visibility = exports.Visibility || (exports.Visibility = {}));
    exports.rustOptions = {
      density: new RendererOptions_1.EnumOption("density", "Density", [
        ["normal", Density.Normal],
        ["dense", Density.Dense]
      ]),
      visibility: new RendererOptions_1.EnumOption("visibility", "Field visibility", [
        ["private", Visibility.Private],
        ["crate", Visibility.Crate],
        ["public", Visibility.Public]
      ]),
      deriveDebug: new RendererOptions_1.BooleanOption("derive-debug", "Derive Debug impl", false),
      deriveClone: new RendererOptions_1.BooleanOption("derive-clone", "Derive Clone impl", false),
      derivePartialEq: new RendererOptions_1.BooleanOption("derive-partial-eq", "Derive PartialEq impl", false),
      skipSerializingNone: new RendererOptions_1.BooleanOption("skip-serializing-none", "Skip serializing empty Option fields", false),
      edition2018: new RendererOptions_1.BooleanOption("edition-2018", "Edition 2018", true),
      leadingComments: new RendererOptions_1.BooleanOption("leading-comments", "Leading Comments", true)
    };
    var namingStyles = {
      snake_case: {
        regex: /^[a-z][a-z0-9]*(_[a-z0-9]+)*$/,
        toParts: (name) => name.split("_"),
        fromParts: (parts) => parts.map((p) => p.toLowerCase()).join("_")
      },
      SCREAMING_SNAKE_CASE: {
        regex: /^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/,
        toParts: (name) => name.split("_"),
        fromParts: (parts) => parts.map((p) => p.toUpperCase()).join("_")
      },
      camelCase: {
        regex: /^[a-z]+([A-Z0-9][a-z]*)*$/,
        toParts: (name) => namingStyles.snake_case.toParts(name.replace(/(.)([A-Z])/g, "$1_$2")),
        fromParts: (parts) => parts.map((p, i) => i === 0 ? p.toLowerCase() : p.substring(0, 1).toUpperCase() + p.substring(1).toLowerCase()).join("")
      },
      PascalCase: {
        regex: /^[A-Z][a-z]*([A-Z0-9][a-z]*)*$/,
        toParts: (name) => namingStyles.snake_case.toParts(name.replace(/(.)([A-Z])/g, "$1_$2")),
        fromParts: (parts) => parts.map((p) => p.substring(0, 1).toUpperCase() + p.substring(1).toLowerCase()).join("")
      },
      "kebab-case": {
        regex: /^[a-z][a-z0-9]*(-[a-z0-9]+)*$/,
        toParts: (name) => name.split("-"),
        fromParts: (parts) => parts.map((p) => p.toLowerCase()).join("-")
      },
      "SCREAMING-KEBAB-CASE": {
        regex: /^[A-Z][A-Z0-9]*(-[A-Z0-9]+)*$/,
        toParts: (name) => name.split("-"),
        fromParts: (parts) => parts.map((p) => p.toUpperCase()).join("-")
      },
      lowercase: {
        regex: /^[a-z][a-z0-9]*$/,
        toParts: (name) => [name],
        fromParts: (parts) => parts.map((p) => p.toLowerCase()).join("")
      },
      UPPERCASE: {
        regex: /^[A-Z][A-Z0-9]*$/,
        toParts: (name) => [name],
        fromParts: (parts) => parts.map((p) => p.toUpperCase()).join("")
      }
    };
    var RustTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      makeRenderer(renderContext, untypedOptionValues) {
        return new RustRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.rustOptions, untypedOptionValues));
      }
      constructor() {
        super("Rust", ["rust", "rs", "rustlang"], "rs");
      }
      getOptions() {
        return [
          exports.rustOptions.density,
          exports.rustOptions.visibility,
          exports.rustOptions.deriveDebug,
          exports.rustOptions.deriveClone,
          exports.rustOptions.derivePartialEq,
          exports.rustOptions.edition2018,
          exports.rustOptions.leadingComments,
          exports.rustOptions.skipSerializingNone
        ];
      }
    };
    exports.RustTargetLanguage = RustTargetLanguage;
    var keywords = [
      "Serialize",
      "Deserialize",
      // Special reserved identifiers used internally for elided lifetimes,
      // unnamed method parameters, crate root module, error recovery etc.
      "{{root}}",
      "$crate",
      // Keywords used in the language.
      "as",
      "async",
      "box",
      "break",
      "const",
      "continue",
      "crate",
      "else",
      "enum",
      "extern",
      "false",
      "fn",
      "for",
      "if",
      "impl",
      "in",
      "let",
      "loop",
      "match",
      "mod",
      "move",
      "mut",
      "pub",
      "ref",
      "return",
      "self",
      "Self",
      "static",
      "struct",
      "super",
      "trait",
      "true",
      "type",
      "unsafe",
      "use",
      "where",
      "while",
      // Keywords reserved for future use.
      "abstract",
      "alignof",
      "become",
      "do",
      "final",
      "macro",
      "offsetof",
      "override",
      "priv",
      "proc",
      "pure",
      "sizeof",
      "typeof",
      "unsized",
      "virtual",
      "yield",
      // Weak keywords, have special meaning only in specific contexts.
      "catch",
      "default",
      "dyn",
      "'static",
      "union",
      // Conflict between `std::Option` and potentially generated Option
      "option"
    ];
    var isAsciiLetterOrUnderscoreOrDigit = (codePoint) => {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscoreOrDigit)(codePoint);
    };
    var isAsciiLetterOrUnderscore = (codePoint) => {
      if (!(0, Strings_1.isAscii)(codePoint)) {
        return false;
      }
      return (0, Strings_1.isLetterOrUnderscore)(codePoint);
    };
    var legalizeName = (0, Strings_1.legalizeCharacters)(isAsciiLetterOrUnderscoreOrDigit);
    function rustStyle(original, isSnakeCase) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const wordStyle = isSnakeCase ? Strings_1.allLowerWordStyle : Strings_1.firstUpperWordStyle;
      const combined = (0, Strings_1.combineWords)(words, legalizeName, wordStyle, wordStyle, wordStyle, wordStyle, isSnakeCase ? "_" : "", isAsciiLetterOrUnderscore);
      return combined === "_" ? "_underscore" : combined;
    }
    var snakeNamingFunction = (0, Naming_1.funPrefixNamer)("default", (original) => rustStyle(original, true));
    var camelNamingFunction = (0, Naming_1.funPrefixNamer)("camel", (original) => rustStyle(original, false));
    var standardUnicodeRustEscape = (codePoint) => {
      if (codePoint <= 65535) {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 4) + "}";
      } else {
        return "\\u{" + (0, Strings_1.intToHex)(codePoint, 6) + "}";
      }
    };
    var rustStringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, standardUnicodeRustEscape));
    var RustRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      makeNamedTypeNamer() {
        return camelNamingFunction;
      }
      namerForObjectProperty() {
        return snakeNamingFunction;
      }
      makeUnionMemberNamer() {
        return camelNamingFunction;
      }
      makeEnumCaseNamer() {
        return camelNamingFunction;
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords;
      }
      forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      get commentLineStart() {
        return "/// ";
      }
      nullableRustType(t, withIssues) {
        return ["Option<", this.breakCycle(t, withIssues), ">"];
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      rustType(t, withIssues = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, "Option<serde_json::Value>"), (_nullType) => (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, "Option<serde_json::Value>"), (_boolType) => "bool", (_integerType) => "i64", (_doubleType) => "f64", (_stringType) => "String", (arrayType) => ["Vec<", this.rustType(arrayType.items, withIssues), ">"], (classType) => this.nameForNamedType(classType), (mapType) => ["HashMap<String, ", this.rustType(mapType.values, withIssues), ">"], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return this.nullableRustType(nullable, withIssues);
          const [hasNull] = (0, TypeUtils_1.removeNullFromUnion)(unionType);
          const isCycleBreaker = this.isCycleBreakerType(unionType);
          const name = isCycleBreaker ? ["Box<", this.nameForNamedType(unionType), ">"] : this.nameForNamedType(unionType);
          return hasNull !== null ? ["Option<", name, ">"] : name;
        });
      }
      breakCycle(t, withIssues) {
        const rustType = this.rustType(t, withIssues);
        const isCycleBreaker = this.isCycleBreakerType(t);
        return isCycleBreaker ? ["Box<", rustType, ">"] : rustType;
      }
      emitRenameAttribute(propName, jsonName, defaultNamingStyle, preferedNamingStyle) {
        const escapedName = rustStringEscape(jsonName);
        const name = namingStyles[defaultNamingStyle].fromParts(this.sourcelikeToString(propName).split(" "));
        const styledName = nameToNamingStyle(name, preferedNamingStyle);
        const namesDiffer = escapedName !== styledName;
        if (namesDiffer) {
          this.emitLine('#[serde(rename = "', escapedName, '")]');
        }
      }
      emitSkipSerializeNone(t) {
        if (t instanceof Type_1.UnionType) {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
          if (nullable !== null)
            this.emitLine('#[serde(skip_serializing_if = "Option::is_none")]');
        }
      }
      get visibility() {
        if (this._options.visibility === Visibility.Crate) {
          return "pub(crate) ";
        } else if (this._options.visibility === Visibility.Public) {
          return "pub ";
        }
        return "";
      }
      emitStructDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        const propertiesNamingStyles = {};
        this.forEachClassProperty(c, "none", (_name, jsonName, _prop) => {
          propertiesNamingStyles[jsonName] = listMatchingNamingStyles(jsonName);
        });
        const defaultStyle = "snake_case";
        const preferedNamingStyle = getPreferedNamingStyle(Object.values(propertiesNamingStyles).flat(), defaultStyle);
        if (preferedNamingStyle !== defaultStyle) {
          this.emitLine(`#[serde(rename_all = "${preferedNamingStyle}")]`);
        }
        const blankLines = this._options.density === Density.Dense ? "none" : "interposing";
        const structBody = () => this.forEachClassProperty(c, blankLines, (name, jsonName, prop) => {
          this.emitDescription(this.descriptionForClassProperty(c, jsonName));
          this.emitRenameAttribute(name, jsonName, defaultStyle, preferedNamingStyle);
          if (this._options.skipSerializingNone) {
            this.emitSkipSerializeNone(prop.type);
          }
          this.emitLine(this.visibility, name, ": ", this.breakCycle(prop.type, true), ",");
        });
        this.emitBlock(["pub struct ", className], structBody);
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitUnion(u, unionName) {
        const isMaybeWithSingleType = (0, TypeUtils_1.nullableFromUnion)(u);
        if (isMaybeWithSingleType !== null) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        this.emitLine("#[serde(untagged)]");
        const [, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u);
        const blankLines = this._options.density === Density.Dense ? "none" : "interposing";
        this.emitBlock(["pub enum ", unionName], () => this.forEachUnionMember(u, nonNulls, blankLines, null, (fieldName, t) => {
          const rustType = this.breakCycle(t, true);
          this.emitLine([fieldName, "(", rustType, "),"]);
        }));
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        const enumCasesNamingStyles = {};
        this.forEachEnumCase(e, "none", (_name, jsonName) => {
          enumCasesNamingStyles[jsonName] = listMatchingNamingStyles(jsonName);
        });
        const defaultStyle = "PascalCase";
        const preferedNamingStyle = getPreferedNamingStyle(Object.values(enumCasesNamingStyles).flat(), defaultStyle);
        if (preferedNamingStyle !== defaultStyle) {
          this.emitLine(`#[serde(rename_all = "${preferedNamingStyle}")]`);
        }
        const blankLines = this._options.density === Density.Dense ? "none" : "interposing";
        this.emitBlock(["pub enum ", enumName], () => this.forEachEnumCase(e, blankLines, (name, jsonName) => {
          this.emitRenameAttribute(name, jsonName, defaultStyle, preferedNamingStyle);
          this.emitLine([name, ","]);
        }));
      }
      emitTopLevelAlias(t, name) {
        this.emitLine("pub type ", name, " = ", this.rustType(t), ";");
      }
      emitLeadingComments() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
          return;
        }
        const topLevelName = (0, Support_1.defined)((0, collection_utils_1.mapFirst)(this.topLevels)).getCombinedName();
        this.emitMultiline(`// Example code that deserializes and serializes the model.
// extern crate serde;
// #[macro_use]
// extern crate serde_derive;
// extern crate serde_json;
//
// use generated_module::${topLevelName};
//
// fn main() {
//     let json = r#"{"answer": 42}"#;
//     let model: ${topLevelName} = serde_json::from_str(&json).unwrap();
// }`);
      }
      emitSourceStructure() {
        if (this._options.leadingComments) {
          this.emitLeadingComments();
        }
        this.ensureBlankLine();
        if (this._options.edition2018) {
          this.emitLine("use serde::{Serialize, Deserialize};");
        } else {
          this.emitLine("extern crate serde_derive;");
        }
        if (this.haveMaps) {
          this.emitLine("use std::collections::HashMap;");
        }
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelAlias(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
        this.forEachNamedType("leading-and-interposing", (c, name) => this.emitStructDefinition(c, name), (e, name) => this.emitEnumDefinition(e, name), (u, name) => this.emitUnion(u, name));
      }
    };
    exports.RustRenderer = RustRenderer;
    function getPreferedNamingStyle(namingStyleOccurences, defaultStyle) {
      const occurrences = Object.fromEntries(Object.keys(namingStyles).map((key) => [key, 0]));
      namingStyleOccurences.forEach((style) => ++occurrences[style]);
      const max = Math.max(...Object.values(occurrences));
      const preferedStyles = Object.entries(occurrences).filter(([_style, num]) => num === max).map(([style, _num]) => style);
      if (preferedStyles.includes(defaultStyle)) {
        return defaultStyle;
      }
      return preferedStyles[0];
    }
    function listMatchingNamingStyles(name) {
      return Object.entries(namingStyles).filter(([_, { regex }]) => regex.test(name)).map(([namingStyle, _]) => namingStyle);
    }
    function nameToNamingStyle(name, style) {
      if (namingStyles[style].regex.test(name)) {
        return name;
      }
      const fromStyle = listMatchingNamingStyles(name)[0];
      if (fromStyle === void 0) {
        return name;
      }
      return namingStyles[style].fromParts(namingStyles[fromStyle].toParts(name));
    }
  }
});

// node_modules/quicktype-core/dist/language/Scala3.js
var require_Scala3 = __commonJS({
  "node_modules/quicktype-core/dist/language/Scala3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Scala3TargetLanguage = exports.CirceRenderer = exports.UpickleRenderer = exports.Scala3Renderer = exports.scala3Options = exports.Framework = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var Framework;
    (function(Framework2) {
      Framework2["None"] = "None";
      Framework2["Upickle"] = "Upickle";
      Framework2["Circe"] = "Circe";
    })(Framework = exports.Framework || (exports.Framework = {}));
    exports.scala3Options = {
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", [
        ["just-types", Framework.None],
        ["circe", Framework.Circe],
        ["upickle", Framework.Upickle]
      ], void 0),
      packageName: new RendererOptions_1.StringOption("package", "Package", "PACKAGE", "quicktype")
    };
    var invalidSymbols = [
      ":",
      "-",
      "+",
      "!",
      "@",
      "#",
      "$",
      "%",
      "^",
      "&",
      "*",
      "(",
      ")",
      ">",
      "<",
      "/",
      ";",
      "'",
      '"',
      "{",
      "}",
      ":",
      "~",
      "`",
      "."
    ];
    var keywords = [
      "abstract",
      "case",
      "catch",
      "class",
      "def",
      "do",
      "else",
      "enum",
      "extends",
      "export",
      "false",
      "final",
      "finally",
      "for",
      "forSome",
      "if",
      "implicit",
      "import",
      "lazy",
      "match",
      "new",
      "null",
      "object",
      "override",
      "package",
      "private",
      "protected",
      "return",
      "sealed",
      "super",
      "this",
      "then",
      "throw",
      "trait",
      "try",
      "true",
      "type",
      "val",
      "var",
      "while",
      "with",
      "yield",
      "Any",
      "Boolean",
      "Double",
      "Float",
      "Long",
      "Int",
      "Short",
      "System",
      "Byte",
      "String",
      "Array",
      "List",
      "Map",
      "Enum"
    ];
    var shouldAddBacktick = (paramName) => {
      return keywords.some((s) => paramName === s) || invalidSymbols.some((s) => paramName.includes(s)) || !isNaN(+parseFloat(paramName)) || !isNaN(parseInt(paramName.charAt(0)));
    };
    var wrapOption = (s, optional) => {
      if (optional) {
        return "Option[" + s + "]";
      } else {
        return s;
      }
    };
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function scalaNameStyle(isUpper, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    var upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (s) => scalaNameStyle(true, s));
    var lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (s) => scalaNameStyle(false, s));
    var Scala3Renderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _scalaOptions) {
        super(targetLanguage, renderContext);
        this._scalaOptions = _scalaOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords;
      }
      forbiddenForObjectProperties(_, _classNamed) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
      }
      topLevelNameStyle(rawName) {
        return scalaNameStyle(true, rawName);
      }
      makeNamedTypeNamer() {
        return upperNamingFunction;
      }
      namerForObjectProperty() {
        return lowerNamingFunction;
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => scalaNameStyle(true, s) + "Value");
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => s.replace(" ", ""));
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? ["{", "}"] : delimiter === "paren" ? ["(", ")"] : delimiter === "none" ? ["", ""] : ["{", "})"];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
      }
      anySourceType(optional) {
        return [wrapOption("Any", optional)];
      }
      // (asarazan): I've broken out the following two functions
      // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
      arrayType(arrayType, withIssues = false) {
        return ["Seq[", this.scalaType(arrayType.items, withIssues), "]"];
      }
      mapType(mapType, withIssues = false) {
        return ["Map[String, ", this.scalaType(mapType.values, withIssues), "]"];
      }
      scalaType(t, withIssues = false, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_nullType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_boolType) => "Boolean", (_integerType) => "Long", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => this.arrayType(arrayType, withIssues), (classType) => this.nameForNamedType(classType), (mapType) => this.mapType(mapType, withIssues), (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (noOptional) {
              return [this.scalaType(nullable, withIssues)];
            } else {
              return ["Option[", this.scalaType(nullable, withIssues), "]"];
            }
          }
          return this.nameForNamedType(unionType);
        });
      }
      emitUsageHeader() {
      }
      emitHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine("package ", this._scalaOptions.packageName);
        this.ensureBlankLine();
      }
      emitTopLevelArray(t, name) {
        const elementType = this.scalaType(t.items);
        this.emitLine(["type ", name, " = List[", elementType, "]"]);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.scalaType(t.values);
        this.emitLine(["type ", name, " = Map[String, ", elementType, "]"]);
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("case class ", className, "()");
      }
      emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
          this.emitEmptyClassDefinition(c, className);
          return;
        }
        const scalaType = (p) => {
          if (p.isOptional) {
            return ["Option[", this.scalaType(p.type, true, true), "]"];
          } else {
            return this.scalaType(p.type, true);
          }
        };
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("case class ", className, " (");
        this.indent(() => {
          let count = c.getProperties().size;
          let first = true;
          this.forEachClassProperty(c, "none", (_, jsonName, p) => {
            const nullable = p.type.kind === "union" && (0, TypeUtils_1.nullableFromUnion)(p.type) !== null;
            const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
            const last = --count === 0;
            const meta = [];
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== void 0) {
              meta.push(() => this.emitDescription(description));
            }
            if (meta.length > 0 && !first) {
              this.ensureBlankLine();
            }
            for (const emit of meta) {
              emit();
            }
            const nameNeedsBackticks = jsonName.endsWith("_") || shouldAddBacktick(jsonName);
            const nameWithBackticks = nameNeedsBackticks ? "`" + jsonName + "`" : jsonName;
            this.emitLine("val ", nameWithBackticks, " : ", scalaType(p), p.isOptional ? " = None" : nullableOrOptional ? " = None" : "", last ? "" : ",");
            if (meta.length > 0 && !last) {
              this.ensureBlankLine();
            }
            first = false;
          });
        });
        this.emitClassDefinitionMethods();
      }
      emitClassDefinitionMethods() {
        this.emitLine(")");
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum ", enumName, " : "], () => {
          let count = e.cases.size;
          if (count > 0) {
            this.emitItem("	 case ");
          }
          this.forEachEnumCase(e, "none", (name, jsonName) => {
            if (!(jsonName == "")) {
              const backticks = shouldAddBacktick(jsonName) || jsonName.includes(" ") || !isNaN(parseInt(jsonName.charAt(0)));
              if (backticks) {
                this.emitItem("`");
              }
              this.emitItemOnce([name]);
              if (backticks) {
                this.emitItem("`");
              }
              if (--count > 0)
                this.emitItem([","]);
            } else {
              --count;
            }
          });
        }, "none");
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class")
            return kind;
          return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
          theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
          theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitItem(["type ", unionName, " = "]);
        theTypes.forEach((t, i) => {
          this.emitItem(i === 0 ? t : [" | ", t]);
        });
        this.ensureBlankLine();
      }
      emitSourceStructure() {
        this.emitHeader();
        this.forEachTopLevel("leading", (t, name) => {
          if (t instanceof Type_1.ArrayType) {
            this.emitTopLevelArray(t, name);
          } else if (t instanceof Type_1.MapType) {
            this.emitTopLevelMap(t, name);
          }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.Scala3Renderer = Scala3Renderer;
    var UpickleRenderer = class extends Scala3Renderer {
      emitClassDefinitionMethods() {
        this.emitLine(") derives ReadWriter ");
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import upickle.default.*");
        this.ensureBlankLine();
      }
    };
    exports.UpickleRenderer = UpickleRenderer;
    var CirceRenderer = class extends Scala3Renderer {
      constructor() {
        super(...arguments);
        this.seenUnionTypes = [];
      }
      circeEncoderForType(t, __ = false, noOptional = false, paramName = "") {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => ["Encoder.encodeJson(", paramName, ")"], (_nullType) => ["Encoder.encodeNone(", paramName, ")"], (_boolType) => ["Encoder.encodeBoolean(", paramName, ")"], (_integerType) => ["Encoder.encodeLong(", paramName, ")"], (_doubleType) => ["Encoder.encodeDouble(", paramName, ")"], (_stringType) => ["Encoder.encodeString(", paramName, ")"], (arrayType) => ["Encoder.encodeSeq[", this.scalaType(arrayType.items), "].apply(", paramName, ")"], (classType) => ["Encoder.AsObject[", this.scalaType(classType), "].apply(", paramName, ")"], (mapType) => ["Encoder.encodeMap[String,", this.scalaType(mapType.values), "].apply(", paramName, ")"], (_) => ["Encoder.encodeString(", paramName, ")"], (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            if (noOptional) {
              return ["Encoder.AsObject[", this.nameForNamedType(nullable), "]"];
            } else {
              return ["Encoder.AsObject[Option[", this.nameForNamedType(nullable), "]]"];
            }
          }
          return ["Encoder.AsObject[", this.nameForNamedType(unionType), "]"];
        });
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.ensureBlankLine();
        this.emitLine("case class ", className, "()  derives Encoder.AsObject, Decoder");
      }
      anySourceType(optional) {
        return [wrapOption("Json", optional)];
      }
      emitClassDefinitionMethods() {
        this.emitLine(") derives Encoder.AsObject, Decoder");
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.ensureBlankLine();
        this.emitItem(["type ", enumName, " = "]);
        let count = e.cases.size;
        this.forEachEnumCase(e, "none", (_, jsonName) => {
          this.emitItem(['"', jsonName, '"']);
          if (--count > 0)
            this.emitItem([" | "]);
        });
        this.ensureBlankLine();
      }
      emitHeader() {
        super.emitHeader();
        this.emitLine("import scala.util.Try");
        this.emitLine("import io.circe.syntax._");
        this.emitLine("import io.circe._");
        this.emitLine("import cats.syntax.functor._");
        this.ensureBlankLine();
        this.emitLine("// For serialising string unions");
        this.emitLine("given [A <: Singleton](using A <:< String): Decoder[A] = Decoder.decodeString.emapTry(x => Try(x.asInstanceOf[A])) ");
        this.emitLine("given [A <: Singleton](using ev: A <:< String): Encoder[A] = Encoder.encodeString.contramap(ev) ");
        this.ensureBlankLine();
        this.emitLine("// If a union has a null in, then we'll need this too... ");
        this.emitLine("type NullValue = None.type");
      }
      emitTopLevelArray(t, name) {
        super.emitTopLevelArray(t, name);
        const elementType = this.scalaType(t.items);
        this.emitLine([
          "given (using ev : ",
          elementType,
          "): Encoder[Map[String,",
          elementType,
          "]] = Encoder.encodeMap[String, ",
          elementType,
          "]"
        ]);
      }
      emitTopLevelMap(t, name) {
        super.emitTopLevelMap(t, name);
        const elementType = this.scalaType(t.values);
        this.ensureBlankLine();
        this.emitLine([
          "given (using ev : ",
          elementType,
          "): Encoder[Map[String, ",
          elementType,
          "]] = Encoder.encodeMap[String, ",
          elementType,
          "]"
        ]);
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class")
            return kind;
          return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
          theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
          theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitItem(["type ", unionName, " = "]);
        theTypes.forEach((t, i) => {
          this.emitItem(i === 0 ? t : [" | ", t]);
        });
        const thisUnionType = theTypes.map((x) => this.sourcelikeToString(x)).join(" | ");
        this.ensureBlankLine();
        if (!this.seenUnionTypes.some((y) => y === thisUnionType)) {
          this.seenUnionTypes.push(thisUnionType);
          const sourceLikeTypes = [];
          this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
            sourceLikeTypes.push([this.scalaType(t), t]);
          });
          if (maybeNull !== null) {
            sourceLikeTypes.push([this.nameForUnionMember(u, maybeNull), maybeNull]);
          }
          this.emitLine(["given Decoder[", unionName, "] = {"]);
          this.indent(() => {
            this.emitLine(["List[Decoder[", unionName, "]]("]);
            this.indent(() => {
              sourceLikeTypes.forEach((t) => {
                this.emitLine(["Decoder[", t[0], "].widen,"]);
              });
            });
            this.emitLine(").reduceLeft(_ or _)");
          });
          this.emitLine(["}"]);
          this.ensureBlankLine();
          this.emitLine(["given Encoder[", unionName, "] = Encoder.instance {"]);
          this.indent(() => {
            sourceLikeTypes.forEach((t, i) => {
              const paramTemp = `enc${i.toString()}`;
              this.emitLine([
                "case ",
                paramTemp,
                " : ",
                t[0],
                " => ",
                this.circeEncoderForType(t[1], false, false, paramTemp)
              ]);
            });
          });
          this.emitLine("}");
        }
      }
    };
    exports.CirceRenderer = CirceRenderer;
    var Scala3TargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Scala3", ["scala3"], "scala");
      }
      getOptions() {
        return [exports.scala3Options.framework, exports.scala3Options.packageName];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.scala3Options, untypedOptionValues);
        switch (options.framework) {
          case Framework.None:
            return new Scala3Renderer(this, renderContext, options);
          case Framework.Upickle:
            return new UpickleRenderer(this, renderContext, options);
          case Framework.Circe:
            return new CirceRenderer(this, renderContext, options);
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.Scala3TargetLanguage = Scala3TargetLanguage;
  }
});

// node_modules/quicktype-core/dist/language/Smithy4s.js
var require_Smithy4s = __commonJS({
  "node_modules/quicktype-core/dist/language/Smithy4s.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SmithyTargetLanguage = exports.Smithy4sRenderer = exports.SmithyOptions = exports.Framework = void 0;
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var Framework;
    (function(Framework2) {
      Framework2["None"] = "None";
    })(Framework = exports.Framework || (exports.Framework = {}));
    exports.SmithyOptions = {
      framework: new RendererOptions_1.EnumOption("framework", "Serialization framework", [["just-types", Framework.None]], void 0),
      packageName: new RendererOptions_1.StringOption("package", "Package", "PACKAGE", "quicktype")
    };
    var invalidSymbols = [
      ":",
      "-",
      "+",
      "!",
      "@",
      "#",
      "%",
      "^",
      "&",
      "*",
      "(",
      ")",
      ">",
      "<",
      "/",
      ";",
      "'",
      '"',
      "{",
      "}",
      ":",
      "~",
      "`",
      "."
    ];
    var keywords = [
      "abstract",
      "case",
      "catch",
      "do",
      "else",
      "export",
      "false",
      "final",
      "finally",
      "for",
      "forSome",
      "if",
      "implicit",
      "import",
      "new",
      "override",
      "package",
      "private",
      "protected",
      "return",
      "sealed",
      "super",
      "this",
      "then",
      "throw",
      "trait",
      "try",
      "true",
      "val",
      "var",
      "while",
      "with",
      "yield",
      "Any",
      "Boolean",
      "Double",
      "Float",
      "Long",
      "Int",
      "Short",
      "System",
      "Byte",
      "String",
      "Array",
      "List",
      "Map",
      "Enum"
    ];
    var shouldAddBacktick = (paramName) => {
      return keywords.some((s) => paramName === s) || invalidSymbols.some((s) => paramName.includes(s)) || !isNaN(parseFloat(paramName)) || !isNaN(parseInt(paramName.charAt(0)));
    };
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function scalaNameStyle(isUpper, original) {
      const words = (0, Strings_1.splitIntoWords)(original);
      return (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.allUpperWordStyle, "", isStartCharacter);
    }
    var upperNamingFunction = (0, Naming_1.funPrefixNamer)("upper", (s) => scalaNameStyle(true, s));
    var lowerNamingFunction = (0, Naming_1.funPrefixNamer)("lower", (s) => scalaNameStyle(false, s));
    var Smithy4sRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _scalaOptions) {
        super(targetLanguage, renderContext);
        this._scalaOptions = _scalaOptions;
      }
      forbiddenNamesForGlobalNamespace() {
        return keywords;
      }
      forbiddenForObjectProperties(_, _classNamed) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
      }
      topLevelNameStyle(rawName) {
        return scalaNameStyle(true, rawName);
      }
      makeNamedTypeNamer() {
        return upperNamingFunction;
      }
      namerForObjectProperty() {
        return lowerNamingFunction;
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => scalaNameStyle(true, s) + "Value");
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => s.replace(" ", ""));
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
      }
      emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? ["{", "}"] : delimiter === "paren" ? ["(", ")"] : delimiter === "none" ? ["", ""] : ["{", "})"];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
      }
      anySourceType(_) {
        return ["Document"];
      }
      // (asarazan): I've broken out the following two functions
      // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
      arrayType(arrayType, _ = false) {
        return arrayType.getCombinedName().toString() + "List";
      }
      emitArrayType(_, smithyType) {
        this.emitLine(["list ", smithyType, " { member : ", "}"]);
      }
      mapType(mapType, _ = false) {
        return mapType.getCombinedName().toString() + "Map";
      }
      scalaType(t, withIssues = false, noOptional = false) {
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_nullType) => {
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, (_boolType) => "Boolean", (_integerType) => "Long", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => this.arrayType(arrayType, withIssues), (classType) => this.nameForNamedType(classType), (mapType) => this.mapType(mapType, withIssues), (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null) {
            return [this.scalaType(nullable, withIssues)];
          }
          return this.nameForNamedType(unionType);
        });
      }
      emitUsageHeader() {
      }
      emitHeader() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else {
          this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine('$version: "2"');
        this.emitLine("namespace ", this._scalaOptions.packageName);
        this.ensureBlankLine();
        this.emitLine("document NullValue");
        this.ensureBlankLine();
      }
      emitTopLevelArray(t, name) {
        const elementType = this.scalaType(t.items);
        this.emitLine(["list ", name, " { member : ", elementType, "}"]);
      }
      emitTopLevelMap(t, name) {
        const elementType = this.scalaType(t.values);
        this.emitLine(["map ", name, " { map[ key : String , value : ", elementType, "}"]);
      }
      emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("structure ", className, "{}");
      }
      emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
          this.emitEmptyClassDefinition(c, className);
          return;
        }
        const scalaType = (p) => {
          if (p.isOptional) {
            return [this.scalaType(p.type, true, true)];
          } else {
            return [this.scalaType(p.type, true)];
          }
        };
        const emitLater = [];
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("structure ", className, " {");
        this.indent(() => {
          let count = c.getProperties().size;
          let first = true;
          this.forEachClassProperty(c, "none", (_, jsonName, p) => {
            const nullable = p.type.kind === "union" && (0, TypeUtils_1.nullableFromUnion)(p.type) !== null;
            const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
            const last = --count === 0;
            const meta = [];
            const laterType = p.type.kind === "array" || p.type.kind === "map";
            if (laterType) {
              emitLater.push(p);
            }
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== void 0) {
              meta.push(() => this.emitDescription(description));
            }
            if (meta.length > 0 && !first) {
              this.ensureBlankLine();
            }
            for (const emit of meta) {
              emit();
            }
            const nameNeedsBackticks = jsonName.endsWith("_") || shouldAddBacktick(jsonName);
            const nameWithBackticks = nameNeedsBackticks ? "`" + jsonName + "`" : jsonName;
            this.emitLine(p.isOptional ? "" : nullableOrOptional ? "" : "@required ", nameWithBackticks, " : ", scalaType(p), last ? "" : ",");
            if (meta.length > 0 && !last) {
              this.ensureBlankLine();
            }
            first = false;
          });
        });
        this.emitClassDefinitionMethods(emitLater);
      }
      emitClassDefinitionMethods(arrayTypes) {
        this.emitLine("}");
        arrayTypes.forEach((p) => {
          function ignore(_) {
            return;
          }
          (0, TypeUtils_1.matchCompoundType)(p.type, (at) => {
            this.emitLine([
              "list ",
              this.scalaType(at, true),
              "{ member: ",
              this.scalaType(at.items, true),
              "}"
            ]);
          }, ignore, (mt) => {
            this.emitLine([
              "map ",
              this.scalaType(mt, true),
              "{ key: String , value: ",
              this.scalaType(mt.values, true),
              "}"
            ]);
          }, ignore, ignore);
        });
      }
      emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.ensureBlankLine();
        this.emitItem(["enum ", enumName, " { "]);
        let count = e.cases.size;
        this.forEachEnumCase(e, "none", (name, jsonName) => {
          this.emitLine();
          this.emitItem([name, ' = "', jsonName, '"']);
          if (--count > 0)
            this.emitItem([","]);
        });
        this.ensureBlankLine();
        this.emitItem(["}"]);
      }
      emitUnionDefinition(u, unionName) {
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class")
            return kind;
          return "_" + kind;
        }
        const emitLater = [];
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
          const laterType = t.kind === "array" || t.kind === "map";
          if (laterType) {
            emitLater.push(t);
          }
          theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
          theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitLine(["@untagged union ", unionName, " { "]);
        this.indent(() => {
          theTypes.forEach((t, i) => {
            this.emitLine([String.fromCharCode(i + 65), " : ", t]);
          });
        });
        this.emitLine("}");
        this.ensureBlankLine();
        emitLater.forEach((p) => {
          function ignore(_) {
            return;
          }
          (0, TypeUtils_1.matchCompoundType)(p, (at) => {
            this.emitLine([
              "list ",
              this.scalaType(at, true),
              "{ member: ",
              this.scalaType(at.items, true),
              "}"
            ]);
          }, ignore, (mt) => {
            this.emitLine([
              "map ",
              this.scalaType(mt, true),
              "{ key: String , value: ",
              this.scalaType(mt.values, true),
              "}"
            ]);
          }, ignore, ignore);
        });
      }
      emitSourceStructure() {
        this.emitHeader();
        this.forEachTopLevel("leading", (t, name) => {
          if (t instanceof Type_1.ArrayType) {
            this.emitTopLevelArray(t, name);
          } else if (t instanceof Type_1.MapType) {
            this.emitTopLevelMap(t, name);
          }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
      }
    };
    exports.Smithy4sRenderer = Smithy4sRenderer;
    var SmithyTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Smithy", ["Smithy"], "smithy");
      }
      getOptions() {
        return [exports.SmithyOptions.framework, exports.SmithyOptions.packageName];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        const options = (0, RendererOptions_1.getOptionValues)(exports.SmithyOptions, untypedOptionValues);
        switch (options.framework) {
          case Framework.None:
            return new Smithy4sRenderer(this, renderContext, options);
          default:
            return (0, Support_1.assertNever)(options.framework);
        }
      }
    };
    exports.SmithyTargetLanguage = SmithyTargetLanguage;
  }
});

// node_modules/quicktype-core/dist/language/Swift.js
var require_Swift = __commonJS({
  "node_modules/quicktype-core/dist/language/Swift.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SwiftRenderer = exports.SwiftTargetLanguage = exports.swiftOptions = void 0;
    var collection_utils_1 = require_dist();
    var Annotation_1 = require_Annotation();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var DateTime_1 = require_DateTime();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var MAX_SAMELINE_PROPERTIES = 4;
    exports.swiftOptions = {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Plain types only", false),
      convenienceInitializers: new RendererOptions_1.BooleanOption("initializers", "Generate initializers and mutators", true),
      explicitCodingKeys: new RendererOptions_1.BooleanOption("coding-keys", "Explicit CodingKey values in Codable types", true),
      codingKeysProtocol: new RendererOptions_1.StringOption("coding-keys-protocol", "CodingKeys implements protocols", "protocol1, protocol2...", "", "secondary"),
      alamofire: new RendererOptions_1.BooleanOption("alamofire", "Alamofire extensions", false),
      namedTypePrefix: new RendererOptions_1.StringOption("type-prefix", "Prefix for type names", "PREFIX", "", "secondary"),
      useClasses: new RendererOptions_1.EnumOption("struct-or-class", "Structs or classes", [
        ["struct", false],
        ["class", true]
      ]),
      mutableProperties: new RendererOptions_1.BooleanOption("mutable-properties", "Use var instead of let for object properties", false),
      acronymStyle: (0, Acronyms_1.acronymOption)(Acronyms_1.AcronymStyleOptions.Pascal),
      dense: new RendererOptions_1.EnumOption("density", "Code density", [
        ["dense", true],
        ["normal", false]
      ], "dense", "secondary"),
      linux: new RendererOptions_1.BooleanOption("support-linux", "Support Linux", false, "secondary"),
      objcSupport: new RendererOptions_1.BooleanOption("objective-c-support", "Objects inherit from NSObject and @objcMembers is added to classes", false),
      optionalEnums: new RendererOptions_1.BooleanOption("optional-enums", "If no matching case is found enum value is set to null", false),
      swift5Support: new RendererOptions_1.BooleanOption("swift-5-support", "Renders output in a Swift 5 compatible mode", false),
      sendable: new RendererOptions_1.BooleanOption("sendable", "Mark generated models as Sendable", false),
      multiFileOutput: new RendererOptions_1.BooleanOption("multi-file-output", "Renders each top-level object in its own Swift file", false),
      accessLevel: new RendererOptions_1.EnumOption("access-level", "Access level", [
        ["internal", "internal"],
        ["public", "public"]
      ], "internal", "secondary"),
      protocol: new RendererOptions_1.EnumOption("protocol", "Make types implement protocol", [
        ["none", { equatable: false, hashable: false }],
        ["equatable", { equatable: true, hashable: false }],
        ["hashable", { equatable: false, hashable: true }]
      ], "none", "secondary")
    };
    var swiftDateTimeRegex = /^\d+-\d+-\d+T\d+:\d+:\d+([zZ]|[+-]\d+(:\d+)?)$/;
    var SwiftDateTimeRecognizer = class extends DateTime_1.DefaultDateTimeRecognizer {
      isDateTime(str) {
        return swiftDateTimeRegex.exec(str) !== null;
      }
    };
    var SwiftTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      constructor() {
        super("Swift", ["swift", "swift4"], "swift");
      }
      getOptions() {
        return [
          exports.swiftOptions.justTypes,
          exports.swiftOptions.useClasses,
          exports.swiftOptions.dense,
          exports.swiftOptions.convenienceInitializers,
          exports.swiftOptions.explicitCodingKeys,
          exports.swiftOptions.codingKeysProtocol,
          exports.swiftOptions.accessLevel,
          exports.swiftOptions.alamofire,
          exports.swiftOptions.linux,
          exports.swiftOptions.namedTypePrefix,
          exports.swiftOptions.protocol,
          exports.swiftOptions.acronymStyle,
          exports.swiftOptions.objcSupport,
          exports.swiftOptions.optionalEnums,
          exports.swiftOptions.sendable,
          exports.swiftOptions.swift5Support,
          exports.swiftOptions.multiFileOutput,
          exports.swiftOptions.mutableProperties
        ];
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        mapping.set("date-time", "date-time");
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      get supportsUnionsWithBothNumberTypes() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new SwiftRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.swiftOptions, untypedOptionValues));
      }
      get dateTimeRecognizer() {
        return new SwiftDateTimeRecognizer();
      }
    };
    exports.SwiftTargetLanguage = SwiftTargetLanguage;
    var keywords = [
      "await",
      "associatedtype",
      "class",
      "deinit",
      "enum",
      "extension",
      "fileprivate",
      "func",
      "import",
      "init",
      "inout",
      "internal",
      "let",
      "open",
      "operator",
      "private",
      "protocol",
      "public",
      "static",
      "struct",
      "subscript",
      "typealias",
      "var",
      "break",
      "case",
      "continue",
      "default",
      "defer",
      "do",
      "else",
      "fallthrough",
      "for",
      "guard",
      "if",
      "in",
      "repeat",
      "return",
      "switch",
      "where",
      "while",
      "as",
      "Any",
      "catch",
      "false",
      "is",
      "nil",
      "rethrows",
      "super",
      "self",
      "Self",
      "throw",
      "throws",
      "true",
      "try",
      "_",
      "associativity",
      "convenience",
      "dynamic",
      "didSet",
      "final",
      "get",
      "infix",
      "indirect",
      "lazy",
      "left",
      "mutating",
      "nonmutating",
      "optional",
      "override",
      "postfix",
      "precedence",
      "prefix",
      "Protocol",
      "required",
      "right",
      "set",
      "Type",
      "unowned",
      "weak",
      "willSet",
      "String",
      "Int",
      "Double",
      "Bool",
      "Data",
      "Date",
      "URL",
      "CommandLine",
      "FileHandle",
      "JSONSerialization",
      "checkNull",
      "removeNSNull",
      "nilToNSNull",
      "convertArray",
      "convertOptional",
      "convertDict",
      "convertDouble",
      "jsonString",
      "jsonData"
    ];
    function isPartCharacter(codePoint) {
      return (0, Strings_1.isLetterOrUnderscore)(codePoint) || (0, Strings_1.isNumeric)(codePoint);
    }
    function isStartCharacter(codePoint) {
      return isPartCharacter(codePoint) && !(0, Strings_1.isDigit)(codePoint);
    }
    var legalizeName = (0, Strings_1.legalizeCharacters)(isPartCharacter);
    function swiftNameStyle(prefix, isUpper, original, acronymsStyle = Strings_1.allUpperWordStyle) {
      const words = (0, Strings_1.splitIntoWords)(original);
      const combined = (0, Strings_1.combineWords)(words, legalizeName, isUpper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, isUpper ? Strings_1.allUpperWordStyle : Strings_1.allLowerWordStyle, acronymsStyle, "", isStartCharacter);
      return (0, Strings_1.addPrefixIfNecessary)(prefix, combined);
    }
    function unicodeEscape(codePoint) {
      return "\\u{" + (0, Strings_1.intToHex)(codePoint, 0) + "}";
    }
    var stringEscape = (0, Strings_1.utf32ConcatMap)((0, Strings_1.escapeNonPrintableMapper)(Strings_1.isPrintable, unicodeEscape));
    var SwiftRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._needAny = false;
        this._needNull = false;
        this.emitSupportFunctions4 = () => {
          this.startFile("JSONSchemaSupport");
          this.emitLineOnce("import Foundation");
          this.forEachTopLevel("leading", (t, name) => this.renderTopLevelAlias(t, name), (t) => this.namedTypeToNameForTopLevel(t) === void 0);
          if (this._options.convenienceInitializers) {
            this.ensureBlankLine();
            this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevelMapAndArrayConvenienceInitializerExtensions(t, name));
          }
          if (!this._options.justTypes && this._options.convenienceInitializers || this._options.alamofire) {
            this.ensureBlankLine();
            this.emitMark("Helper functions for creating encoders and decoders", true);
            this.ensureBlankLine();
            this.emitNewEncoderDecoder();
          }
          if (this._options.alamofire) {
            this.ensureBlankLine();
            this.emitMark("Alamofire response handlers", true);
            this.ensureBlankLine();
            this.emitAlamofireExtension();
          }
          if (this._needAny || this._needNull) {
            this.ensureBlankLine();
            this.emitMark("Encode/decode helpers", true);
            this.ensureBlankLine();
            if (this._options.objcSupport) {
              this.emitLine(this.objcMembersDeclaration, this.accessLevel, "class JSONNull: NSObject, Codable {");
            } else {
              this.emitLine(this.accessLevel, "class JSONNull: Codable, Hashable {");
            }
            this.ensureBlankLine();
            this.emitMultiline(`    public static func == (lhs: JSONNull, rhs: JSONNull) -> Bool {
        return true
    }`);
            if (this._options.objcSupport === false) {
              this.ensureBlankLine();
              this.emitMultiline(`    public var hashValue: Int {
        return 0
    }`);
              if (this._options.swift5Support) {
                this.ensureBlankLine();
                this.emitMultiline(`    public func hash(into hasher: inout Hasher) {
        // No-op
    }`);
              }
            }
            this.ensureBlankLine();
            if (this._options.objcSupport) {
              this.emitItem("    override ");
            } else {
              this.emitItem("    ");
            }
            this.emitMultiline(`public init() {}
    
    public required init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if !container.decodeNil() {
            throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for JSONNull"))
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encodeNil()
    }
}`);
          }
          if (this._needAny) {
            this.ensureBlankLine();
            this.emitMultiline(`class JSONCodingKey: CodingKey {
    let key: String
    
    required init?(intValue: Int) {
        return nil
    }
    
    required init?(stringValue: String) {
        key = stringValue
    }
    
    var intValue: Int? {
        return nil
    }
    
    var stringValue: String {
        return key
    }
}`);
            this.ensureBlankLine();
            if (this._options.objcSupport) {
              this.emitLine(this.objcMembersDeclaration, this.accessLevel, "class JSONAny: NSObject, Codable {");
            } else {
              this.emitLine(this.accessLevel, "class JSONAny: Codable {");
            }
            this.ensureBlankLine();
            this.emitMultiline(`    ${this.accessLevel}let value: Any
    
    static func decodingError(forCodingPath codingPath: [CodingKey]) -> DecodingError {
        let context = DecodingError.Context(codingPath: codingPath, debugDescription: "Cannot decode JSONAny")
        return DecodingError.typeMismatch(JSONAny.self, context)
    }
    
    static func encodingError(forValue value: Any, codingPath: [CodingKey]) -> EncodingError {
        let context = EncodingError.Context(codingPath: codingPath, debugDescription: "Cannot encode JSONAny")
        return EncodingError.invalidValue(value, context)
    }

    static func decode(from container: SingleValueDecodingContainer) throws -> Any {
        if let value = try? container.decode(Bool.self) {
            return value
        }
        if let value = try? container.decode(Int64.self) {
            return value
        }
        if let value = try? container.decode(Double.self) {
            return value
        }
        if let value = try? container.decode(String.self) {
            return value
        }
        if container.decodeNil() {
            return JSONNull()
        }
        throw decodingError(forCodingPath: container.codingPath)
    }
    
    static func decode(from container: inout UnkeyedDecodingContainer) throws -> Any {
        if let value = try? container.decode(Bool.self) {
            return value
        }
        if let value = try? container.decode(Int64.self) {
            return value
        }
        if let value = try? container.decode(Double.self) {
            return value
        }
        if let value = try? container.decode(String.self) {
            return value
        }
        if let value = try? container.decodeNil() {
            if value {
                return JSONNull()
            }
        }
        if var container = try? container.nestedUnkeyedContainer() {
            return try decodeArray(from: &container)
        }
        if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self) {
            return try decodeDictionary(from: &container)
        }
        throw decodingError(forCodingPath: container.codingPath)
    }
    
    static func decode(from container: inout KeyedDecodingContainer<JSONCodingKey>, forKey key: JSONCodingKey) throws -> Any {
        if let value = try? container.decode(Bool.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(Int64.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(Double.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(String.self, forKey: key) {
            return value
        }
        if let value = try? container.decodeNil(forKey: key) {
            if value {
                return JSONNull()
            }
        }
        if var container = try? container.nestedUnkeyedContainer(forKey: key) {
            return try decodeArray(from: &container)
        }
        if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key) {
            return try decodeDictionary(from: &container)
        }
        throw decodingError(forCodingPath: container.codingPath)
    }
    
    static func decodeArray(from container: inout UnkeyedDecodingContainer) throws -> [Any] {
        var arr: [Any] = []
        while !container.isAtEnd {
            let value = try decode(from: &container)
            arr.append(value)
        }
        return arr
    }

    static func decodeDictionary(from container: inout KeyedDecodingContainer<JSONCodingKey>) throws -> [String: Any] {
        var dict = [String: Any]()
        for key in container.allKeys {
            let value = try decode(from: &container, forKey: key)
            dict[key.stringValue] = value
        }
        return dict
    }
    
    static func encode(to container: inout UnkeyedEncodingContainer, array: [Any]) throws {
        for value in array {
            if let value = value as? Bool {
                try container.encode(value)
            } else if let value = value as? Int64 {
                try container.encode(value)
            } else if let value = value as? Double {
                try container.encode(value)
            } else if let value = value as? String {
                try container.encode(value)
            } else if value is JSONNull {
                try container.encodeNil()
            } else if let value = value as? [Any] {
                var container = container.nestedUnkeyedContainer()
                try encode(to: &container, array: value)
            } else if let value = value as? [String: Any] {
                var container = container.nestedContainer(keyedBy: JSONCodingKey.self)
                try encode(to: &container, dictionary: value)
            } else {
                throw encodingError(forValue: value, codingPath: container.codingPath)
            }
        }
    }
    
    static func encode(to container: inout KeyedEncodingContainer<JSONCodingKey>, dictionary: [String: Any]) throws {
        for (key, value) in dictionary {
            let key = JSONCodingKey(stringValue: key)!
            if let value = value as? Bool {
                try container.encode(value, forKey: key)
            } else if let value = value as? Int64 {
                try container.encode(value, forKey: key)
            } else if let value = value as? Double {
                try container.encode(value, forKey: key)
            } else if let value = value as? String {
                try container.encode(value, forKey: key)
            } else if value is JSONNull {
                try container.encodeNil(forKey: key)
            } else if let value = value as? [Any] {
                var container = container.nestedUnkeyedContainer(forKey: key)
                try encode(to: &container, array: value)
            } else if let value = value as? [String: Any] {
                var container = container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key)
                try encode(to: &container, dictionary: value)
            } else {
                throw encodingError(forValue: value, codingPath: container.codingPath)
            }
        }
    }

    static func encode(to container: inout SingleValueEncodingContainer, value: Any) throws {
        if let value = value as? Bool {
            try container.encode(value)
        } else if let value = value as? Int64 {
            try container.encode(value)
        } else if let value = value as? Double {
            try container.encode(value)
        } else if let value = value as? String {
            try container.encode(value)
        } else if value is JSONNull {
            try container.encodeNil()
        } else {
            throw encodingError(forValue: value, codingPath: container.codingPath)
        }
    }
    
    public required init(from decoder: Decoder) throws {
        if var arrayContainer = try? decoder.unkeyedContainer() {
            self.value = try JSONAny.decodeArray(from: &arrayContainer)
        } else if var container = try? decoder.container(keyedBy: JSONCodingKey.self) {
            self.value = try JSONAny.decodeDictionary(from: &container)
        } else {
            let container = try decoder.singleValueContainer()
            self.value = try JSONAny.decode(from: container)
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        if let arr = self.value as? [Any] {
            var container = encoder.unkeyedContainer()
            try JSONAny.encode(to: &container, array: arr)
        } else if let dict = self.value as? [String: Any] {
            var container = encoder.container(keyedBy: JSONCodingKey.self)
            try JSONAny.encode(to: &container, dictionary: dict)
        } else {
            var container = encoder.singleValueContainer()
            try JSONAny.encode(to: &container, value: self.value)
        }
    }
}`);
          }
          this.endFile();
        };
      }
      forbiddenNamesForGlobalNamespace() {
        if (this._options.alamofire) {
          return ["DataRequest", ...keywords];
        }
        return keywords;
      }
      forbiddenForObjectProperties(_c, _classNamed) {
        return { names: ["fromURL", "json"], includeGlobalForbidden: true };
      }
      forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
      }
      forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("upper", (s) => swiftNameStyle(this._options.namedTypePrefix, true, s, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)));
      }
      namerForObjectProperty() {
        return this.lowerNamingFunction;
      }
      makeUnionMemberNamer() {
        return this.lowerNamingFunction;
      }
      makeEnumCaseNamer() {
        return this.lowerNamingFunction;
      }
      isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
      }
      emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: "/// " });
      }
      emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
      }
      emitBlockWithAccess(line, f) {
        this.emitBlock([this.accessLevel, line], f);
      }
      justTypesCase(justTypes, notJustTypes) {
        if (this._options.justTypes)
          return justTypes;
        else
          return notJustTypes;
      }
      get lowerNamingFunction() {
        return (0, Naming_1.funPrefixNamer)("lower", (s) => swiftNameStyle("", false, s, (0, Acronyms_1.acronymStyle)(this._options.acronymStyle)));
      }
      swiftPropertyType(p) {
        if (p.isOptional || this._options.optionalEnums && p.type.kind === "enum") {
          return [this.swiftType(p.type, true, true), "?"];
        } else {
          return this.swiftType(p.type, true);
        }
      }
      swiftType(t, withIssues = false, noOptional = false) {
        const optional = noOptional ? "" : "?";
        return (0, TypeUtils_1.matchType)(t, (_anyType) => {
          this._needAny = true;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.anyTypeIssueAnnotation, this.justTypesCase(["Any", optional], "JSONAny"));
        }, (_nullType) => {
          this._needNull = true;
          return (0, Source_1.maybeAnnotated)(withIssues, Annotation_1.nullTypeIssueAnnotation, this.justTypesCase("NSNull", ["JSONNull", optional]));
        }, (_boolType) => "Bool", (_integerType) => "Int", (_doubleType) => "Double", (_stringType) => "String", (arrayType) => ["[", this.swiftType(arrayType.items, withIssues), "]"], (classType) => this.nameForNamedType(classType), (mapType) => ["[String: ", this.swiftType(mapType.values, withIssues), "]"], (enumType) => this.nameForNamedType(enumType), (unionType) => {
          const nullable = (0, TypeUtils_1.nullableFromUnion)(unionType);
          if (nullable !== null)
            return [this.swiftType(nullable, withIssues), optional];
          return this.nameForNamedType(unionType);
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return "Date";
          } else {
            return (0, Support_1.panic)(`Transformed string type ${transformedStringType.kind} not supported`);
          }
        });
      }
      proposedUnionMemberNameForTypeKind(kind) {
        if (kind === "enum") {
          return "enumeration";
        }
        if (kind === "union") {
          return "one_of";
        }
        return null;
      }
      renderSingleFileHeaderComments() {
        this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
        this.emitLineOnce("// To parse the JSON, add this file to your project and do:");
        this.emitLineOnce("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
          if (this._options.convenienceInitializers && !(t instanceof Type_1.EnumType)) {
            this.emitLineOnce("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = try ", topLevelName, "(json)");
          } else {
            this.emitLineOnce("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, topLevelName), " = ", "try? JSONDecoder().decode(", topLevelName, ".self, from: jsonData)");
          }
        });
      }
      renderHeader(type, name) {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        } else if (!this._options.justTypes) {
          if (this._options.multiFileOutput) {
            this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
            this.emitLineOnce("// To parse the JSON, add this file to your project and do:");
            this.emitLineOnce("//");
            if (this._options.convenienceInitializers && !(type instanceof Type_1.EnumType)) {
              this.emitLine("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = try ", name, "(json)");
            } else {
              this.emitLine("//   let ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = ", "try? newJSONDecoder().decode(", name, ".self, from: jsonData)");
            }
          }
          if (this._options.alamofire) {
            this.emitLine("//");
            this.emitLine("// To parse values from Alamofire responses:");
            this.emitLine("//");
            this.emitLine("//   Alamofire.request(url).response", name, " { response in");
            this.emitLine("//     if let ", (0, Source_1.modifySource)(Strings_1.camelCase, name), " = response.result.value {");
            this.emitLine("//       ...");
            this.emitLine("//     }");
            this.emitLine("//   }");
          }
          if (this._options.protocol.hashable || this._options.protocol.equatable) {
            this.emitLine("//");
            this.emitLine("// Hashable or Equatable:");
            this.emitLine("// The compiler will not be able to synthesize the implementation of Hashable or Equatable");
            this.emitLine("// for types that require the use of JSONAny, nor will the implementation of Hashable be");
            this.emitLine("// synthesized for types that have collections (such as arrays or dictionaries).");
          }
        }
        this.ensureBlankLine();
        this.emitLineOnce("import Foundation");
        if (!this._options.justTypes && this._options.alamofire) {
          this.emitLineOnce("import Alamofire");
        }
        if (this._options.optionalEnums) {
          this.emitLineOnce("import OptionallyDecodable // https://github.com/idrougge/OptionallyDecodable");
        }
        this.ensureBlankLine();
      }
      renderTopLevelAlias(t, name) {
        this.emitLine(this.accessLevel, "typealias ", name, " = ", this.swiftType(t, true));
      }
      getProtocolsArray(kind) {
        const protocols = [];
        const isClass = kind === "class";
        if (isClass && this._options.objcSupport) {
          protocols.push("NSObject");
        }
        if (!this._options.justTypes) {
          protocols.push("Codable");
        }
        if (this._options.protocol.hashable) {
          protocols.push("Hashable");
        }
        if (this._options.protocol.equatable) {
          protocols.push("Equatable");
        }
        if (this._options.sendable && (!this._options.mutableProperties || !isClass) && !this._options.objcSupport) {
          protocols.push("Sendable");
        }
        return protocols;
      }
      getProtocolString(kind, baseClass = void 0) {
        let protocols = this.getProtocolsArray(kind);
        if (baseClass) {
          protocols.unshift(baseClass);
        }
        return protocols.length > 0 ? ": " + protocols.join(", ") : "";
      }
      getEnumPropertyGroups(c) {
        let groups = [];
        let group = [];
        this.forEachClassProperty(c, "none", (name, jsonName) => {
          const label = stringEscape(jsonName);
          const redundant = this.sourcelikeToString(name) === label;
          if (this._options.dense && redundant) {
            group.push({ name });
          } else {
            if (group.length > 0) {
              groups.push(group);
              group = [];
            }
            groups.push([{ name, label }]);
          }
        });
        if (group.length > 0) {
          groups.push(group);
        }
        return groups;
      }
      /// Access level with trailing space (e.g. "public "), or empty string
      get accessLevel() {
        return this._options.accessLevel === "internal" ? "" : this._options.accessLevel + " ";
      }
      get objcMembersDeclaration() {
        if (this._options.objcSupport) {
          return "@objcMembers ";
        }
        return "";
      }
      /// startFile takes a file name, appends ".swift" to it and sets it as the current filename.
      startFile(basename) {
        if (this._options.multiFileOutput === false) {
          return;
        }
        (0, Support_1.assert)(this._currentFilename === void 0, "Previous file wasn't finished: " + this._currentFilename);
        this._currentFilename = `${this.sourcelikeToString(basename)}.swift`;
        this.initializeEmitContextForFilename(this._currentFilename);
      }
      /// endFile pushes the current file name onto the collection of finished files and then resets the current file name. These finished files are used in index.ts to write the output.
      endFile() {
        if (this._options.multiFileOutput === false) {
          return;
        }
        this.finishFile((0, Support_1.defined)(this._currentFilename));
        this._currentFilename = void 0;
      }
      propertyLinesDefinition(name, parameter) {
        const useMutableProperties = this._options.mutableProperties;
        return [
          this.accessLevel,
          useMutableProperties ? "var " : "let ",
          name,
          ": ",
          this.swiftPropertyType(parameter)
        ];
      }
      renderClassDefinition(c, className) {
        this.startFile(className);
        this.renderHeader(c, className);
        this.emitDescription(this.descriptionForType(c));
        this.emitMark(this.sourcelikeToString(className), true);
        const isClass = this._options.useClasses || this.isCycleBreakerType(c);
        const structOrClass = isClass ? "class" : "struct";
        if (isClass && this._options.objcSupport) {
          this.emitItem(this.objcMembersDeclaration);
        }
        this.emitBlockWithAccess([structOrClass, " ", className, this.getProtocolString(structOrClass)], () => {
          if (this._options.dense) {
            let lastProperty = void 0;
            let lastNames = [];
            const emitLastProperty = () => {
              if (lastProperty === void 0)
                return;
              const useMutableProperties = this._options.mutableProperties;
              let sources = [
                [
                  this._options.optionalEnums && lastProperty.type.kind === "enum" ? "@OptionallyDecodable " : "",
                  this.accessLevel,
                  useMutableProperties || this._options.optionalEnums && lastProperty.type.kind === "enum" ? "var " : "let "
                ]
              ];
              lastNames.forEach((n, i) => {
                if (i > 0)
                  sources.push(", ");
                sources.push(n);
              });
              sources.push(": ");
              sources.push(this.swiftPropertyType(lastProperty));
              this.emitLine(sources);
              lastProperty = void 0;
              lastNames = [];
            };
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
              const description = this.descriptionForClassProperty(c, jsonName);
              if (lastProperty && !p.equals(lastProperty) || lastNames.length >= MAX_SAMELINE_PROPERTIES || description !== void 0) {
                emitLastProperty();
              }
              if (lastProperty === void 0) {
                lastProperty = p;
              }
              lastNames.push(name);
              if (description !== void 0) {
                this.emitDescription(description);
                emitLastProperty();
              }
            });
            emitLastProperty();
          } else {
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
              const description = this.descriptionForClassProperty(c, jsonName);
              const propertyLines = this.propertyLinesDefinition(name, p);
              this.emitDescription(description);
              this.emitLine(propertyLines);
            });
          }
          if (!this._options.justTypes) {
            const groups = this.getEnumPropertyGroups(c);
            const allPropertiesRedundant = groups.every((group) => {
              return group.every((p) => p.label === void 0);
            });
            if (!allPropertiesRedundant && c.getProperties().size > 0) {
              this.ensureBlankLine();
              let enumDeclaration = this.accessLevel;
              enumDeclaration += "enum CodingKeys: String, CodingKey";
              if (this._options.codingKeysProtocol && this._options.codingKeysProtocol.length > 0) {
                enumDeclaration += ", ";
                enumDeclaration += this._options.codingKeysProtocol;
              }
              this.emitBlock(enumDeclaration, () => {
                for (const group of groups) {
                  const { name, label } = group[0];
                  if (this._options.explicitCodingKeys && label !== void 0) {
                    this.emitLine("case ", name, ' = "', label, '"');
                  } else {
                    const names = (0, collection_utils_1.arrayIntercalate)(", ", group.map((p) => p.name));
                    this.emitLine("case ", names);
                  }
                }
              });
            }
          }
          if (isClass || // Public structs need explicit initializers
          // https://github.com/quicktype/quicktype/issues/899
          this._options.accessLevel === "public") {
            this.ensureBlankLine();
            let initProperties = this.initializableProperties(c);
            let propertiesLines = [];
            for (let property of initProperties) {
              if (propertiesLines.length > 0)
                propertiesLines.push(", ");
              propertiesLines.push(property.name, ": ", this.swiftPropertyType(property.parameter));
            }
            if (this.propertyCount(c) === 0 && this._options.objcSupport) {
              this.emitBlockWithAccess(["override init()"], () => {
                return "";
              });
            } else {
              this.emitBlockWithAccess(["init(", ...propertiesLines, ")"], () => {
                for (let property of initProperties) {
                  this.emitLine("self.", property.name, " = ", property.name);
                }
              });
            }
          }
        });
        if (!this._options.justTypes) {
          if (this._options.convenienceInitializers) {
            this.ensureBlankLine();
            this.emitMark(this.sourcelikeToString(className) + " convenience initializers and mutators");
            this.ensureBlankLine();
            this.emitConvenienceInitializersExtension(c, className);
            this.ensureBlankLine();
          }
        }
        this.endFile();
      }
      initializableProperties(c) {
        const properties = [];
        this.forEachClassProperty(c, "none", (name, jsonName, parameter, position) => {
          const property = { name, jsonName, parameter, position };
          properties.push(property);
        });
        return properties;
      }
      emitNewEncoderDecoder() {
        this.emitBlock("func newJSONDecoder() -> JSONDecoder", () => {
          this.emitLine("let decoder = JSONDecoder()");
          if (!this._options.linux) {
            this.emitBlock("if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *)", () => {
              this.emitLine("decoder.dateDecodingStrategy = .iso8601");
            });
          } else {
            this.emitMultiline(`decoder.dateDecodingStrategy = .custom({ (decoder) -> Date in
    let container = try decoder.singleValueContainer()
    let dateStr = try container.decode(String.self)

    let formatter = DateFormatter()
    formatter.calendar = Calendar(identifier: .iso8601)
    formatter.locale = Locale(identifier: "en_US_POSIX")
    formatter.timeZone = TimeZone(secondsFromGMT: 0)
    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"
    if let date = formatter.date(from: dateStr) {
        return date
    }
    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
    if let date = formatter.date(from: dateStr) {
        return date
    }
    throw DecodingError.typeMismatch(Date.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Could not decode date"))
})`);
          }
          this.emitLine("return decoder");
        });
        this.ensureBlankLine();
        this.emitBlock("func newJSONEncoder() -> JSONEncoder", () => {
          this.emitLine("let encoder = JSONEncoder()");
          if (!this._options.linux) {
            this.emitBlock("if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *)", () => {
              this.emitLine("encoder.dateEncodingStrategy = .iso8601");
            });
          } else {
            this.emitMultiline(`let formatter = DateFormatter()
formatter.calendar = Calendar(identifier: .iso8601)
formatter.locale = Locale(identifier: "en_US_POSIX")
formatter.timeZone = TimeZone(secondsFromGMT: 0)
formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
encoder.dateEncodingStrategy = .formatted(formatter)`);
          }
          this.emitLine("return encoder");
        });
      }
      emitConvenienceInitializersExtension(c, className) {
        const isClass = this._options.useClasses || this.isCycleBreakerType(c);
        const convenience = isClass ? "convenience " : "";
        this.emitBlockWithAccess(["extension ", className], () => {
          if (isClass) {
            this.emitBlock("convenience init(data: Data) throws", () => {
              if (this.propertyCount(c) > 0) {
                this.emitLine("let me = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
              } else {
                this.emitLine("let _ = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
              }
              let args = [];
              this.forEachClassProperty(c, "none", (name) => {
                if (args.length > 0)
                  args.push(", ");
                args.push(name, ": ", "me.", name);
              });
              this.emitLine("self.init(", ...args, ")");
            });
          } else {
            this.emitBlock("init(data: Data) throws", () => {
              this.emitLine("self = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
            });
          }
          this.ensureBlankLine();
          this.emitBlock([convenience, "init(_ json: String, using encoding: String.Encoding = .utf8) throws"], () => {
            this.emitBlock("guard let data = json.data(using: encoding) else", () => {
              this.emitLine('throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)');
            });
            this.emitLine("try self.init(data: data)");
          });
          this.ensureBlankLine();
          this.emitBlock([convenience, "init(fromURL url: URL) throws"], () => {
            this.emitLine("try self.init(data: try Data(contentsOf: url))");
          });
          this.ensureBlankLine();
          this.emitConvenienceMutator(c, className);
          this.ensureBlankLine();
          this.emitBlock("func jsonData() throws -> Data", () => {
            this.emitLine("return try newJSONEncoder().encode(self)");
          });
          this.ensureBlankLine();
          this.emitBlock("func jsonString(encoding: String.Encoding = .utf8) throws -> String?", () => {
            this.emitLine("return String(data: try self.jsonData(), encoding: encoding)");
          });
        });
      }
      renderEnumDefinition(e, enumName) {
        this.startFile(enumName);
        this.emitLineOnce("import Foundation");
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        const protocolString = this.getProtocolString("enum", "String");
        if (this._options.justTypes) {
          this.emitBlockWithAccess(["enum ", enumName, protocolString], () => {
            this.forEachEnumCase(e, "none", (name) => {
              this.emitLine("case ", name);
            });
          });
        } else {
          this.emitBlockWithAccess(["enum ", enumName, protocolString], () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine("case ", name, ' = "', stringEscape(jsonName), '"');
            });
          });
        }
        this.endFile();
      }
      renderUnionDefinition(u, unionName) {
        this.startFile(unionName);
        this.emitLineOnce("import Foundation");
        this.ensureBlankLine();
        function sortBy(t) {
          const kind = t.kind;
          if (kind === "class")
            return kind;
          return "_" + kind;
        }
        const renderUnionCase = (t) => {
          this.emitBlock(["if let x = try? container.decode(", this.swiftType(t), ".self)"], () => {
            this.emitLine("self = .", this.nameForUnionMember(u, t), "(x)");
            this.emitLine("return");
          });
        };
        this.emitDescription(this.descriptionForType(u));
        const indirect = this.isCycleBreakerType(u) ? "indirect " : "";
        const [maybeNull, nonNulls] = (0, TypeUtils_1.removeNullFromUnion)(u, sortBy);
        this.emitBlockWithAccess([indirect, "enum ", unionName, this.getProtocolString("enum")], () => {
          this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
            this.emitLine("case ", name, "(", this.swiftType(t), ")");
          });
          if (maybeNull !== null) {
            this.emitLine("case ", this.nameForUnionMember(u, maybeNull));
          }
          if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitBlockWithAccess("init(from decoder: Decoder) throws", () => {
              this.emitLine("let container = try decoder.singleValueContainer()");
              const boolMember = u.findMember("bool");
              if (boolMember !== void 0)
                renderUnionCase(boolMember);
              const integerMember = u.findMember("integer");
              if (integerMember !== void 0)
                renderUnionCase(integerMember);
              for (const t of nonNulls) {
                if (t.kind === "bool" || t.kind === "integer")
                  continue;
                renderUnionCase(t);
              }
              if (maybeNull !== null) {
                this.emitBlock("if container.decodeNil()", () => {
                  this.emitLine("self = .", this.nameForUnionMember(u, maybeNull));
                  this.emitLine("return");
                });
              }
              this.emitDecodingError(unionName);
            });
            this.ensureBlankLine();
            this.emitBlockWithAccess("func encode(to encoder: Encoder) throws", () => {
              this.emitLine("var container = encoder.singleValueContainer()");
              this.emitLine("switch self {");
              this.forEachUnionMember(u, nonNulls, "none", null, (name, _) => {
                this.emitLine("case .", name, "(let x):");
                this.indent(() => this.emitLine("try container.encode(x)"));
              });
              if (maybeNull !== null) {
                this.emitLine("case .", this.nameForUnionMember(u, maybeNull), ":");
                this.indent(() => this.emitLine("try container.encodeNil()"));
              }
              this.emitLine("}");
            });
          }
        });
        this.endFile();
      }
      emitTopLevelMapAndArrayConvenienceInitializerExtensions(t, name) {
        let extensionSource;
        if (t instanceof Type_1.ArrayType) {
          extensionSource = ["Array where Element == ", name, ".Element"];
        } else if (t instanceof Type_1.MapType) {
          extensionSource = ["Dictionary where Key == String, Value == ", this.swiftType(t.values)];
        } else {
          return;
        }
        this.emitBlockWithAccess(["extension ", extensionSource], () => {
          this.emitBlock(["init(data: Data) throws"], () => {
            this.emitLine("self = try newJSONDecoder().decode(", name, ".self, from: data)");
          });
          this.ensureBlankLine();
          this.emitBlock("init(_ json: String, using encoding: String.Encoding = .utf8) throws", () => {
            this.emitBlock("guard let data = json.data(using: encoding) else", () => {
              this.emitLine('throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)');
            });
            this.emitLine("try self.init(data: data)");
          });
          this.ensureBlankLine();
          this.emitBlock("init(fromURL url: URL) throws", () => {
            this.emitLine("try self.init(data: try Data(contentsOf: url))");
          });
          this.ensureBlankLine();
          this.emitBlock("func jsonData() throws -> Data", () => {
            this.emitLine("return try newJSONEncoder().encode(self)");
          });
          this.ensureBlankLine();
          this.emitBlock("func jsonString(encoding: String.Encoding = .utf8) throws -> String?", () => {
            this.emitLine("return String(data: try self.jsonData(), encoding: encoding)");
          });
        });
      }
      emitDecodingError(name) {
        this.emitLine("throw DecodingError.typeMismatch(", name, '.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for ', name, '"))');
      }
      emitConvenienceMutator(c, className) {
        this.emitLine("func with(");
        this.indent(() => {
          this.forEachClassProperty(c, "none", (name, _, p, position) => {
            this.emitLine(name, ": ", this.swiftPropertyType(p), "? = nil", position !== "only" && position !== "last" ? "," : "");
          });
        });
        this.emitBlock([") -> ", className], () => {
          this.emitLine("return ", className, "(");
          this.indent(() => {
            this.forEachClassProperty(c, "none", (name, _, _p, position) => {
              this.emitLine(name, ": ", name, " ?? self.", name, position !== "only" && position !== "last" ? "," : "");
            });
          });
          this.emitLine(")");
        });
      }
      emitMark(line, horizontalLine = false) {
        this.emitLine("// MARK:", horizontalLine ? " - " : " ", line);
      }
      emitSourceStructure() {
        if (this._options.multiFileOutput === false) {
          this.renderSingleFileHeaderComments();
        }
        this.forEachNamedType("leading-and-interposing", (c, className) => this.renderClassDefinition(c, className), (e, enumName) => this.renderEnumDefinition(e, enumName), (u, unionName) => this.renderUnionDefinition(u, unionName));
        if (!this._options.justTypes) {
          this.emitSupportFunctions4();
        }
      }
      emitAlamofireExtension() {
        this.ensureBlankLine();
        this.emitBlockWithAccess("extension DataRequest", () => {
          this.emitMultiline(`fileprivate func decodableResponseSerializer<T: Decodable>() -> DataResponseSerializer<T> {
    return DataResponseSerializer { _, response, data, error in
        guard error == nil else { return .failure(error!) }
        
        guard let data = data else {
            return .failure(AFError.responseSerializationFailed(reason: .inputDataNil))
        }
        
        return Result { try newJSONDecoder().decode(T.self, from: data) }
    }
}

@discardableResult
fileprivate func responseDecodable<T: Decodable>(queue: DispatchQueue? = nil, completionHandler: @escaping (DataResponse<T>) -> Void) -> Self {
    return response(queue: queue, responseSerializer: decodableResponseSerializer(), completionHandler: completionHandler)
}`);
          this.ensureBlankLine();
          this.forEachTopLevel("leading-and-interposing", (_, name) => {
            this.emitLine("@discardableResult");
            this.emitBlock([
              "func response",
              name,
              "(queue: DispatchQueue? = nil, completionHandler: @escaping (DataResponse<",
              name,
              ">) -> Void) -> Self"
            ], () => {
              this.emitLine("return responseDecodable(queue: queue, completionHandler: completionHandler)");
            });
          });
        });
      }
    };
    exports.SwiftRenderer = SwiftRenderer;
  }
});

// node_modules/quicktype-core/dist/language/TypeScriptEffectSchema.js
var require_TypeScriptEffectSchema = __commonJS({
  "node_modules/quicktype-core/dist/language/TypeScriptEffectSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeScriptEffectSchemaRenderer = exports.TypeScriptEffectSchemaTargetLanguage = exports.typeScriptEffectSchemaOptions = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var JavaScript_1 = require_JavaScript();
    exports.typeScriptEffectSchemaOptions = {
      justSchema: new RendererOptions_1.BooleanOption("just-schema", "Schema only", false)
    };
    var TypeScriptEffectSchemaTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      getOptions() {
        return [];
      }
      constructor(displayName = "TypeScript Effect Schema", names = ["typescript-effect-schema"], extension = "ts") {
        super(displayName, names, extension);
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptEffectSchemaRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.typeScriptEffectSchemaOptions, untypedOptionValues));
      }
    };
    exports.TypeScriptEffectSchemaTargetLanguage = TypeScriptEffectSchemaTargetLanguage;
    var TypeScriptEffectSchemaRenderer = class extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this.emittedObjects = /* @__PURE__ */ new Set();
      }
      forbiddenNamesForGlobalNamespace() {
        return ["Class", "Date", "Object", "String", "Array", "JSON", "Error"];
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(Acronyms_1.AcronymStyleOptions.Camel);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, JavaScript_1.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", Strings_1.isLetterOrUnderscore);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, false));
      }
      importStatement(lhs, moduleName) {
        return ["import ", lhs, " from ", moduleName, ";"];
      }
      emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("* as S", '"@effect/schema/Schema"'));
      }
      typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        return p.isOptional ? ["S.optional(", typeMap, ")"] : typeMap;
      }
      typeMapTypeFor(t, required = true) {
        if (t.kind === "class" || t.kind === "object" || t.kind === "enum") {
          const name = this.nameForNamedType(t);
          if (this.emittedObjects.has(name)) {
            return [name];
          }
          return ["S.suspend(() => ", name, ")"];
        }
        const match = (0, TypeUtils_1.matchType)(t, (_anyType) => "S.Any", (_nullType) => "S.Null", (_boolType) => "S.Boolean", (_integerType) => "S.Number", (_doubleType) => "S.Number", (_stringType) => "S.String", (arrayType) => ["S.Array(", this.typeMapTypeFor(arrayType.items, false), ")"], (_classType) => (0, Support_1.panic)("Should already be handled."), (_mapType) => ["S.Record(S.String, ", this.typeMapTypeFor(_mapType.values, false), ")"], (_enumType) => (0, Support_1.panic)("Should already be handled."), (unionType) => {
          const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
          return ["S.Union(", ...(0, collection_utils_1.arrayIntercalate)(", ", children), ")"];
        }, (_transformedStringType) => {
          return "S.String";
        });
        if (required) {
          return [match];
        }
        return match;
      }
      emitObject(name, t) {
        this.emittedObjects.add(name);
        this.ensureBlankLine();
        this.emitLine("\nexport class ", name, " extends S.Class<", name, '>("', name, '")({');
        this.indent(() => {
          this.forEachClassProperty(t, "none", (_, jsonName, property) => {
            this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
          });
        });
        this.emitLine("}) {}");
      }
      emitEnum(e, enumName) {
        this.emittedObjects.add(enumName);
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("\nexport const ", enumName, " = ", "S.Literal(");
        this.indent(() => this.forEachEnumCase(e, "none", (_, jsonName) => {
          this.emitLine('"', (0, Strings_1.stringEscape)(jsonName), '",');
        }));
        this.emitLine(");");
        if (!this._options.justSchema) {
          this.emitLine("export type ", enumName, " = S.Schema.Type<typeof ", enumName, ">;");
        }
      }
      walkObjectNames(objectType) {
        const names = [];
        const recurse = (type) => {
          if (type.kind === "object" || type.kind === "class") {
            names.push(this.nameForNamedType(type));
            this.forEachClassProperty(type, "none", (_, __, prop) => {
              recurse(prop.type);
            });
          } else if (type instanceof Type_1.ArrayType) {
            recurse(type.items);
          } else if (type instanceof Type_1.MapType) {
            recurse(type.values);
          } else if (type instanceof Type_1.EnumType) {
            for (const t of type.getChildren()) {
              recurse(t);
            }
          }
        };
        this.forEachClassProperty(objectType, "none", (_, __, prop) => {
          recurse(prop.type);
        });
        return names;
      }
      emitSchemas() {
        this.ensureBlankLine();
        this.forEachEnum("leading-and-interposing", (u, enumName) => {
          this.emitEnum(u, enumName);
        });
        const order = [];
        const mapKey = [];
        const mapValue = [];
        this.forEachObject("none", (type, name) => {
          mapKey.push(name);
          mapValue.push(type);
        });
        mapKey.forEach((_, index) => {
          let ordinal = 0;
          const source = mapValue[index];
          const names = this.walkObjectNames(source);
          names.forEach((name) => {
            const depName = name;
            order.forEach((orderItem) => {
              const depIndex = orderItem;
              if (mapKey[depIndex] === depName) {
                ordinal = Math.max(ordinal, depIndex + 1);
              }
            });
          });
          order.splice(ordinal, 0, index);
        });
        order.forEach((i) => this.emitGatheredSource(this.gatherSource(() => this.emitObject(mapKey[i], mapValue[i]))));
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        this.emitImports();
        this.emitSchemas();
      }
    };
    exports.TypeScriptEffectSchemaRenderer = TypeScriptEffectSchemaRenderer;
  }
});

// node_modules/quicktype-core/dist/language/TypeScriptFlow.js
var require_TypeScriptFlow = __commonJS({
  "node_modules/quicktype-core/dist/language/TypeScriptFlow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FlowRenderer = exports.FlowTargetLanguage = exports.TypeScriptRenderer = exports.TypeScriptFlowBaseRenderer = exports.TypeScriptTargetLanguage = exports.TypeScriptFlowBaseTargetLanguage = exports.tsFlowOptions = void 0;
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Source_1 = require_Source();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var JavaScript_1 = require_JavaScript();
    var JavaScriptUnicodeMaps_1 = require_JavaScriptUnicodeMaps();
    exports.tsFlowOptions = Object.assign({}, JavaScript_1.javaScriptOptions, {
      justTypes: new RendererOptions_1.BooleanOption("just-types", "Interfaces only", false),
      nicePropertyNames: new RendererOptions_1.BooleanOption("nice-property-names", "Transform property names to be JavaScripty", false),
      declareUnions: new RendererOptions_1.BooleanOption("explicit-unions", "Explicitly name unions", false),
      preferUnions: new RendererOptions_1.BooleanOption("prefer-unions", "Use union type instead of enum", false),
      preferTypes: new RendererOptions_1.BooleanOption("prefer-types", "Use types instead of interfaces", false),
      preferConstValues: new RendererOptions_1.BooleanOption("prefer-const-values", "Use string instead of enum for string enums with single value", false),
      readonly: new RendererOptions_1.BooleanOption("readonly", "Use readonly type members", false)
    });
    var tsFlowTypeAnnotations = {
      any: ": any",
      anyArray: ": any[]",
      anyMap: ": { [k: string]: any }",
      string: ": string",
      stringArray: ": string[]",
      boolean: ": boolean"
    };
    var TypeScriptFlowBaseTargetLanguage = class extends JavaScript_1.JavaScriptTargetLanguage {
      getOptions() {
        return [
          exports.tsFlowOptions.justTypes,
          exports.tsFlowOptions.nicePropertyNames,
          exports.tsFlowOptions.declareUnions,
          exports.tsFlowOptions.runtimeTypecheck,
          exports.tsFlowOptions.runtimeTypecheckIgnoreUnknownProperties,
          exports.tsFlowOptions.acronymStyle,
          exports.tsFlowOptions.converters,
          exports.tsFlowOptions.rawType,
          exports.tsFlowOptions.preferUnions,
          exports.tsFlowOptions.preferTypes,
          exports.tsFlowOptions.preferConstValues,
          exports.tsFlowOptions.readonly
        ];
      }
      get supportsOptionalClassProperties() {
        return true;
      }
    };
    exports.TypeScriptFlowBaseTargetLanguage = TypeScriptFlowBaseTargetLanguage;
    var TypeScriptTargetLanguage = class extends TypeScriptFlowBaseTargetLanguage {
      constructor() {
        super("TypeScript", ["typescript", "ts", "tsx"], "ts");
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.tsFlowOptions, untypedOptionValues));
      }
    };
    exports.TypeScriptTargetLanguage = TypeScriptTargetLanguage;
    function quotePropertyName(original) {
      const escaped = (0, Strings_1.utf16StringEscape)(original);
      const quoted = `"${escaped}"`;
      if (original.length === 0) {
        return quoted;
      } else if (!(0, JavaScriptUnicodeMaps_1.isES3IdentifierStart)(original.codePointAt(0))) {
        return quoted;
      } else if (escaped !== original) {
        return quoted;
      } else if ((0, JavaScript_1.legalizeName)(original) !== original) {
        return quoted;
      } else {
        return original;
      }
    }
    var TypeScriptFlowBaseRenderer = class extends JavaScript_1.JavaScriptRenderer {
      constructor(targetLanguage, renderContext, _tsFlowOptions) {
        super(targetLanguage, renderContext, _tsFlowOptions);
        this._tsFlowOptions = _tsFlowOptions;
      }
      namerForObjectProperty() {
        if (this._tsFlowOptions.nicePropertyNames) {
          return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, false));
        } else {
          return super.namerForObjectProperty();
        }
      }
      sourceFor(t) {
        if (this._tsFlowOptions.preferConstValues && t.kind === "enum" && t instanceof Type_1.EnumType && t.cases.size === 1) {
          const item = t.cases.values().next().value;
          return (0, Source_1.singleWord)(`"${(0, Strings_1.utf16StringEscape)(item)}"`);
        }
        if (["class", "object", "enum"].includes(t.kind)) {
          return (0, Source_1.singleWord)(this.nameForNamedType(t));
        }
        return (0, TypeUtils_1.matchType)(t, (_anyType) => (0, Source_1.singleWord)("any"), (_nullType) => (0, Source_1.singleWord)("null"), (_boolType) => (0, Source_1.singleWord)("boolean"), (_integerType) => (0, Source_1.singleWord)("number"), (_doubleType) => (0, Source_1.singleWord)("number"), (_stringType) => (0, Source_1.singleWord)("string"), (arrayType) => {
          const itemType = this.sourceFor(arrayType.items);
          if (arrayType.items instanceof Type_1.UnionType && !this._tsFlowOptions.declareUnions || arrayType.items instanceof Type_1.ArrayType) {
            return (0, Source_1.singleWord)(["Array<", itemType.source, ">"]);
          } else {
            return (0, Source_1.singleWord)([(0, Source_1.parenIfNeeded)(itemType), "[]"]);
          }
        }, (_classType) => (0, Support_1.panic)("We handled this above"), (mapType) => (0, Source_1.singleWord)(["{ [key: string]: ", this.sourceFor(mapType.values).source, " }"]), (_enumType) => (0, Support_1.panic)("We handled this above"), (unionType) => {
          if (!this._tsFlowOptions.declareUnions || (0, TypeUtils_1.nullableFromUnion)(unionType) !== null) {
            const children = Array.from(unionType.getChildren()).map((c) => (0, Source_1.parenIfNeeded)(this.sourceFor(c)));
            return (0, Source_1.multiWord)(" | ", ...children);
          } else {
            return (0, Source_1.singleWord)(this.nameForNamedType(unionType));
          }
        }, (transformedStringType) => {
          if (transformedStringType.kind === "date-time") {
            return (0, Source_1.singleWord)("Date");
          }
          return (0, Source_1.singleWord)("string");
        });
      }
      emitClassBlockBody(c) {
        this.emitPropertyTable(c, (name, _jsonName, p) => {
          const t = p.type;
          let propertyName = name;
          propertyName = (0, Source_1.modifySource)(quotePropertyName, name);
          if (this._tsFlowOptions.readonly) {
            propertyName = (0, Source_1.modifySource)((_propertyName) => "readonly " + _propertyName, propertyName);
          }
          return [
            [propertyName, p.isOptional ? "?" : "", ": "],
            [this.sourceFor(t).source, ";"]
          ];
        });
        const additionalProperties = c.getAdditionalProperties();
        if (additionalProperties) {
          this.emitTable([["[property: string]", ": ", this.sourceFor(additionalProperties).source, ";"]]);
        }
      }
      emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitClassBlock(c, className);
      }
      emitUnion(u, unionName) {
        if (!this._tsFlowOptions.declareUnions) {
          return;
        }
        this.emitDescription(this.descriptionForType(u));
        const children = (0, Source_1.multiWord)(" | ", ...Array.from(u.getChildren()).map((c) => (0, Source_1.parenIfNeeded)(this.sourceFor(c))));
        this.emitLine("export type ", unionName, " = ", children.source, ";");
      }
      emitTypes() {
        this.forEachTopLevel("none", (t, name) => {
          if (!t.isPrimitive()) {
            return;
          }
          this.ensureBlankLine();
          this.emitDescription(this.descriptionForType(t));
          this.emitLine("type ", name, " = ", this.sourceFor(t).source, ";");
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClass(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
      }
      emitUsageComments() {
        if (this._tsFlowOptions.justTypes)
          return;
        super.emitUsageComments();
      }
      deserializerFunctionLine(t, name) {
        const jsonType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["function to", name, "(json: ", jsonType, "): ", this.sourceFor(t).source];
      }
      serializerFunctionLine(t, name) {
        const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
        const returnType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["function ", camelCaseName, "ToJson(value: ", this.sourceFor(t).source, "): ", returnType];
      }
      get moduleLine() {
        return void 0;
      }
      get castFunctionLines() {
        return ["function cast<T>(val: any, typ: any): T", "function uncast<T>(val: T, typ: any): any"];
      }
      get typeAnnotations() {
        throw new Error("not implemented");
      }
      emitConvertModule() {
        if (this._tsFlowOptions.justTypes)
          return;
        super.emitConvertModule();
      }
      emitConvertModuleHelpers() {
        if (this._tsFlowOptions.justTypes)
          return;
        super.emitConvertModuleHelpers();
      }
      emitModuleExports() {
        if (this._tsFlowOptions.justTypes) {
          return;
        } else {
          super.emitModuleExports();
        }
      }
    };
    exports.TypeScriptFlowBaseRenderer = TypeScriptFlowBaseRenderer;
    var TypeScriptRenderer = class extends TypeScriptFlowBaseRenderer {
      forbiddenNamesForGlobalNamespace() {
        return ["Array", "Date"];
      }
      deserializerFunctionLine(t, name) {
        const jsonType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["public static to", name, "(json: ", jsonType, "): ", this.sourceFor(t).source];
      }
      serializerFunctionLine(t, name) {
        const camelCaseName = (0, Source_1.modifySource)(Strings_1.camelCase, name);
        const returnType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["public static ", camelCaseName, "ToJson(value: ", this.sourceFor(t).source, "): ", returnType];
      }
      get moduleLine() {
        return "export class Convert";
      }
      get typeAnnotations() {
        return Object.assign({ never: ": never" }, tsFlowTypeAnnotations);
      }
      emitModuleExports() {
        return;
      }
      emitUsageImportComment() {
        const topLevelNames = [];
        this.forEachTopLevel("none", (_t, name) => {
          topLevelNames.push(", ", name);
        }, TypeUtils_1.isNamedType);
        this.emitLine("//   import { Convert", topLevelNames, ' } from "./file";');
      }
      emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        if (this._tsFlowOptions.preferConstValues && e.cases.size === 1)
          return;
        if (this._tsFlowOptions.preferUnions) {
          let items = "";
          e.cases.forEach((item) => {
            if (items === "") {
              items += `"${(0, Strings_1.utf16StringEscape)(item)}"`;
              return;
            }
            items += ` | "${(0, Strings_1.utf16StringEscape)(item)}"`;
          });
          this.emitLine("export type ", enumName, " = ", items, ";");
        } else {
          this.emitBlock(["export enum ", enumName, " "], "", () => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
              this.emitLine(name, ` = "${(0, Strings_1.utf16StringEscape)(jsonName)}",`);
            });
          });
        }
      }
      emitClassBlock(c, className) {
        this.emitBlock(this._tsFlowOptions.preferTypes ? ["export type ", className, " = "] : ["export interface ", className, " "], "", () => {
          this.emitClassBlockBody(c);
        });
      }
      emitSourceStructure() {
        super.emitSourceStructure();
      }
    };
    exports.TypeScriptRenderer = TypeScriptRenderer;
    var FlowTargetLanguage = class extends TypeScriptFlowBaseTargetLanguage {
      constructor() {
        super("Flow", ["flow"], "js");
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new FlowRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.tsFlowOptions, untypedOptionValues));
      }
    };
    exports.FlowTargetLanguage = FlowTargetLanguage;
    var FlowRenderer = class extends TypeScriptFlowBaseRenderer {
      forbiddenNamesForGlobalNamespace() {
        return ["Class", "Date", "Object", "String", "Array", "JSON", "Error"];
      }
      get typeAnnotations() {
        return Object.assign({ never: "" }, tsFlowTypeAnnotations);
      }
      emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        const lines = [];
        this.forEachEnumCase(e, "none", (_, jsonName) => {
          const maybeOr = lines.length === 0 ? "  " : "| ";
          lines.push([maybeOr, '"', (0, Strings_1.utf16StringEscape)(jsonName), '"']);
        });
        (0, Support_1.defined)(lines[lines.length - 1]).push(";");
        this.emitLine("export type ", enumName, " =");
        this.indent(() => {
          for (const line of lines) {
            this.emitLine(line);
          }
        });
      }
      emitClassBlock(c, className) {
        this.emitBlock(["export type ", className, " = "], ";", () => {
          this.emitClassBlockBody(c);
        });
      }
      emitSourceStructure() {
        this.emitLine("// @flow");
        this.ensureBlankLine();
        super.emitSourceStructure();
      }
    };
    exports.FlowRenderer = FlowRenderer;
  }
});

// node_modules/quicktype-core/dist/language/TypeScriptZod.js
var require_TypeScriptZod = __commonJS({
  "node_modules/quicktype-core/dist/language/TypeScriptZod.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeScriptZodRenderer = exports.TypeScriptZodTargetLanguage = exports.typeScriptZodOptions = void 0;
    var collection_utils_1 = require_dist();
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    var Naming_1 = require_Naming();
    var RendererOptions_1 = require_RendererOptions();
    var Acronyms_1 = require_Acronyms();
    var Strings_1 = require_Strings();
    var Support_1 = require_Support();
    var TargetLanguage_1 = require_TargetLanguage();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var JavaScript_1 = require_JavaScript();
    exports.typeScriptZodOptions = {
      justSchema: new RendererOptions_1.BooleanOption("just-schema", "Schema only", false)
    };
    var TypeScriptZodTargetLanguage = class extends TargetLanguage_1.TargetLanguage {
      getOptions() {
        return [];
      }
      constructor(displayName = "TypeScript Zod", names = ["typescript-zod"], extension = "ts") {
        super(displayName, names, extension);
      }
      get stringTypeMapping() {
        const mapping = /* @__PURE__ */ new Map();
        const dateTimeType = "date-time";
        mapping.set("date-time", dateTimeType);
        return mapping;
      }
      get supportsOptionalClassProperties() {
        return true;
      }
      makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptZodRenderer(this, renderContext, (0, RendererOptions_1.getOptionValues)(exports.typeScriptZodOptions, untypedOptionValues));
      }
    };
    exports.TypeScriptZodTargetLanguage = TypeScriptZodTargetLanguage;
    var TypeScriptZodRenderer = class _TypeScriptZodRenderer extends ConvenienceRenderer_1.ConvenienceRenderer {
      constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
      }
      forbiddenNamesForGlobalNamespace() {
        return ["Class", "Date", "Object", "String", "Array", "JSON", "Error"];
      }
      nameStyle(original, upper) {
        const acronyms = (0, Acronyms_1.acronymStyle)(Acronyms_1.AcronymStyleOptions.Camel);
        const words = (0, Strings_1.splitIntoWords)(original);
        return (0, Strings_1.combineWords)(words, JavaScript_1.legalizeName, upper ? Strings_1.firstUpperWordStyle : Strings_1.allLowerWordStyle, Strings_1.firstUpperWordStyle, upper ? (s) => (0, Strings_1.capitalize)(acronyms(s)) : Strings_1.allLowerWordStyle, acronyms, "", Strings_1.isLetterOrUnderscore);
      }
      makeNamedTypeNamer() {
        return (0, Naming_1.funPrefixNamer)("types", (s) => this.nameStyle(s, true));
      }
      makeUnionMemberNamer() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      namerForObjectProperty() {
        return (0, Naming_1.funPrefixNamer)("properties", (s) => this.nameStyle(s, true));
      }
      makeEnumCaseNamer() {
        return (0, Naming_1.funPrefixNamer)("enum-cases", (s) => this.nameStyle(s, false));
      }
      importStatement(lhs, moduleName) {
        return ["import ", lhs, " from ", moduleName, ";"];
      }
      emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("* as z", '"zod"'));
      }
      typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        return p.isOptional ? [typeMap, ".optional()"] : typeMap;
      }
      typeMapTypeFor(t, required = true) {
        if (["class", "object", "enum"].includes(t.kind)) {
          return [this.nameForNamedType(t), "Schema"];
        }
        const match = (0, TypeUtils_1.matchType)(t, (_anyType) => "z.any()", (_nullType) => "z.null()", (_boolType) => "z.boolean()", (_integerType) => "z.number()", (_doubleType) => "z.number()", (_stringType) => "z.string()", (arrayType) => ["z.array(", this.typeMapTypeFor(arrayType.items, false), ")"], (_classType) => (0, Support_1.panic)("Should already be handled."), (_mapType) => ["z.record(z.string(), ", this.typeMapTypeFor(_mapType.values, false), ")"], (_enumType) => (0, Support_1.panic)("Should already be handled."), (unionType) => {
          const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
          return ["z.union([", ...(0, collection_utils_1.arrayIntercalate)(", ", children), "])"];
        }, (_transformedStringType) => {
          if (_transformedStringType.kind === "date-time") {
            return "z.coerce.date()";
          }
          return "z.string()";
        });
        if (required) {
          return [match];
        }
        return match;
      }
      emitObject(name, t) {
        this.ensureBlankLine();
        this.emitLine("\nexport const ", name, "Schema = ", "z.object({");
        this.indent(() => {
          this.forEachClassProperty(t, "none", (_, jsonName, property) => {
            this.emitLine(`"${(0, Strings_1.utf16StringEscape)(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
          });
        });
        this.emitLine("});");
        if (!this._options.justSchema) {
          this.emitLine("export type ", name, " = z.infer<typeof ", name, "Schema>;");
        }
      }
      emitEnum(e, enumName) {
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("\nexport const ", enumName, "Schema = ", "z.enum([");
        this.indent(() => this.forEachEnumCase(e, "none", (_, jsonName) => {
          this.emitLine('"', (0, Strings_1.stringEscape)(jsonName), '",');
        }));
        this.emitLine("]);");
        if (!this._options.justSchema) {
          this.emitLine("export type ", enumName, " = z.infer<typeof ", enumName, "Schema>;");
        }
      }
      /** Static function that extracts underlying type refs for types that form part of the
       * definition of the passed type - used to ensure that these appear in generated source
       * before types that reference them.
       *
       * Primitive types don't need defining and enums are output before other types, hence,
       * these are ignored.
       */
      static extractUnderlyingTyperefs(type) {
        let typeRefs = [];
        if (!type.isPrimitive() && type.kind != "enum") {
          if (type instanceof Type_1.SetOperationType) {
            type.members.forEach((member) => {
              typeRefs.push(..._TypeScriptZodRenderer.extractUnderlyingTyperefs(member));
            });
          }
          if (type instanceof Type_1.ObjectType) {
            const addType = type.getAdditionalProperties();
            if (addType) {
              typeRefs.push(..._TypeScriptZodRenderer.extractUnderlyingTyperefs(addType));
            }
          }
          if (type instanceof Type_1.ArrayType) {
            const itemsType = type.items;
            if (itemsType) {
              typeRefs.push(..._TypeScriptZodRenderer.extractUnderlyingTyperefs(itemsType));
            }
          }
          if (type instanceof Type_1.ClassType) {
            typeRefs.push(type.typeRef);
          }
        }
        return typeRefs;
      }
      emitSchemas() {
        this.ensureBlankLine();
        this.forEachEnum("leading-and-interposing", (u, enumName) => {
          this.emitEnum(u, enumName);
        });
        const order = [];
        const mapType = [];
        const mapTypeRef = [];
        const mapName = [];
        const mapChildTypeRefs = [];
        this.forEachObject("none", (type, name) => {
          mapType.push(type);
          mapTypeRef.push(type.typeRef);
          mapName.push(name);
          const children = type.getChildren();
          let childTypeRefs = [];
          children.forEach((child) => {
            childTypeRefs = childTypeRefs.concat(_TypeScriptZodRenderer.extractUnderlyingTyperefs(child));
          });
          mapChildTypeRefs.push(childTypeRefs);
        });
        let indices = [];
        mapType.forEach((_, index) => {
          indices.push(index);
        });
        let deferredIndices = [];
        const MAX_PASSES = 999;
        let passNum = 0;
        do {
          indices.forEach((index) => {
            const childTypeRefs = mapChildTypeRefs[index];
            let foundAllChildren = true;
            childTypeRefs.forEach((childRef) => {
              if (mapTypeRef.includes(childRef)) {
                let found = false;
                for (let j = 0; j < order.length; j++) {
                  const childIndex = order[j];
                  if (mapTypeRef[childIndex] === childRef) {
                    found = true;
                    break;
                  }
                }
                foundAllChildren = foundAllChildren && found;
              } else {
                console.error("A child type reference was not found amongst all Object definitions! TypeRef: " + childRef);
              }
            });
            if (foundAllChildren) {
              order.push(index);
            } else {
              deferredIndices.push(index);
            }
          });
          indices = deferredIndices;
          deferredIndices = [];
          passNum++;
          if (passNum > MAX_PASSES) {
            order.push(...deferredIndices);
            console.warn("Exceeded maximum number of passes when determining output order, output may contain forward references");
          }
        } while (indices.length > 0 && passNum <= MAX_PASSES);
        order.forEach((i) => this.emitGatheredSource(this.gatherSource(() => this.emitObject(mapName[i], mapType[i]))));
      }
      emitSourceStructure() {
        if (this.leadingComments !== void 0) {
          this.emitComments(this.leadingComments);
        }
        this.emitImports();
        this.emitSchemas();
      }
    };
    exports.TypeScriptZodRenderer = TypeScriptZodRenderer;
  }
});

// node_modules/quicktype-core/dist/language/All.js
var require_All = __commonJS({
  "node_modules/quicktype-core/dist/language/All.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.languageNamed = exports.all = void 0;
    var collection_utils_1 = require_dist();
    var CJSON_1 = require_CJSON();
    var CPlusPlus_1 = require_CPlusPlus();
    var Crystal_1 = require_Crystal();
    var CSharp_1 = require_CSharp();
    var Dart_1 = require_Dart();
    var Elixir_1 = require_Elixir();
    var Elm_1 = require_Elm();
    var Golang_1 = require_Golang();
    var Haskell_1 = require_Haskell();
    var Java_1 = require_Java();
    var JavaScript_1 = require_JavaScript();
    var JavaScriptPropTypes_1 = require_JavaScriptPropTypes();
    var JSONSchema_1 = require_JSONSchema();
    var Kotlin_1 = require_Kotlin();
    var Objective_C_1 = require_Objective_C();
    var Php_1 = require_Php();
    var Pike_1 = require_Pike();
    var Python_1 = require_Python();
    var ruby_1 = require_ruby();
    var Rust_1 = require_Rust();
    var Scala3_1 = require_Scala3();
    var Smithy4s_1 = require_Smithy4s();
    var Swift_1 = require_Swift();
    var TypeScriptEffectSchema_1 = require_TypeScriptEffectSchema();
    var TypeScriptFlow_1 = require_TypeScriptFlow();
    var TypeScriptZod_1 = require_TypeScriptZod();
    exports.all = [
      new CSharp_1.CSharpTargetLanguage(),
      new Golang_1.GoTargetLanguage(),
      new Rust_1.RustTargetLanguage(),
      new Crystal_1.CrystalTargetLanguage(),
      new CJSON_1.CJSONTargetLanguage(),
      new CPlusPlus_1.CPlusPlusTargetLanguage(),
      new Objective_C_1.ObjectiveCTargetLanguage(),
      new Java_1.JavaTargetLanguage(),
      new TypeScriptFlow_1.TypeScriptTargetLanguage(),
      new JavaScript_1.JavaScriptTargetLanguage(),
      new JavaScriptPropTypes_1.JavaScriptPropTypesTargetLanguage(),
      new TypeScriptFlow_1.FlowTargetLanguage(),
      new Swift_1.SwiftTargetLanguage(),
      new Scala3_1.Scala3TargetLanguage(),
      new Smithy4s_1.SmithyTargetLanguage(),
      new Kotlin_1.KotlinTargetLanguage(),
      new Elm_1.ElmTargetLanguage(),
      new JSONSchema_1.JSONSchemaTargetLanguage(),
      new ruby_1.RubyTargetLanguage(),
      new Dart_1.DartTargetLanguage(),
      new Python_1.PythonTargetLanguage("Python", ["python", "py"], "py"),
      new Pike_1.PikeTargetLanguage(),
      new Haskell_1.HaskellTargetLanguage(),
      new TypeScriptZod_1.TypeScriptZodTargetLanguage(),
      new TypeScriptEffectSchema_1.TypeScriptEffectSchemaTargetLanguage(),
      new Elixir_1.ElixirTargetLanguage(),
      new Php_1.PhpTargetLanguage()
    ];
    function languageNamed(name, targetLanguages) {
      if (targetLanguages === void 0) {
        targetLanguages = exports.all;
      }
      const maybeTargetLanguage = (0, collection_utils_1.iterableFind)(targetLanguages, (l) => l.names.includes(name) || l.displayName === name);
      if (maybeTargetLanguage !== void 0)
        return maybeTargetLanguage;
      return (0, collection_utils_1.iterableFind)(targetLanguages, (l) => l.extension === name);
    }
    exports.languageNamed = languageNamed;
  }
});

// node_modules/quicktype-core/dist/input/CompressedJSON.js
var require_CompressedJSON = __commonJS({
  "node_modules/quicktype-core/dist/input/CompressedJSON.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressedJSONFromString = exports.CompressedJSON = exports.valueTag = exports.makeValue = exports.Tag = void 0;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var Tag;
    (function(Tag2) {
      Tag2[Tag2["Null"] = 1] = "Null";
      Tag2[Tag2["False"] = 2] = "False";
      Tag2[Tag2["True"] = 3] = "True";
      Tag2[Tag2["Integer"] = 4] = "Integer";
      Tag2[Tag2["Double"] = 5] = "Double";
      Tag2[Tag2["InternedString"] = 6] = "InternedString";
      Tag2[Tag2["UninternedString"] = 7] = "UninternedString";
      Tag2[Tag2["Object"] = 8] = "Object";
      Tag2[Tag2["Array"] = 9] = "Array";
      Tag2[Tag2["StringFormat"] = 10] = "StringFormat";
      Tag2[Tag2["TransformedString"] = 11] = "TransformedString";
    })(Tag = exports.Tag || (exports.Tag = {}));
    var TAG_BITS = 4;
    var TAG_MASK = (1 << TAG_BITS) - 1;
    function makeValue(t, index) {
      return t | index << TAG_BITS;
    }
    exports.makeValue = makeValue;
    function getIndex(v, tag) {
      (0, Support_1.assert)(valueTag(v) === tag, "Trying to get index for value with invalid tag");
      return v >> TAG_BITS;
    }
    function valueTag(v) {
      return v & TAG_MASK;
    }
    exports.valueTag = valueTag;
    var CompressedJSON = class {
      constructor(dateTimeRecognizer, handleRefs) {
        this.dateTimeRecognizer = dateTimeRecognizer;
        this.handleRefs = handleRefs;
        this._contextStack = [];
        this._strings = [];
        this._stringIndexes = {};
        this._objects = [];
        this._arrays = [];
        this.getObjectForValue = (v) => {
          return this._objects[getIndex(v, Tag.Object)];
        };
        this.getArrayForValue = (v) => {
          return this._arrays[getIndex(v, Tag.Array)];
        };
        this.internArray = (arr) => {
          const index = this._arrays.length;
          this._arrays.push(arr);
          return makeValue(Tag.Array, index);
        };
      }
      parseSync(_input) {
        return (0, Support_1.panic)("parseSync not implemented in CompressedJSON");
      }
      getStringForValue(v) {
        const tag = valueTag(v);
        (0, Support_1.assert)(tag === Tag.InternedString || tag === Tag.TransformedString);
        return this._strings[getIndex(v, tag)];
      }
      getStringFormatTypeKind(v) {
        const kind = this._strings[getIndex(v, Tag.StringFormat)];
        if (!(0, Type_1.isPrimitiveStringTypeKind)(kind) || kind === "string") {
          return (0, Support_1.panic)("Not a transformed string type kind");
        }
        return kind;
      }
      get context() {
        return (0, Support_1.defined)(this._ctx);
      }
      internString(s) {
        if (Object.prototype.hasOwnProperty.call(this._stringIndexes, s)) {
          return this._stringIndexes[s];
        }
        const index = this._strings.length;
        this._strings.push(s);
        this._stringIndexes[s] = index;
        return index;
      }
      makeString(s) {
        const value = makeValue(Tag.InternedString, this.internString(s));
        (0, Support_1.assert)(typeof value === "number", `Interned string value is not a number: ${value}`);
        return value;
      }
      internObject(obj) {
        const index = this._objects.length;
        this._objects.push(obj);
        return makeValue(Tag.Object, index);
      }
      get isExpectingRef() {
        return this._ctx !== void 0 && this._ctx.currentKey === "$ref";
      }
      commitValue(value) {
        (0, Support_1.assert)(typeof value === "number", `CompressedJSON value is not a number: ${value}`);
        if (this._ctx === void 0) {
          (0, Support_1.assert)(this._rootValue === void 0, "Committing value but nowhere to commit to - root value still there.");
          this._rootValue = value;
        } else if (this._ctx.currentObject !== void 0) {
          if (this._ctx.currentKey === void 0) {
            return (0, Support_1.panic)("Must have key and can't have string when committing");
          }
          this._ctx.currentObject.push(this.makeString(this._ctx.currentKey), value);
          this._ctx.currentKey = void 0;
        } else if (this._ctx.currentArray !== void 0) {
          this._ctx.currentArray.push(value);
        } else {
          return (0, Support_1.panic)("Committing value but nowhere to commit to");
        }
      }
      commitNull() {
        this.commitValue(makeValue(Tag.Null, 0));
      }
      commitBoolean(v) {
        this.commitValue(makeValue(v ? Tag.True : Tag.False, 0));
      }
      commitNumber(isDouble) {
        const numberTag = isDouble ? Tag.Double : Tag.Integer;
        this.commitValue(makeValue(numberTag, 0));
      }
      commitString(s) {
        let value = void 0;
        if (this.handleRefs && this.isExpectingRef) {
          value = this.makeString(s);
        } else {
          const format = (0, StringTypes_1.inferTransformedStringTypeKindForString)(s, this.dateTimeRecognizer);
          if (format !== void 0) {
            if ((0, Support_1.defined)(Type_1.transformedStringTypeTargetTypeKindsMap.get(format)).attributesProducer !== void 0) {
              value = makeValue(Tag.TransformedString, this.internString(s));
            } else {
              value = makeValue(Tag.StringFormat, this.internString(format));
            }
          } else if (s.length <= 64) {
            value = this.makeString(s);
          } else {
            value = makeValue(Tag.UninternedString, 0);
          }
        }
        this.commitValue(value);
      }
      finish() {
        const value = this._rootValue;
        if (value === void 0) {
          return (0, Support_1.panic)("Finished without root document");
        }
        (0, Support_1.assert)(this._ctx === void 0 && this._contextStack.length === 0, "Finished with contexts present");
        this._rootValue = void 0;
        return value;
      }
      pushContext() {
        if (this._ctx !== void 0) {
          this._contextStack.push(this._ctx);
        }
        this._ctx = {
          currentObject: void 0,
          currentArray: void 0,
          currentKey: void 0,
          currentNumberIsDouble: false
        };
      }
      pushObjectContext() {
        this.pushContext();
        (0, Support_1.defined)(this._ctx).currentObject = [];
      }
      setPropertyKey(key) {
        const ctx = this.context;
        ctx.currentKey = key;
      }
      finishObject() {
        const obj = this.context.currentObject;
        if (obj === void 0) {
          return (0, Support_1.panic)("Object ended but not started");
        }
        this.popContext();
        this.commitValue(this.internObject(obj));
      }
      pushArrayContext() {
        this.pushContext();
        (0, Support_1.defined)(this._ctx).currentArray = [];
      }
      finishArray() {
        const arr = this.context.currentArray;
        if (arr === void 0) {
          return (0, Support_1.panic)("Array ended but not started");
        }
        this.popContext();
        this.commitValue(this.internArray(arr));
      }
      popContext() {
        (0, Support_1.assert)(this._ctx !== void 0, "Popping context when there isn't one");
        this._ctx = this._contextStack.pop();
      }
      equals(other) {
        return this === other;
      }
      hashCode() {
        let hashAccumulator = collection_utils_1.hashCodeInit;
        for (const s of this._strings) {
          hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, (0, collection_utils_1.hashString)(s));
        }
        for (const s of Object.getOwnPropertyNames(this._stringIndexes).sort()) {
          hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, (0, collection_utils_1.hashString)(s));
          hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, this._stringIndexes[s]);
        }
        for (const o of this._objects) {
          for (const v of o) {
            hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, v);
          }
        }
        for (const o of this._arrays) {
          for (const v of o) {
            hashAccumulator = (0, collection_utils_1.addHashCode)(hashAccumulator, v);
          }
        }
        return hashAccumulator;
      }
    };
    exports.CompressedJSON = CompressedJSON;
    var CompressedJSONFromString = class extends CompressedJSON {
      parse(input) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.parseSync(input);
        });
      }
      parseSync(input) {
        const json = JSON.parse(input);
        this.process(json);
        return this.finish();
      }
      process(json) {
        if (json === null) {
          this.commitNull();
        } else if (typeof json === "boolean") {
          this.commitBoolean(json);
        } else if (typeof json === "string") {
          this.commitString(json);
        } else if (typeof json === "number") {
          const isDouble = json !== Math.floor(json) || json < Number.MIN_SAFE_INTEGER || json > Number.MAX_SAFE_INTEGER;
          this.commitNumber(isDouble);
        } else if (Array.isArray(json)) {
          this.pushArrayContext();
          for (const v of json) {
            this.process(v);
          }
          this.finishArray();
        } else if (typeof json === "object") {
          this.pushObjectContext();
          for (const key of Object.getOwnPropertyNames(json)) {
            this.setPropertyKey(key);
            this.process(json[key]);
          }
          this.finishObject();
        } else {
          return (0, Support_1.panic)("Invalid JSON object");
        }
      }
    };
    exports.CompressedJSONFromString = CompressedJSONFromString;
  }
});

// node_modules/quicktype-core/dist/UnionBuilder.js
var require_UnionBuilder = __commonJS({
  "node_modules/quicktype-core/dist/UnionBuilder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnionBuilder = exports.TypeRefUnionAccumulator = exports.UnionAccumulator = void 0;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    function addAttributes(accumulatorAttributes, newAttributes) {
      if (accumulatorAttributes === void 0)
        return newAttributes;
      return (0, TypeAttributes_1.combineTypeAttributes)("union", accumulatorAttributes, newAttributes);
    }
    function setAttributes(attributeMap, kind, newAttributes) {
      attributeMap.set(kind, addAttributes(attributeMap.get(kind), newAttributes));
    }
    function addAttributesToBuilder(builder, kind, newAttributes) {
      let arr = builder.get(kind);
      if (arr === void 0) {
        arr = [];
        builder.set(kind, arr);
      }
      arr.push(newAttributes);
    }
    function buildTypeAttributeMap(builder) {
      return (0, collection_utils_1.mapMap)(builder, (arr) => (0, TypeAttributes_1.combineTypeAttributes)("union", arr));
    }
    function moveAttributes(map2, fromKind, toKind) {
      const fromAttributes = (0, Support_1.defined)(map2.get(fromKind));
      map2.delete(fromKind);
      setAttributes(map2, toKind, fromAttributes);
    }
    var UnionAccumulator = class {
      constructor(_conflateNumbers) {
        this._conflateNumbers = _conflateNumbers;
        this._nonStringTypeAttributes = /* @__PURE__ */ new Map();
        this._stringTypeAttributes = /* @__PURE__ */ new Map();
        this.arrayData = [];
        this.objectData = [];
        this._enumCases = /* @__PURE__ */ new Set();
        this._lostTypeAttributes = false;
      }
      have(kind) {
        return this._nonStringTypeAttributes.has(kind) || this._stringTypeAttributes.has(kind);
      }
      addNone(_attributes) {
        this._lostTypeAttributes = true;
      }
      addAny(attributes) {
        addAttributesToBuilder(this._nonStringTypeAttributes, "any", attributes);
        this._lostTypeAttributes = true;
      }
      addPrimitive(kind, attributes) {
        (0, Support_1.assert)(kind !== "any", "any must be added with addAny");
        addAttributesToBuilder(this._nonStringTypeAttributes, kind, attributes);
      }
      addFullStringType(attributes, stringTypes) {
        let stringTypesAttributes = void 0;
        if (stringTypes === void 0) {
          stringTypes = StringTypes_1.stringTypesTypeAttributeKind.tryGetInAttributes(attributes);
        } else {
          stringTypesAttributes = StringTypes_1.stringTypesTypeAttributeKind.makeAttributes(stringTypes);
        }
        if (stringTypes === void 0) {
          stringTypes = StringTypes_1.StringTypes.unrestricted;
          stringTypesAttributes = StringTypes_1.stringTypesTypeAttributeKind.makeAttributes(stringTypes);
        }
        const maybeEnumAttributes = this._nonStringTypeAttributes.get("enum");
        if (stringTypes.isRestricted) {
          (0, Support_1.assert)(maybeEnumAttributes === void 0, "We can't add both an enum as well as a restricted string type to a union builder");
        }
        addAttributesToBuilder(this._stringTypeAttributes, "string", attributes);
        if (stringTypesAttributes !== void 0) {
          addAttributesToBuilder(this._stringTypeAttributes, "string", stringTypesAttributes);
        }
      }
      addStringType(kind, attributes, stringTypes) {
        if (kind === "string") {
          this.addFullStringType(attributes, stringTypes);
          return;
        }
        addAttributesToBuilder(this._stringTypeAttributes, kind, attributes);
        if (stringTypes !== void 0) {
          addAttributesToBuilder(this._stringTypeAttributes, kind, StringTypes_1.stringTypesTypeAttributeKind.makeAttributes(stringTypes));
        }
      }
      addArray(t, attributes) {
        this.arrayData.push(t);
        addAttributesToBuilder(this._nonStringTypeAttributes, "array", attributes);
      }
      addObject(t, attributes) {
        this.objectData.push(t);
        addAttributesToBuilder(this._nonStringTypeAttributes, "object", attributes);
      }
      addEnum(cases, attributes) {
        const maybeStringAttributes = this._stringTypeAttributes.get("string");
        if (maybeStringAttributes !== void 0) {
          addAttributesToBuilder(this._stringTypeAttributes, "string", attributes);
          return;
        }
        addAttributesToBuilder(this._nonStringTypeAttributes, "enum", attributes);
        (0, collection_utils_1.setUnionInto)(this._enumCases, cases);
      }
      addStringCases(cases, attributes) {
        this.addFullStringType(attributes, StringTypes_1.StringTypes.fromCases(cases));
      }
      addStringCase(s, count, attributes) {
        this.addFullStringType(attributes, StringTypes_1.StringTypes.fromCase(s, count));
      }
      get enumCases() {
        return this._enumCases;
      }
      getMemberKinds() {
        (0, Support_1.assert)(!(this.have("enum") && this.have("string")), "We can't have both strings and enums in the same union");
        let merged = (0, collection_utils_1.mapMerge)(buildTypeAttributeMap(this._nonStringTypeAttributes), buildTypeAttributeMap(this._stringTypeAttributes));
        if (merged.size === 0) {
          return /* @__PURE__ */ new Map([["none", TypeAttributes_1.emptyTypeAttributes]]);
        }
        if (this._nonStringTypeAttributes.has("any")) {
          (0, Support_1.assert)(this._lostTypeAttributes, "This had to be set when we added 'any'");
          const allAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", Array.from(merged.values()));
          return /* @__PURE__ */ new Map([["any", allAttributes]]);
        }
        if (this._conflateNumbers && this.have("integer") && this.have("double")) {
          moveAttributes(merged, "integer", "double");
        }
        if (this.have("map")) {
          moveAttributes(merged, "map", "class");
        }
        return merged;
      }
      get lostTypeAttributes() {
        return this._lostTypeAttributes;
      }
    };
    exports.UnionAccumulator = UnionAccumulator;
    var FauxUnion = class {
      getAttributes() {
        return TypeAttributes_1.emptyTypeAttributes;
      }
    };
    function attributesForTypes(types) {
      const unionsForType = /* @__PURE__ */ new Map();
      const typesForUnion = /* @__PURE__ */ new Map();
      const unions = /* @__PURE__ */ new Set();
      let unionsEquivalentToRoot = /* @__PURE__ */ new Set();
      function traverse(t, path, isEquivalentToRoot) {
        if (t instanceof Type_1.UnionType) {
          unions.add(t);
          if (isEquivalentToRoot) {
            unionsEquivalentToRoot = unionsEquivalentToRoot.add(t);
          }
          isEquivalentToRoot = isEquivalentToRoot && t.members.size === 1;
          path.push(t);
          for (const m of t.members) {
            traverse(m, path, isEquivalentToRoot);
          }
          path.pop();
        } else {
          (0, collection_utils_1.mapUpdateInto)(unionsForType, t, (s) => s === void 0 ? new Set(path) : (0, collection_utils_1.setUnionInto)(s, path));
          for (const u of path) {
            (0, collection_utils_1.mapUpdateInto)(typesForUnion, u, (s) => s === void 0 ? /* @__PURE__ */ new Set([t]) : s.add(t));
          }
        }
      }
      const rootPath = [new FauxUnion()];
      const typesArray = Array.from(types);
      for (const t of typesArray) {
        traverse(t, rootPath, typesArray.length === 1);
      }
      const resultAttributes = (0, collection_utils_1.mapMap)(unionsForType, (unionForType, t) => {
        const singleAncestors = Array.from(unionForType).filter((u) => (0, Support_1.defined)(typesForUnion.get(u)).size === 1);
        (0, Support_1.assert)(singleAncestors.every((u) => (0, Support_1.defined)(typesForUnion.get(u)).has(t)), "We messed up bookkeeping");
        const inheritedAttributes = singleAncestors.map((u) => u.getAttributes());
        return (0, TypeAttributes_1.combineTypeAttributes)("union", [t.getAttributes()].concat(inheritedAttributes));
      });
      const unionAttributes = Array.from(unions).map((u) => {
        const t = typesForUnion.get(u);
        if (t !== void 0 && t.size === 1) {
          return TypeAttributes_1.emptyTypeAttributes;
        }
        const attributes = u.getAttributes();
        if (unionsEquivalentToRoot.has(u)) {
          return attributes;
        }
        return (0, TypeAttributes_1.makeTypeAttributesInferred)(attributes);
      });
      return [resultAttributes, (0, TypeAttributes_1.combineTypeAttributes)("union", unionAttributes)];
    }
    var TypeRefUnionAccumulator = class extends UnionAccumulator {
      // There is a method analogous to this in the IntersectionAccumulator.  It might
      // make sense to find a common interface.
      addType(t, attributes) {
        (0, TypeUtils_1.matchTypeExhaustive)(
          t,
          (_noneType) => this.addNone(attributes),
          (_anyType) => this.addAny(attributes),
          (_nullType) => this.addPrimitive("null", attributes),
          (_boolType) => this.addPrimitive("bool", attributes),
          (_integerType) => this.addPrimitive("integer", attributes),
          (_doubleType) => this.addPrimitive("double", attributes),
          (_stringType) => this.addStringType("string", attributes),
          (arrayType) => this.addArray(arrayType.items.typeRef, attributes),
          (classType) => this.addObject(classType.typeRef, attributes),
          (mapType) => this.addObject(mapType.typeRef, attributes),
          (objectType) => this.addObject(objectType.typeRef, attributes),
          // FIXME: We're not carrying counts, so this is not correct if we do enum
          // inference.  JSON Schema input uses this case, however, without enum
          // inference, which is fine, but still a bit ugly.
          (enumType) => this.addEnum(enumType.cases, attributes),
          (_unionType) => {
            return (0, Support_1.panic)("The unions should have been eliminated in attributesForTypesInUnion");
          },
          (transformedStringType) => this.addStringType(transformedStringType.kind, attributes)
        );
      }
      addTypes(types) {
        const [attributesMap, unionAttributes] = attributesForTypes(types);
        for (const [t, attributes] of attributesMap) {
          this.addType(t, attributes);
        }
        return unionAttributes;
      }
    };
    exports.TypeRefUnionAccumulator = TypeRefUnionAccumulator;
    var UnionBuilder = class {
      constructor(typeBuilder) {
        this.typeBuilder = typeBuilder;
      }
      makeTypeOfKind(typeProvider, kind, typeAttributes, forwardingRef) {
        switch (kind) {
          case "string":
            return this.typeBuilder.getStringType(typeAttributes, void 0, forwardingRef);
          case "enum":
            return this.typeBuilder.getEnumType(typeAttributes, typeProvider.enumCases, forwardingRef);
          case "object":
            return this.makeObject(typeProvider.objectData, typeAttributes, forwardingRef);
          case "array":
            return this.makeArray(typeProvider.arrayData, typeAttributes, forwardingRef);
          default:
            if ((0, Type_1.isPrimitiveTypeKind)(kind)) {
              return this.typeBuilder.getPrimitiveType(kind, typeAttributes, forwardingRef);
            }
            if (kind === "union" || kind === "class" || kind === "map" || kind === "intersection") {
              return (0, Support_1.panic)(`getMemberKinds() shouldn't return ${kind}`);
            }
            return (0, Support_1.assertNever)(kind);
        }
      }
      buildUnion(typeProvider, unique, typeAttributes, forwardingRef) {
        const kinds = typeProvider.getMemberKinds();
        if (typeProvider.lostTypeAttributes) {
          this.typeBuilder.setLostTypeAttributes();
        }
        if (kinds.size === 1) {
          const [[kind, memberAttributes]] = Array.from(kinds);
          const allAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", typeAttributes, (0, TypeAttributes_1.increaseTypeAttributesDistance)(memberAttributes));
          const t = this.makeTypeOfKind(typeProvider, kind, allAttributes, forwardingRef);
          return t;
        }
        const union = unique ? this.typeBuilder.getUniqueUnionType(typeAttributes, void 0, forwardingRef) : void 0;
        const types = [];
        for (const [kind, memberAttributes] of kinds) {
          types.push(this.makeTypeOfKind(typeProvider, kind, memberAttributes, void 0));
        }
        const typesSet = new Set(types);
        if (union !== void 0) {
          this.typeBuilder.setSetOperationMembers(union, typesSet);
          return union;
        } else {
          return this.typeBuilder.getUnionType(typeAttributes, typesSet, forwardingRef);
        }
      }
    };
    exports.UnionBuilder = UnionBuilder;
  }
});

// node_modules/quicktype-core/dist/input/Inference.js
var require_Inference = __commonJS({
  "node_modules/quicktype-core/dist/input/Inference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeInference = void 0;
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeGraph_1 = require_TypeGraph();
    var TypeUtils_1 = require_TypeUtils();
    var UnionBuilder_1 = require_UnionBuilder();
    var CompressedJSON_1 = require_CompressedJSON();
    function forEachArrayInNestedValueArray(va, f) {
      if (va.length === 0) {
        return;
      }
      if (Array.isArray(va[0])) {
        for (const x of va) {
          forEachArrayInNestedValueArray(x, f);
        }
      } else {
        f(va);
      }
    }
    function forEachValueInNestedValueArray(va, f) {
      forEachArrayInNestedValueArray(va, (a) => {
        for (const x of a) {
          f(x);
        }
      });
    }
    var InferenceUnionBuilder = class extends UnionBuilder_1.UnionBuilder {
      constructor(typeBuilder, _typeInference, _fixed) {
        super(typeBuilder);
        this._typeInference = _typeInference;
        this._fixed = _fixed;
      }
      makeObject(objects, typeAttributes, forwardingRef) {
        return this._typeInference.inferClassType(typeAttributes, objects, this._fixed, forwardingRef);
      }
      makeArray(arrays, typeAttributes, forwardingRef) {
        return this.typeBuilder.getArrayType(typeAttributes, this._typeInference.inferType(TypeAttributes_1.emptyTypeAttributes, arrays, this._fixed, forwardingRef));
      }
    };
    function canBeEnumCase(_s) {
      return true;
    }
    var TypeInference = class {
      constructor(_cjson, _typeBuilder, _inferMaps, _inferEnums) {
        this._cjson = _cjson;
        this._typeBuilder = _typeBuilder;
        this._inferMaps = _inferMaps;
        this._inferEnums = _inferEnums;
      }
      addValuesToAccumulator(valueArray, accumulator) {
        forEachValueInNestedValueArray(valueArray, (value) => {
          const t = (0, CompressedJSON_1.valueTag)(value);
          switch (t) {
            case CompressedJSON_1.Tag.Null:
              accumulator.addPrimitive("null", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.False:
            case CompressedJSON_1.Tag.True:
              accumulator.addPrimitive("bool", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Integer:
              accumulator.addPrimitive("integer", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Double:
              accumulator.addPrimitive("double", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.InternedString:
              if (this._inferEnums) {
                const s = this._cjson.getStringForValue(value);
                if (canBeEnumCase(s)) {
                  accumulator.addStringCase(s, 1, TypeAttributes_1.emptyTypeAttributes);
                } else {
                  accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
                }
              } else {
                accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
              }
              break;
            case CompressedJSON_1.Tag.UninternedString:
              accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Object:
              accumulator.addObject(this._cjson.getObjectForValue(value), TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.Array:
              accumulator.addArray(this._cjson.getArrayForValue(value), TypeAttributes_1.emptyTypeAttributes);
              break;
            case CompressedJSON_1.Tag.StringFormat: {
              const kind = this._cjson.getStringFormatTypeKind(value);
              accumulator.addStringType("string", TypeAttributes_1.emptyTypeAttributes, new StringTypes_1.StringTypes(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Set([kind])));
              break;
            }
            case CompressedJSON_1.Tag.TransformedString: {
              const s = this._cjson.getStringForValue(value);
              const kind = (0, StringTypes_1.inferTransformedStringTypeKindForString)(s, this._cjson.dateTimeRecognizer);
              if (kind === void 0) {
                return (0, Support_1.panic)("TransformedString does not have a kind");
              }
              const producer = (0, Support_1.defined)(Type_1.transformedStringTypeTargetTypeKindsMap.get(kind)).attributesProducer;
              if (producer === void 0) {
                return (0, Support_1.panic)("TransformedString does not have attribute producer");
              }
              accumulator.addStringType("string", producer(s), new StringTypes_1.StringTypes(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Set([kind])));
              break;
            }
            default:
              return (0, Support_1.assertNever)(t);
          }
        });
      }
      inferType(typeAttributes, valueArray, fixed, forwardingRef) {
        const accumulator = this.accumulatorForArray(valueArray);
        return this.makeTypeFromAccumulator(accumulator, typeAttributes, fixed, forwardingRef);
      }
      resolveRef(ref, topLevel) {
        if (!ref.startsWith("#/")) {
          return (0, Messages_1.messageError)("InferenceJSONReferenceNotRooted", { reference: ref });
        }
        const parts = ref.split("/").slice(1);
        const graph = this._typeBuilder.typeGraph;
        let tref = topLevel;
        for (const part of parts) {
          let t = (0, TypeGraph_1.derefTypeRef)(tref, graph);
          if (t instanceof Type_1.UnionType) {
            const nullable = (0, TypeUtils_1.nullableFromUnion)(t);
            if (nullable === null) {
              return (0, Messages_1.messageError)("InferenceJSONReferenceToUnion", { reference: ref });
            }
            t = nullable;
          }
          if (t instanceof Type_1.ClassType) {
            const cp = t.getProperties().get(part);
            if (cp === void 0) {
              return (0, Messages_1.messageError)("InferenceJSONReferenceWrongProperty", { reference: ref });
            }
            tref = cp.typeRef;
          } else if (t instanceof Type_1.MapType) {
            tref = t.values.typeRef;
          } else if (t instanceof Type_1.ArrayType) {
            if (/^[0-9]+$/.exec(part) === null) {
              return (0, Messages_1.messageError)("InferenceJSONReferenceInvalidArrayIndex", { reference: ref });
            }
            tref = t.items.typeRef;
          } else {
            return (0, Messages_1.messageError)("InferenceJSONReferenceWrongProperty", { reference: ref });
          }
        }
        return tref;
      }
      inferTopLevelType(typeAttributes, valueArray, fixed) {
        (0, Support_1.assert)(this._refIntersections === void 0, "Didn't reset ref intersections - nested invocations?");
        if (this._cjson.handleRefs) {
          this._refIntersections = [];
        }
        const topLevel = this.inferType(typeAttributes, valueArray, fixed);
        if (this._cjson.handleRefs) {
          for (const [tref, refs] of (0, Support_1.defined)(this._refIntersections)) {
            const resolved = refs.map((r) => this.resolveRef(r, topLevel));
            this._typeBuilder.setSetOperationMembers(tref, new Set(resolved));
          }
          this._refIntersections = void 0;
        }
        return topLevel;
      }
      accumulatorForArray(valueArray) {
        const accumulator = new UnionBuilder_1.UnionAccumulator(true);
        this.addValuesToAccumulator(valueArray, accumulator);
        return accumulator;
      }
      makeTypeFromAccumulator(accumulator, typeAttributes, fixed, forwardingRef) {
        const unionBuilder = new InferenceUnionBuilder(this._typeBuilder, this, fixed);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
      }
      inferClassType(typeAttributes, objects, fixed, forwardingRef) {
        const propertyNames = [];
        const propertyValues = {};
        forEachArrayInNestedValueArray(objects, (arr) => {
          for (let i = 0; i < arr.length; i += 2) {
            const key = this._cjson.getStringForValue(arr[i]);
            const value = arr[i + 1];
            if (!Object.prototype.hasOwnProperty.call(propertyValues, key)) {
              propertyNames.push(key);
              propertyValues[key] = [];
            }
            propertyValues[key].push(value);
          }
        });
        if (this._cjson.handleRefs && propertyNames.length === 1 && propertyNames[0] === "$ref") {
          const values = propertyValues.$ref;
          if (values.every((v) => (0, CompressedJSON_1.valueTag)(v) === CompressedJSON_1.Tag.InternedString)) {
            const allRefs = values.map((v) => this._cjson.getStringForValue(v));
            const tref = this._typeBuilder.getUniqueIntersectionType(typeAttributes, void 0);
            (0, Support_1.defined)(this._refIntersections).push([tref, allRefs]);
            return tref;
          }
        }
        if (this._inferMaps && propertyNames.length > 500) {
          const accumulator = new UnionBuilder_1.UnionAccumulator(true);
          for (const key of propertyNames) {
            this.addValuesToAccumulator(propertyValues[key], accumulator);
          }
          const values = this.makeTypeFromAccumulator(accumulator, TypeAttributes_1.emptyTypeAttributes, fixed);
          return this._typeBuilder.getMapType(typeAttributes, values, forwardingRef);
        }
        const properties = /* @__PURE__ */ new Map();
        for (const key of propertyNames) {
          const values = propertyValues[key];
          const t = this.inferType(TypeAttributes_1.emptyTypeAttributes, values, false);
          const isOptional = values.length < objects.length;
          properties.set(key, this._typeBuilder.makeClassProperty(t, isOptional));
        }
        if (fixed) {
          return this._typeBuilder.getUniqueClassType(typeAttributes, true, properties, forwardingRef);
        } else {
          return this._typeBuilder.getClassType(typeAttributes, properties, forwardingRef);
        }
      }
    };
    exports.TypeInference = TypeInference;
  }
});

// node_modules/quicktype-core/dist/input/Inputs.js
var require_Inputs = __commonJS({
  "node_modules/quicktype-core/dist/input/Inputs.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputData = exports.jsonInputForTargetLanguage = exports.JSONInput = void 0;
    var collection_utils_1 = require_dist();
    var Description_1 = require_Description();
    var TypeNames_1 = require_TypeNames();
    var All_1 = require_All();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var CompressedJSON_1 = require_CompressedJSON();
    var Inference_1 = require_Inference();
    function messageParseError(name, description, e) {
      return (0, Messages_1.messageError)("MiscJSONParseError", {
        description: (0, collection_utils_1.withDefault)(description, "input"),
        address: name,
        message: (0, Support_1.errorMessage)(e)
      });
    }
    var JSONInput = class {
      constructor(_compressedJSON) {
        this._compressedJSON = _compressedJSON;
        this.kind = "json";
        this.needIR = true;
        this.needSchemaProcessing = false;
        this._topLevels = /* @__PURE__ */ new Map();
      }
      addSample(topLevelName, sample) {
        let topLevel = this._topLevels.get(topLevelName);
        if (topLevel === void 0) {
          topLevel = { samples: [], description: void 0 };
          this._topLevels.set(topLevelName, topLevel);
        }
        topLevel.samples.push(sample);
      }
      setDescription(topLevelName, description) {
        let topLevel = this._topLevels.get(topLevelName);
        if (topLevel === void 0) {
          return (0, Support_1.panic)("Trying to set description for a top-level that doesn't exist");
        }
        topLevel.description = description;
      }
      addSamples(name, values, description) {
        for (const value of values) {
          this.addSample(name, value);
          if (description !== void 0) {
            this.setDescription(name, description);
          }
        }
      }
      addSource(source) {
        return __awaiter(this, void 0, void 0, function* () {
          const { name, samples, description } = source;
          try {
            const values = yield (0, collection_utils_1.arrayMapSync)(samples, (s) => __awaiter(this, void 0, void 0, function* () {
              return yield this._compressedJSON.parse(s);
            }));
            this.addSamples(name, values, description);
          } catch (e) {
            return messageParseError(name, description, e);
          }
        });
      }
      addSourceSync(source) {
        const { name, samples, description } = source;
        try {
          const values = samples.map((s) => this._compressedJSON.parseSync(s));
          this.addSamples(name, values, description);
        } catch (e) {
          return messageParseError(name, description, e);
        }
      }
      singleStringSchemaSource() {
        return void 0;
      }
      addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        return __awaiter(this, void 0, void 0, function* () {
          this.addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
        });
      }
      addTypesSync(_ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        const inference = new Inference_1.TypeInference(this._compressedJSON, typeBuilder, inferMaps, inferEnums);
        for (const [name, { samples, description }] of this._topLevels) {
          const tref = inference.inferTopLevelType((0, TypeNames_1.makeNamesTypeAttributes)(name, false), samples, fixedTopLevels);
          typeBuilder.addTopLevel(name, tref);
          if (description !== void 0) {
            const attributes = Description_1.descriptionTypeAttributeKind.makeAttributes(/* @__PURE__ */ new Set([description]));
            typeBuilder.addAttributes(tref, attributes);
          }
        }
      }
    };
    exports.JSONInput = JSONInput;
    function jsonInputForTargetLanguage(targetLanguage, languages, handleJSONRefs = false) {
      if (typeof targetLanguage === "string") {
        targetLanguage = (0, Support_1.defined)((0, All_1.languageNamed)(targetLanguage, languages));
      }
      const compressedJSON = new CompressedJSON_1.CompressedJSONFromString(targetLanguage.dateTimeRecognizer, handleJSONRefs);
      return new JSONInput(compressedJSON);
    }
    exports.jsonInputForTargetLanguage = jsonInputForTargetLanguage;
    var InputData = class {
      constructor() {
        this._inputs = /* @__PURE__ */ new Set();
      }
      addInput(input) {
        this._inputs = this._inputs.add(input);
      }
      getOrAddInput(kind, makeInput) {
        let input = (0, collection_utils_1.iterableFind)(this._inputs, (i) => i.kind === kind);
        if (input === void 0) {
          input = makeInput();
          this.addInput(input);
        }
        return input;
      }
      addSource(kind, source, makeInput) {
        return __awaiter(this, void 0, void 0, function* () {
          const input = this.getOrAddInput(kind, makeInput);
          yield input.addSource(source);
        });
      }
      addSourceSync(kind, source, makeInput) {
        const input = this.getOrAddInput(kind, makeInput);
        input.addSourceSync(source);
      }
      addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const input of this._inputs) {
            yield input.addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
          }
        });
      }
      addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        for (const input of this._inputs) {
          input.addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
        }
      }
      get needIR() {
        return (0, collection_utils_1.iterableSome)(this._inputs, (i) => i.needIR);
      }
      get needSchemaProcessing() {
        return (0, collection_utils_1.iterableSome)(this._inputs, (i) => i.needSchemaProcessing);
      }
      singleStringSchemaSource() {
        const schemaStrings = (0, collection_utils_1.setFilterMap)(this._inputs, (i) => i.singleStringSchemaSource());
        if (schemaStrings.size > 1) {
          return (0, Support_1.panic)("We have more than one input with a string schema source");
        }
        return (0, collection_utils_1.iterableFirst)(schemaStrings);
      }
    };
    exports.InputData = InputData;
  }
});

// node_modules/quicktype-core/dist/MakeTransformations.js
var require_MakeTransformations = __commonJS({
  "node_modules/quicktype-core/dist/MakeTransformations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeTransformations = void 0;
    var collection_utils_1 = require_dist();
    var Constraints_1 = require_Constraints();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Transformers_1 = require_Transformers();
    var Type_1 = require_Type();
    var TypeGraph_1 = require_TypeGraph();
    function transformationAttributes(graph, reconstitutedTargetType, transformer, debugPrintTransformations) {
      const transformation = new Transformers_1.Transformation(graph, reconstitutedTargetType, transformer);
      if (debugPrintTransformations) {
        console.log(`transformation for ${(0, TypeGraph_1.typeRefIndex)(reconstitutedTargetType)}:`);
        transformation.debugPrint();
        console.log("reverse:");
        transformation.reverse.debugPrint();
      }
      return Transformers_1.transformationTypeAttributeKind.makeAttributes(transformation);
    }
    function makeEnumTransformer(graph, enumType, stringType, continuation) {
      const sortedCases = Array.from(enumType.cases).sort();
      const caseTransformers = sortedCases.map((c) => new Transformers_1.StringMatchTransformer(graph, stringType, new Transformers_1.StringProducerTransformer(graph, stringType, continuation, c), c));
      return new Transformers_1.ChoiceTransformer(graph, stringType, caseTransformers);
    }
    function replaceUnion(union, builder, forwardingRef, transformedTypes, debugPrintTransformations) {
      const graph = builder.typeGraph;
      (0, Support_1.assert)(union.members.size > 0, "We can't have empty unions");
      let additionalAttributes = TypeAttributes_1.emptyTypeAttributes;
      function reconstituteMember(t) {
        if ((0, Type_1.isPrimitiveStringTypeKind)(t.kind)) {
          const targetTypeKind = (0, Type_1.targetTypeKindForTransformedStringTypeKind)(t.kind);
          if (targetTypeKind !== void 0) {
            const targetTypeMember = union.findMember(targetTypeKind);
            additionalAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", additionalAttributes, t.getAttributes());
            if (targetTypeMember !== void 0) {
              return builder.reconstituteType(targetTypeMember);
            }
            return builder.getPrimitiveType(targetTypeKind);
          }
        }
        return builder.reconstituteType(t);
      }
      const reconstitutedMembersByKind = (0, collection_utils_1.mapMapEntries)(union.members.entries(), (m) => [m.kind, reconstituteMember(m)]);
      const reconstitutedMemberSet = new Set(reconstitutedMembersByKind.values());
      const haveUnion = reconstitutedMemberSet.size > 1;
      if (!haveUnion) {
        builder.setLostTypeAttributes();
      }
      const reconstitutedTargetType = haveUnion ? builder.getUnionType(union.getAttributes(), reconstitutedMemberSet) : (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(reconstitutedMemberSet));
      function memberForKind(kind) {
        return (0, Support_1.defined)(reconstitutedMembersByKind.get(kind));
      }
      function consumer(memberTypeRef) {
        if (!haveUnion)
          return void 0;
        return new Transformers_1.UnionInstantiationTransformer(graph, memberTypeRef);
      }
      function transformerForKind(kind) {
        const member = union.findMember(kind);
        if (member === void 0)
          return void 0;
        const memberTypeRef = memberForKind(kind);
        return new Transformers_1.DecodingTransformer(graph, memberTypeRef, consumer(memberTypeRef));
      }
      let maybeStringType = void 0;
      function getStringType() {
        if (maybeStringType === void 0) {
          maybeStringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
        }
        return maybeStringType;
      }
      function transformerForStringType(t) {
        const memberRef = memberForKind(t.kind);
        if (t.kind === "string") {
          const minMax = (0, Constraints_1.minMaxLengthForType)(t);
          if (minMax === void 0) {
            return consumer(memberRef);
          }
          const [min, max] = minMax;
          return new Transformers_1.MinMaxLengthCheckTransformer(graph, getStringType(), consumer(memberRef), min, max);
        } else if (t instanceof Type_1.EnumType && transformedTypes.has(t)) {
          return makeEnumTransformer(graph, t, getStringType(), consumer(memberRef));
        } else {
          return new Transformers_1.ParseStringTransformer(graph, getStringType(), consumer(memberRef));
        }
      }
      const stringTypes = (0, collection_utils_1.arraySortByInto)(Array.from(union.stringTypeMembers), (t) => t.kind);
      let transformerForString;
      if (stringTypes.length === 0) {
        transformerForString = void 0;
      } else if (stringTypes.length === 1) {
        const t = stringTypes[0];
        transformerForString = new Transformers_1.DecodingTransformer(graph, getStringType(), transformerForStringType(t));
      } else {
        transformerForString = new Transformers_1.DecodingTransformer(graph, getStringType(), new Transformers_1.ChoiceTransformer(graph, getStringType(), stringTypes.map((t) => (0, Support_1.defined)(transformerForStringType(t)))));
      }
      const transformerForClass = transformerForKind("class");
      const transformerForMap = transformerForKind("map");
      (0, Support_1.assert)(transformerForClass === void 0 || transformerForMap === void 0, "Can't have both class and map in a transformed union");
      const transformerForObject = transformerForClass !== null && transformerForClass !== void 0 ? transformerForClass : transformerForMap;
      const transformer = new Transformers_1.DecodingChoiceTransformer(graph, builder.getPrimitiveType("any"), transformerForKind("null"), transformerForKind("integer"), transformerForKind("double"), transformerForKind("bool"), transformerForString, transformerForKind("array"), transformerForObject);
      const attributes = transformationAttributes(graph, reconstitutedTargetType, transformer, debugPrintTransformations);
      return builder.getPrimitiveType("any", (0, TypeAttributes_1.combineTypeAttributes)("union", attributes, additionalAttributes), forwardingRef);
    }
    function replaceArray(arrayType, builder, forwardingRef, debugPrintTransformations) {
      const anyType = builder.getPrimitiveType("any");
      const anyArrayType = builder.getArrayType(TypeAttributes_1.emptyTypeAttributes, anyType);
      const reconstitutedItems = builder.reconstituteType(arrayType.items);
      const transformer = new Transformers_1.ArrayDecodingTransformer(builder.typeGraph, anyArrayType, void 0, reconstitutedItems, new Transformers_1.DecodingTransformer(builder.typeGraph, anyType, void 0));
      const reconstitutedArray = builder.getArrayType(builder.reconstituteTypeAttributes(arrayType.getAttributes()), reconstitutedItems);
      const attributes = transformationAttributes(builder.typeGraph, reconstitutedArray, transformer, debugPrintTransformations);
      return builder.getArrayType(attributes, anyType, forwardingRef);
    }
    function replaceEnum(enumType, builder, forwardingRef, debugPrintTransformations) {
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, makeEnumTransformer(builder.typeGraph, enumType, stringType));
      const reconstitutedEnum = builder.getEnumType(enumType.getAttributes(), enumType.cases);
      const attributes = transformationAttributes(builder.typeGraph, reconstitutedEnum, transformer, debugPrintTransformations);
      return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
    }
    function replaceNumber(t, builder, forwardingRef, debugPrintTransformations) {
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const [min, max] = (0, Support_1.defined)((0, Constraints_1.minMaxValueForType)(t));
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, new Transformers_1.MinMaxValueTransformer(builder.typeGraph, stringType, void 0, min, max));
      const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
      const attributes = transformationAttributes(builder.typeGraph, builder.getPrimitiveType("double", reconstitutedAttributes, void 0), transformer, debugPrintTransformations);
      return builder.getPrimitiveType("double", attributes, forwardingRef);
    }
    function replaceString(t, builder, forwardingRef, debugPrintTransformations) {
      const [min, max] = (0, Support_1.defined)((0, Constraints_1.minMaxLengthForType)(t));
      const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, new Transformers_1.MinMaxLengthCheckTransformer(builder.typeGraph, stringType, void 0, min, max));
      const attributes = transformationAttributes(builder.typeGraph, builder.getStringType(reconstitutedAttributes, void 0), transformer, debugPrintTransformations);
      return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
    }
    function replaceTransformedStringType(t, kind, builder, forwardingRef, debugPrintTransformations) {
      const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
      const targetTypeKind = (0, collection_utils_1.withDefault)((0, Type_1.targetTypeKindForTransformedStringTypeKind)(kind), kind);
      const stringType = builder.getStringType(TypeAttributes_1.emptyTypeAttributes, StringTypes_1.StringTypes.unrestricted);
      const transformer = new Transformers_1.DecodingTransformer(builder.typeGraph, stringType, new Transformers_1.ParseStringTransformer(builder.typeGraph, stringType, void 0));
      const attributes = transformationAttributes(builder.typeGraph, builder.getPrimitiveType(targetTypeKind, reconstitutedAttributes), transformer, debugPrintTransformations);
      return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
    }
    function makeTransformations(ctx, graph, targetLanguage) {
      const transformedTypes = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => {
        if (targetLanguage.needsTransformerForType(t))
          return true;
        if (!(t instanceof Type_1.UnionType))
          return false;
        const stringMembers = t.stringTypeMembers;
        if (stringMembers.size <= 1)
          return false;
        return (0, collection_utils_1.iterableSome)(stringMembers, (m) => targetLanguage.needsTransformerForType(m));
      });
      function replace(setOfOneUnion, builder, forwardingRef) {
        const t = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfOneUnion));
        if (t instanceof Type_1.UnionType) {
          return replaceUnion(t, builder, forwardingRef, transformedTypes, ctx.debugPrintTransformations);
        }
        if (t instanceof Type_1.ArrayType) {
          return replaceArray(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (t instanceof Type_1.EnumType) {
          return replaceEnum(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (t.kind === "string") {
          return replaceString(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if ((0, Type_1.isNumberTypeKind)(t.kind)) {
          return replaceNumber(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if ((0, Type_1.isPrimitiveStringTypeKind)(t.kind)) {
          return replaceTransformedStringType(t, t.kind, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        return (0, Support_1.panic)(`Cannot make transformation for type ${t.kind}`);
      }
      const groups = Array.from(transformedTypes).map((t) => [t]);
      return graph.rewrite("make-transformations", ctx.stringTypeMapping, false, groups, ctx.debugPrintReconstitution, replace);
    }
    exports.makeTransformations = makeTransformations;
  }
});

// node_modules/quicktype-core/dist/UnifyClasses.js
var require_UnifyClasses = __commonJS({
  "node_modules/quicktype-core/dist/UnifyClasses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unifyTypes = exports.unionBuilderForUnification = exports.UnifyUnionBuilder = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeGraph_1 = require_TypeGraph();
    var TypeUtils_1 = require_TypeUtils();
    var UnionBuilder_1 = require_UnionBuilder();
    function getCliqueProperties(clique, builder, makePropertyType) {
      let lostTypeAttributes = false;
      let propertyNames = /* @__PURE__ */ new Set();
      for (const o of clique) {
        (0, collection_utils_1.setUnionInto)(propertyNames, o.getProperties().keys());
      }
      let properties = Array.from(propertyNames).map((name) => [name, /* @__PURE__ */ new Set(), false]);
      let additionalProperties = void 0;
      for (const o of clique) {
        let additional = o.getAdditionalProperties();
        if (additional !== void 0) {
          if (additionalProperties === void 0) {
            additionalProperties = /* @__PURE__ */ new Set();
          }
          if (additional !== void 0) {
            additionalProperties.add(additional);
          }
        }
        for (let i = 0; i < properties.length; i++) {
          let [name, types, isOptional] = properties[i];
          const maybeProperty = o.getProperties().get(name);
          if (maybeProperty === void 0) {
            isOptional = true;
            if (additional !== void 0 && additional.kind !== "any") {
              types.add(additional);
            }
          } else {
            if (maybeProperty.isOptional) {
              isOptional = true;
            }
            types.add(maybeProperty.type);
          }
          properties[i][2] = isOptional;
        }
      }
      const unifiedAdditionalProperties = additionalProperties === void 0 ? void 0 : makePropertyType(additionalProperties);
      const unifiedPropertiesArray = properties.map(([name, types, isOptional]) => {
        return [name, builder.makeClassProperty(makePropertyType(types), isOptional)];
      });
      const unifiedProperties = new Map(unifiedPropertiesArray);
      return [unifiedProperties, unifiedAdditionalProperties, lostTypeAttributes];
    }
    function countProperties(clique) {
      let hasProperties = false;
      let hasAdditionalProperties = false;
      let hasNonAnyAdditionalProperties = false;
      for (const o of clique) {
        if (o.getProperties().size > 0) {
          hasProperties = true;
        }
        const additional = o.getAdditionalProperties();
        if (additional !== void 0) {
          hasAdditionalProperties = true;
          if (additional.kind !== "any") {
            hasNonAnyAdditionalProperties = true;
          }
        }
      }
      return { hasProperties, hasAdditionalProperties, hasNonAnyAdditionalProperties };
    }
    var UnifyUnionBuilder = class extends UnionBuilder_1.UnionBuilder {
      constructor(typeBuilder, _makeObjectTypes, _makeClassesFixed, _unifyTypes) {
        super(typeBuilder);
        this._makeObjectTypes = _makeObjectTypes;
        this._makeClassesFixed = _makeClassesFixed;
        this._unifyTypes = _unifyTypes;
      }
      makeObject(objectRefs, typeAttributes, forwardingRef) {
        const maybeTypeRef = this.typeBuilder.lookupTypeRefs(objectRefs, forwardingRef);
        if (maybeTypeRef !== void 0) {
          (0, Support_1.assert)(forwardingRef === void 0 || maybeTypeRef === forwardingRef, "The forwarding ref must be consumed");
          this.typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
          return maybeTypeRef;
        }
        if (objectRefs.length === 1) {
          return this.typeBuilder.reconstituteTypeRef(objectRefs[0], typeAttributes, forwardingRef);
        }
        const objectTypes = objectRefs.map((r) => (0, TypeUtils_1.assertIsObject)((0, TypeGraph_1.derefTypeRef)(r, this.typeBuilder)));
        const { hasProperties, hasAdditionalProperties, hasNonAnyAdditionalProperties } = countProperties(objectTypes);
        if (!this._makeObjectTypes && (hasNonAnyAdditionalProperties || !hasProperties && hasAdditionalProperties)) {
          const propertyTypes = /* @__PURE__ */ new Set();
          for (const o of objectTypes) {
            (0, collection_utils_1.setUnionInto)(propertyTypes, Array.from(o.getProperties().values()).map((cp) => cp.typeRef));
          }
          const additionalPropertyTypes = new Set(objectTypes.filter((o) => o.getAdditionalProperties() !== void 0).map((o) => (0, Support_1.defined)(o.getAdditionalProperties()).typeRef));
          (0, collection_utils_1.setUnionInto)(propertyTypes, additionalPropertyTypes);
          return this.typeBuilder.getMapType(typeAttributes, this._unifyTypes(Array.from(propertyTypes)));
        } else {
          const [properties, additionalProperties, lostTypeAttributes] = getCliqueProperties(objectTypes, this.typeBuilder, (types) => {
            (0, Support_1.assert)(types.size > 0, "Property has no type");
            return this._unifyTypes(Array.from(types).map((t) => t.typeRef));
          });
          if (lostTypeAttributes) {
            this.typeBuilder.setLostTypeAttributes();
          }
          if (this._makeObjectTypes) {
            return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
          } else {
            (0, Support_1.assert)(additionalProperties === void 0, "We have additional properties but want to make a class");
            return this.typeBuilder.getUniqueClassType(typeAttributes, this._makeClassesFixed, properties, forwardingRef);
          }
        }
      }
      makeArray(arrays, typeAttributes, forwardingRef) {
        const ref = this.typeBuilder.getArrayType(typeAttributes, this._unifyTypes(arrays), forwardingRef);
        return ref;
      }
    };
    exports.UnifyUnionBuilder = UnifyUnionBuilder;
    function unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers) {
      return new UnifyUnionBuilder(typeBuilder, makeObjectTypes, makeClassesFixed, (trefs) => unifyTypes(new Set(trefs.map((tref) => (0, TypeGraph_1.derefTypeRef)(tref, typeBuilder))), TypeAttributes_1.emptyTypeAttributes, typeBuilder, unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers), conflateNumbers));
    }
    exports.unionBuilderForUnification = unionBuilderForUnification;
    function unifyTypes(types, typeAttributes, typeBuilder, unionBuilder, conflateNumbers, maybeForwardingRef) {
      typeAttributes = typeBuilder.reconstituteTypeAttributes(typeAttributes);
      if (types.size === 0) {
        return (0, Support_1.panic)("Cannot unify empty set of types");
      } else if (types.size === 1) {
        const first = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(types));
        if (!(first instanceof Type_1.UnionType)) {
          return typeBuilder.reconstituteTypeRef(first.typeRef, typeAttributes, maybeForwardingRef);
        }
      }
      const typeRefs = Array.from(types).map((t) => t.typeRef);
      const maybeTypeRef = typeBuilder.lookupTypeRefs(typeRefs, maybeForwardingRef);
      if (maybeTypeRef !== void 0) {
        typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
        return maybeTypeRef;
      }
      const accumulator = new UnionBuilder_1.TypeRefUnionAccumulator(conflateNumbers);
      const nestedAttributes = typeBuilder.reconstituteTypeAttributes(accumulator.addTypes(types));
      typeAttributes = (0, TypeAttributes_1.combineTypeAttributes)("union", typeAttributes, nestedAttributes);
      return typeBuilder.withForwardingRef(maybeForwardingRef, (forwardingRef) => {
        typeBuilder.registerUnion(typeRefs, forwardingRef);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
      });
    }
    exports.unifyTypes = unifyTypes;
  }
});

// node_modules/quicktype-core/dist/rewrites/CombineClasses.js
var require_CombineClasses = __commonJS({
  "node_modules/quicktype-core/dist/rewrites/CombineClasses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineClasses = void 0;
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var UnifyClasses_1 = require_UnifyClasses();
    var REQUIRED_OVERLAP = 3 / 4;
    function typeSetsCanBeCombined(s1, s2) {
      return (0, Type_1.setOperationCasesEqual)(s1, s2, true, (a, b) => a.structurallyCompatible(b, true));
    }
    function canBeCombined(c1, c2, onlyWithSameProperties) {
      const p1 = c1.getProperties();
      const p2 = c2.getProperties();
      if (onlyWithSameProperties) {
        if (p1.size !== p2.size) {
          return false;
        }
      } else {
        if (p1.size < p2.size * REQUIRED_OVERLAP || p2.size < p1.size * REQUIRED_OVERLAP) {
          return false;
        }
      }
      let larger;
      let smaller;
      if (p1.size > p2.size) {
        larger = p1;
        smaller = p2;
      } else {
        larger = p2;
        smaller = p1;
      }
      let maxFaults;
      if (onlyWithSameProperties) {
        maxFaults = 0;
      } else {
        const minOverlap = Math.ceil(larger.size * REQUIRED_OVERLAP);
        maxFaults = smaller.size - minOverlap;
      }
      (0, Support_1.assert)(maxFaults >= 0, "Max faults negative");
      const commonProperties = [];
      let faults = 0;
      for (const [name] of smaller) {
        if (larger.has(name)) {
          commonProperties.push(name);
        } else {
          faults += 1;
          if (faults > maxFaults)
            break;
        }
      }
      if (faults > maxFaults)
        return false;
      for (const name of commonProperties) {
        let ts = smaller.get(name);
        let tl = larger.get(name);
        if (ts === void 0 || tl === void 0) {
          return (0, Support_1.panic)(`Both classes should have property ${name}`);
        }
        const tsCases = (0, TypeUtils_1.nonNullTypeCases)(ts.type);
        const tlCases = (0, TypeUtils_1.nonNullTypeCases)(tl.type);
        if (tsCases.size > 0 && tlCases.size > 0 && !typeSetsCanBeCombined(tsCases, tlCases)) {
          return false;
        }
      }
      return true;
    }
    function tryAddToClique(c, clique, onlyWithSameProperties) {
      for (const prototype of clique.prototypes) {
        if (prototype.structurallyCompatible(c)) {
          clique.members.push(c);
          return true;
        }
      }
      for (const prototype of clique.prototypes) {
        if (canBeCombined(prototype, c, onlyWithSameProperties)) {
          clique.prototypes.push(c);
          clique.members.push(c);
          return true;
        }
      }
      return false;
    }
    function findSimilarityCliques(graph, onlyWithSameProperties, includeFixedClasses) {
      const classCandidates = Array.from(graph.allNamedTypesSeparated().objects).filter((o) => o instanceof Type_1.ClassType && (includeFixedClasses || !o.isFixed));
      const cliques = [];
      for (const c of classCandidates) {
        let cliqueIndex = void 0;
        for (let i = 0; i < cliques.length; i++) {
          if (tryAddToClique(c, cliques[i], onlyWithSameProperties)) {
            cliqueIndex = i;
            break;
          }
        }
        if (cliqueIndex === void 0) {
          cliqueIndex = cliques.length;
          cliques.push({ members: [c], prototypes: [c] });
        }
        const tmp = cliques[0];
        cliques[0] = cliques[cliqueIndex];
        cliques[cliqueIndex] = tmp;
      }
      return cliques.map((clique) => clique.members).filter((cl) => cl.length > 1);
    }
    function combineClasses(ctx, graph, alphabetizeProperties, conflateNumbers, onlyWithSameProperties, debugPrintReconstitution) {
      const cliques = ctx.time("  find similarity cliques", () => findSimilarityCliques(graph, onlyWithSameProperties, false));
      function makeCliqueClass(clique, builder, forwardingRef) {
        (0, Support_1.assert)(clique.size > 0, "Clique can't be empty");
        const attributes = (0, TypeUtils_1.combineTypeAttributesOfTypes)("union", clique);
        return (0, UnifyClasses_1.unifyTypes)(clique, attributes, builder, (0, UnifyClasses_1.unionBuilderForUnification)(builder, false, false, conflateNumbers), conflateNumbers, forwardingRef);
      }
      return graph.rewrite("combine classes", ctx.stringTypeMapping, alphabetizeProperties, cliques, debugPrintReconstitution, makeCliqueClass);
    }
    exports.combineClasses = combineClasses;
  }
});

// node_modules/quicktype-core/dist/rewrites/ExpandStrings.js
var require_ExpandStrings = __commonJS({
  "node_modules/quicktype-core/dist/rewrites/ExpandStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expandStrings = void 0;
    var collection_utils_1 = require_dist();
    var StringTypes_1 = require_StringTypes();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var TypeUtils_1 = require_TypeUtils();
    var MIN_LENGTH_FOR_ENUM = 10;
    var MIN_LENGTH_FOR_OVERLAP = 5;
    var REQUIRED_OVERLAP = 3 / 4;
    function isOwnEnum({ numValues, cases }) {
      return numValues >= MIN_LENGTH_FOR_ENUM && cases.size < Math.sqrt(numValues);
    }
    function enumCasesOverlap(newCases, existingCases, newAreSubordinate) {
      const smaller = newAreSubordinate ? newCases.size : Math.min(newCases.size, existingCases.size);
      const overlap = (0, collection_utils_1.setIntersect)(newCases, existingCases).size;
      return overlap >= smaller * REQUIRED_OVERLAP;
    }
    function isAlwaysEmptyString(cases) {
      return cases.length === 1 && cases[0] === "";
    }
    function expandStrings(ctx, graph, inference) {
      const stringTypeMapping = ctx.stringTypeMapping;
      const allStrings = Array.from(graph.allTypesUnordered()).filter((t) => t.kind === "string" && (0, TypeUtils_1.stringTypesForType)(t).isRestricted);
      function makeEnumInfo(t) {
        const stringTypes = (0, TypeUtils_1.stringTypesForType)(t);
        const mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted)
          return void 0;
        const cases = (0, Support_1.defined)(mappedStringTypes.cases);
        if (cases.size === 0)
          return void 0;
        const numValues = (0, collection_utils_1.iterableReduce)(cases.values(), 0, (a, b) => a + b);
        if (inference !== "all") {
          const keys = Array.from(cases.keys());
          if (isAlwaysEmptyString(keys))
            return void 0;
          const someCaseIsNotNumber = (0, collection_utils_1.iterableSome)(keys, (key) => /^[-+]?[0-9]+(\.[0-9]+)?$/.test(key) === false);
          if (!someCaseIsNotNumber)
            return void 0;
        }
        return { cases: new Set(cases.keys()), numValues };
      }
      const enumInfos = /* @__PURE__ */ new Map();
      const enumSets = [];
      if (inference !== "none") {
        let findOverlap = function(newCases, newAreSubordinate) {
          return enumSets.findIndex((s) => enumCasesOverlap(newCases, s, newAreSubordinate));
        };
        for (const t of allStrings) {
          const enumInfo = makeEnumInfo(t);
          if (enumInfo === void 0)
            continue;
          enumInfos.set(t, enumInfo);
        }
        for (const t of Array.from(enumInfos.keys())) {
          const enumInfo = (0, Support_1.defined)(enumInfos.get(t));
          const cases = enumInfo.cases;
          if (inference === "all") {
            enumSets.push(cases);
          } else {
            if (!isOwnEnum(enumInfo))
              continue;
            const index = findOverlap(cases, false);
            if (index >= 0) {
              enumSets[index] = (0, collection_utils_1.setUnion)(enumSets[index], cases);
            } else {
              enumSets.push(cases);
            }
          }
          enumInfos.delete(t);
        }
        if (inference === "all") {
          (0, Support_1.assert)(enumInfos.size === 0);
        }
        for (const [, enumInfo] of enumInfos.entries()) {
          if (enumInfo.numValues < MIN_LENGTH_FOR_OVERLAP)
            continue;
          const index = findOverlap(enumInfo.cases, true);
          if (index >= 0) {
            enumSets[index] = (0, collection_utils_1.setUnion)(enumSets[index], enumInfo.cases);
          }
        }
      }
      function replaceString(group, builder, forwardingRef) {
        (0, Support_1.assert)(group.size === 1);
        const t = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(group));
        const stringTypes = (0, TypeUtils_1.stringTypesForType)(t);
        const attributes = (0, collection_utils_1.mapFilter)(t.getAttributes(), (a) => a !== stringTypes);
        const mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted) {
          return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
        }
        const setMatches = inference === "all" ? collection_utils_1.areEqual : collection_utils_1.setIsSuperset;
        const types = [];
        const cases = (0, Support_1.defined)(mappedStringTypes.cases);
        if (cases.size > 0) {
          const keys = new Set(cases.keys());
          const fullCases = enumSets.find((s) => setMatches(s, keys));
          if (inference !== "none" && !isAlwaysEmptyString(Array.from(keys)) && fullCases !== void 0) {
            types.push(builder.getEnumType(TypeAttributes_1.emptyTypeAttributes, fullCases));
          } else {
            return builder.getStringType(attributes, StringTypes_1.StringTypes.unrestricted, forwardingRef);
          }
        }
        const transformations = mappedStringTypes.transformations;
        if (types.length === 0 && transformations.size === 1) {
          const kind = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(transformations));
          return builder.getPrimitiveType(kind, attributes, forwardingRef);
        }
        types.push(...Array.from(transformations).map((k) => builder.getPrimitiveType(k)));
        (0, Support_1.assert)(types.length > 0, "We got an empty string type");
        return builder.getUnionType(attributes, new Set(types), forwardingRef);
      }
      return graph.rewrite("expand strings", stringTypeMapping, false, allStrings.map((t) => [t]), ctx.debugPrintReconstitution, replaceString);
    }
    exports.expandStrings = expandStrings;
  }
});

// node_modules/quicktype-core/dist/rewrites/FlattenStrings.js
var require_FlattenStrings = __commonJS({
  "node_modules/quicktype-core/dist/rewrites/FlattenStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flattenStrings = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var TypeUtils_1 = require_TypeUtils();
    function unionNeedsReplacing(u) {
      const stringMembers = u.stringTypeMembers;
      if (stringMembers.size <= 1)
        return void 0;
      const stringType = u.findMember("string");
      if (stringType === void 0)
        return void 0;
      (0, Support_1.assert)(!(0, TypeUtils_1.stringTypesForType)(stringType).isRestricted, "We must only flatten strings if we have no restriced strings");
      return stringMembers;
    }
    function replaceUnion(group, builder, forwardingRef) {
      (0, Support_1.assert)(group.size === 1);
      const u = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(group));
      const stringMembers = (0, Support_1.defined)(unionNeedsReplacing(u));
      const stringAttributes = (0, TypeUtils_1.combineTypeAttributesOfTypes)("union", stringMembers);
      const types = [];
      for (const t of u.members) {
        if (stringMembers.has(t))
          continue;
        types.push(builder.reconstituteType(t));
      }
      if (types.length === 0) {
        return builder.getStringType((0, TypeAttributes_1.combineTypeAttributes)("union", stringAttributes, u.getAttributes()), void 0, forwardingRef);
      }
      types.push(builder.getStringType(stringAttributes, void 0));
      return builder.getUnionType(u.getAttributes(), new Set(types), forwardingRef);
    }
    function flattenStrings(graph, stringTypeMapping, debugPrintReconstitution) {
      const allUnions = graph.allNamedTypesSeparated().unions;
      const unionsToReplace = Array.from(allUnions).filter(unionNeedsReplacing).map((t) => [t]);
      return graph.rewrite("flatten strings", stringTypeMapping, false, unionsToReplace, debugPrintReconstitution, replaceUnion);
    }
    exports.flattenStrings = flattenStrings;
  }
});

// node_modules/quicktype-core/dist/rewrites/FlattenUnions.js
var require_FlattenUnions = __commonJS({
  "node_modules/quicktype-core/dist/rewrites/FlattenUnions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flattenUnions = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Messages_1 = require_Messages();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeGraph_1 = require_TypeGraph();
    var TypeUtils_1 = require_TypeUtils();
    var UnifyClasses_1 = require_UnifyClasses();
    function flattenUnions(graph, stringTypeMapping, conflateNumbers, makeObjectTypes, debugPrintReconstitution) {
      let needsRepeat = false;
      function replace(types, builder, forwardingRef) {
        const unionBuilder = new UnifyClasses_1.UnifyUnionBuilder(builder, makeObjectTypes, true, (trefs) => {
          (0, Support_1.assert)(trefs.length > 0, "Must have at least one type to build union");
          trefs = trefs.map((tref) => builder.reconstituteType((0, TypeGraph_1.derefTypeRef)(tref, graph)));
          if (trefs.length === 1) {
            return trefs[0];
          }
          needsRepeat = true;
          return builder.getUnionType(TypeAttributes_1.emptyTypeAttributes, new Set(trefs));
        });
        return (0, UnifyClasses_1.unifyTypes)(types, TypeAttributes_1.emptyTypeAttributes, builder, unionBuilder, conflateNumbers, forwardingRef);
      }
      const allUnions = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t instanceof Type_1.UnionType);
      const nonCanonicalUnions = (0, collection_utils_1.setFilter)(allUnions, (u) => !u.isCanonical);
      let foundIntersection = false;
      const groups = (0, TypeUtils_1.makeGroupsToFlatten)(nonCanonicalUnions, (members) => {
        (0, Messages_1.messageAssert)(members.size > 0, "IRNoEmptyUnions", {});
        if (!(0, collection_utils_1.iterableSome)(members, (m) => m instanceof Type_1.IntersectionType))
          return true;
        foundIntersection = true;
        return false;
      });
      graph = graph.rewrite("flatten unions", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
      return [graph, !needsRepeat && !foundIntersection];
    }
    exports.flattenUnions = flattenUnions;
  }
});

// node_modules/quicktype-core/dist/EncodedMarkovChain.js
var require_EncodedMarkovChain = __commonJS({
  "node_modules/quicktype-core/dist/EncodedMarkovChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodedMarkovChain = void 0;
    exports.encodedMarkovChain = "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";
  }
});

// node_modules/quicktype-core/dist/MarkovChain.js
var require_MarkovChain = __commonJS({
  "node_modules/quicktype-core/dist/MarkovChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.test = exports.generate = exports.evaluate = exports.evaluateFull = exports.load = exports.train = void 0;
    var EncodedMarkovChain_1 = require_EncodedMarkovChain();
    var Support_1 = require_Support();
    function makeTrie() {
      const arr = [];
      for (let i = 0; i < 128; i++) {
        arr.push(null);
      }
      return { count: 0, arr };
    }
    function lookup(t, seq2, i) {
      if (i >= seq2.length) {
        return t;
      }
      let first = seq2.charCodeAt(i);
      if (first >= 128) {
        first = 0;
      }
      const n = t.arr[first];
      if (n === null) {
        return void 0;
      }
      if (typeof n === "object") {
        return lookup(n, seq2, i + 1);
      } else {
        return n / t.count;
      }
    }
    function increment(t, seq2, i) {
      let first = seq2.charCodeAt(i);
      if (first >= 128) {
        first = 0;
      }
      if (i >= seq2.length - 1) {
        if (typeof t !== "object") {
          return (0, Support_1.panic)("Malformed trie");
        }
        let n = t.arr[first];
        if (n === null) {
          n = 0;
        } else if (typeof n === "object") {
          return (0, Support_1.panic)("Malformed trie");
        }
        t.arr[first] = n + 1;
        t.count += 1;
        return;
      }
      let st = t.arr[first];
      if (st === null) {
        t.arr[first] = st = makeTrie();
      }
      if (typeof st !== "object") {
        return (0, Support_1.panic)("Malformed trie");
      }
      increment(st, seq2, i + 1);
    }
    function train(lines, depth) {
      const trie = makeTrie();
      for (const l of lines) {
        for (let i = depth; i <= l.length; i++) {
          increment(trie, l.slice(i - depth, i), 0);
        }
      }
      return { trie, depth };
    }
    exports.train = train;
    function load() {
      return JSON.parse((0, Support_1.inflateBase64)(EncodedMarkovChain_1.encodedMarkovChain));
    }
    exports.load = load;
    function evaluateFull(mc, word) {
      const { trie, depth } = mc;
      if (word.length < depth) {
        return [1, []];
      }
      let p = 1;
      const scores = [];
      for (let i = depth; i <= word.length; i++) {
        let cp = lookup(trie, word.slice(i - depth, i), 0);
        if (typeof cp === "object") {
          return (0, Support_1.panic)("Did we mess up the depth?");
        }
        if (cp === void 0) {
          cp = 1e-4;
        }
        scores.push(cp);
        p = p * cp;
      }
      return [Math.pow(p, 1 / (word.length - depth + 1)), scores];
    }
    exports.evaluateFull = evaluateFull;
    function evaluate(mc, word) {
      return evaluateFull(mc, word)[0];
    }
    exports.evaluate = evaluate;
    function randomInt(lower, upper) {
      const range = upper - lower;
      return lower + Math.floor(Math.random() * range);
    }
    function generate(mc, state, unseenWeight) {
      (0, Support_1.assert)(state.length === mc.depth - 1, "State and chain length don't match up");
      const t = lookup(mc.trie, state, 0);
      if (typeof t === "number") {
        return (0, Support_1.panic)("Wrong depth?");
      }
      if (t === void 0) {
        return String.fromCharCode(randomInt(32, 127));
      }
      const counts = t.arr.map((x, i) => x === null ? i === 0 ? 0 : unseenWeight : x);
      let n = 0;
      for (const c of counts) {
        n += c;
      }
      const r = randomInt(0, n);
      let sum = 0;
      for (let i = 0; i < counts.length; i++) {
        sum += counts[i];
        if (r < sum) {
          return String.fromCharCode(i);
        }
      }
      return (0, Support_1.panic)("We screwed up bookkeeping, or randomInt");
    }
    exports.generate = generate;
    function testWord(mc, word) {
      console.log(`"${word}": ${evaluate(mc, word)}`);
    }
    function test() {
      const mc = load();
      testWord(mc, "url");
      testWord(mc, "json");
      testWord(mc, "my_property");
      testWord(mc, "ordinary");
      testWord(mc, "different");
      testWord(mc, "189512");
      testWord(mc, "2BTZIqw0ntH9MvilQ3ewNY");
      testWord(mc, "0uBTNdNGb2OY5lou41iYL52LcDq2");
      testWord(mc, "-KpqHmWuDOUnr1hmAhxp");
      testWord(mc, "granularity");
      testWord(mc, "coverage");
      testWord(mc, "postingFrequency");
      testWord(mc, "dataFrequency");
      testWord(mc, "units");
      testWord(mc, "datasetOwner");
      testWord(mc, "organization");
      testWord(mc, "timePeriod");
      testWord(mc, "contactInformation");
      testWord(mc, "ð¾ ð ð ð ð ð ð ð§");
    }
    exports.test = test;
  }
});

// node_modules/quicktype-core/dist/rewrites/InferMaps.js
var require_InferMaps = __commonJS({
  "node_modules/quicktype-core/dist/rewrites/InferMaps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inferMaps = void 0;
    var collection_utils_1 = require_dist();
    var MarkovChain_1 = require_MarkovChain();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var UnifyClasses_1 = require_UnifyClasses();
    var mapSizeThreshold = 20;
    var stringMapSizeThreshold = 50;
    var markovChain = void 0;
    function nameProbability(name) {
      if (markovChain === void 0) {
        markovChain = (0, MarkovChain_1.load)();
      }
      return (0, MarkovChain_1.evaluate)(markovChain, name);
    }
    function shouldBeMap(properties) {
      const numProperties = properties.size;
      if (numProperties < 2)
        return void 0;
      if ((0, collection_utils_1.iterableEvery)(properties.keys(), (n) => /^[0-9]+$/.test(n))) {
        return (0, collection_utils_1.setMap)(properties.values(), (cp) => cp.type);
      }
      if (numProperties < stringMapSizeThreshold && (0, collection_utils_1.iterableEvery)(properties.values(), (cp) => (0, Type_1.isPrimitiveStringTypeKind)(cp.type.kind) || cp.type.kind === "null")) {
        return void 0;
      }
      if (numProperties < mapSizeThreshold) {
        const names = Array.from(properties.keys());
        const probabilities = names.map(nameProbability);
        const product = probabilities.reduce((a, b) => a * b, 1);
        const probability = Math.pow(product, 1 / numProperties);
        const exponent = 5;
        const scale = Math.pow(22, exponent);
        const limit = Math.pow(numProperties + 2, exponent) / scale + (25e-4 - Math.pow(3, exponent) / scale);
        if (probability > limit)
          return void 0;
      }
      let firstNonNullCases = void 0;
      const allCases = /* @__PURE__ */ new Set();
      let canBeMap = true;
      for (const [, p] of properties) {
        const nn = (0, TypeUtils_1.removeNullFromType)(p.type)[1];
        if (nn.size > 0) {
          if (firstNonNullCases !== void 0) {
            if (!(0, Type_1.setOperationCasesEqual)(nn, firstNonNullCases, true, (a, b) => a.structurallyCompatible(b, true))) {
              canBeMap = false;
              break;
            }
          } else {
            firstNonNullCases = nn;
          }
        }
        allCases.add(p.type);
      }
      if (!canBeMap) {
        return void 0;
      }
      return allCases;
    }
    function inferMaps(graph, stringTypeMapping, conflateNumbers, debugPrintReconstitution) {
      function replaceClass(setOfOneClass, builder, forwardingRef) {
        const c = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfOneClass));
        const properties = c.getProperties();
        const shouldBe = shouldBeMap(properties);
        if (shouldBe === void 0) {
          return (0, Support_1.panic)(`We shouldn't be replacing class ${c.getCombinedName()} with a map`);
        }
        return builder.getMapType(c.getAttributes(), (0, UnifyClasses_1.unifyTypes)(shouldBe, c.getAttributes(), builder, (0, UnifyClasses_1.unionBuilderForUnification)(builder, false, false, conflateNumbers), conflateNumbers), forwardingRef);
      }
      const classesToReplace = Array.from(graph.allNamedTypesSeparated().objects).filter((o) => {
        if (!(o instanceof Type_1.ClassType))
          return false;
        return !o.isFixed && shouldBeMap(o.getProperties()) !== void 0;
      });
      return graph.rewrite("infer maps", stringTypeMapping, false, classesToReplace.map((c) => [c]), debugPrintReconstitution, replaceClass);
    }
    exports.inferMaps = inferMaps;
  }
});

// node_modules/quicktype-core/dist/rewrites/ReplaceObjectType.js
var require_ReplaceObjectType = __commonJS({
  "node_modules/quicktype-core/dist/rewrites/ReplaceObjectType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceObjectType = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    function replaceObjectType(graph, stringTypeMapping, _conflateNumbers, leaveFullObjects, debugPrintReconstitution) {
      function replace(setOfOneType, builder, forwardingRef) {
        const o = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(setOfOneType));
        const attributes = o.getAttributes();
        const properties = o.getProperties();
        const additionalProperties = o.getAdditionalProperties();
        function reconstituteProperties() {
          return (0, collection_utils_1.mapMap)(properties, (cp) => builder.makeClassProperty(builder.reconstituteTypeRef(cp.typeRef), cp.isOptional));
        }
        function makeClass() {
          return builder.getUniqueClassType(attributes, true, reconstituteProperties(), forwardingRef);
        }
        function reconstituteAdditionalProperties() {
          return builder.reconstituteType((0, Support_1.defined)(additionalProperties));
        }
        if (additionalProperties === void 0) {
          return makeClass();
        }
        if (properties.size === 0) {
          return builder.getMapType(attributes, reconstituteAdditionalProperties(), forwardingRef);
        }
        if (additionalProperties.kind === "any") {
          builder.setLostTypeAttributes();
          return makeClass();
        }
        const propertyTypes = (0, collection_utils_1.setMap)(properties.values(), (cp) => cp.type).add(additionalProperties);
        let union = builder.lookupTypeRefs(Array.from(propertyTypes).map((t) => t.typeRef));
        if (union === void 0) {
          const reconstitutedTypes = (0, collection_utils_1.setMap)(propertyTypes, (t) => builder.reconstituteType(t));
          union = builder.getUniqueUnionType(TypeAttributes_1.emptyTypeAttributes, new Set(reconstitutedTypes));
        }
        return builder.getMapType(attributes, union, forwardingRef);
      }
      const allObjectTypes = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t.kind === "object");
      const objectTypesToReplace = leaveFullObjects ? (0, collection_utils_1.setFilter)(allObjectTypes, (o) => o.getProperties().size === 0 || o.getAdditionalProperties() === void 0) : allObjectTypes;
      const groups = Array.from(objectTypesToReplace).map((t) => [t]);
      return graph.rewrite("replace object type", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
    }
    exports.replaceObjectType = replaceObjectType;
  }
});

// node_modules/quicktype-core/dist/rewrites/ResolveIntersections.js
var require_ResolveIntersections = __commonJS({
  "node_modules/quicktype-core/dist/rewrites/ResolveIntersections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveIntersections = void 0;
    var collection_utils_1 = require_dist();
    var TypeAttributes_1 = require_TypeAttributes();
    var Support_1 = require_Support();
    var Type_1 = require_Type();
    var TypeUtils_1 = require_TypeUtils();
    var UnionBuilder_1 = require_UnionBuilder();
    function canResolve(t) {
      const members = (0, TypeUtils_1.setOperationMembersRecursively)(t, void 0)[0];
      if (members.size <= 1)
        return true;
      return (0, collection_utils_1.iterableEvery)(members, (m) => !(m instanceof Type_1.UnionType) || m.isCanonical);
    }
    function attributesForTypes(types) {
      return (0, collection_utils_1.mapMapEntries)(types.entries(), (t) => [t.kind, t.getAttributes()]);
    }
    var IntersectionAccumulator = class {
      constructor() {
        this._primitiveAttributes = /* @__PURE__ */ new Map();
        this._arrayAttributes = TypeAttributes_1.emptyTypeAttributes;
        this._objectProperties = /* @__PURE__ */ new Map();
        this._objectAttributes = TypeAttributes_1.emptyTypeAttributes;
        this._additionalPropertyTypes = /* @__PURE__ */ new Set();
        this._lostTypeAttributes = false;
      }
      updatePrimitiveTypes(members) {
        const types = (0, collection_utils_1.setFilter)(members, (t) => (0, Type_1.isPrimitiveTypeKind)(t.kind));
        const attributes = attributesForTypes(types);
        (0, collection_utils_1.mapMergeWithInto)(this._primitiveAttributes, (a, b) => (0, TypeAttributes_1.combineTypeAttributes)("intersect", a, b), attributes);
        const kinds = (0, collection_utils_1.setMap)(types, (t) => t.kind);
        if (this._primitiveTypes === void 0) {
          this._primitiveTypes = new Set(kinds);
          return;
        }
        const haveNumber = (0, collection_utils_1.iterableFind)(this._primitiveTypes, Type_1.isNumberTypeKind) !== void 0 && (0, collection_utils_1.iterableFind)(kinds, Type_1.isNumberTypeKind) !== void 0;
        this._primitiveTypes = (0, collection_utils_1.setIntersect)(this._primitiveTypes, kinds);
        if (haveNumber && (0, collection_utils_1.iterableFind)(this._primitiveTypes, Type_1.isNumberTypeKind) === void 0) {
          this._primitiveTypes = this._primitiveTypes.add("integer");
        }
      }
      updateArrayItemTypes(members) {
        const maybeArray = (0, collection_utils_1.iterableFind)(members, (t) => t instanceof Type_1.ArrayType);
        if (maybeArray === void 0) {
          this._arrayItemTypes = false;
          return;
        }
        this._arrayAttributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", this._arrayAttributes, maybeArray.getAttributes());
        if (this._arrayItemTypes === void 0) {
          this._arrayItemTypes = /* @__PURE__ */ new Set();
        } else if (this._arrayItemTypes !== false) {
          this._arrayItemTypes.add(maybeArray.items);
        }
      }
      updateObjectProperties(members) {
        const maybeObject = (0, collection_utils_1.iterableFind)(members, (t) => t instanceof Type_1.ObjectType);
        if (maybeObject === void 0) {
          this._objectProperties = void 0;
          this._additionalPropertyTypes = void 0;
          return;
        }
        this._objectAttributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", this._objectAttributes, maybeObject.getAttributes());
        const objectAdditionalProperties = maybeObject.getAdditionalProperties();
        if (this._objectProperties === void 0) {
          (0, Support_1.assert)(this._additionalPropertyTypes === void 0);
          return;
        }
        const allPropertyNames = (0, collection_utils_1.setUnionInto)(new Set(this._objectProperties.keys()), maybeObject.getProperties().keys());
        for (const name of allPropertyNames) {
          const existing = (0, Support_1.defined)(this._objectProperties).get(name);
          const newProperty = maybeObject.getProperties().get(name);
          if (existing !== void 0 && newProperty !== void 0) {
            const cp = new Type_1.GenericClassProperty(existing.typeData.add(newProperty.type), existing.isOptional && newProperty.isOptional);
            (0, Support_1.defined)(this._objectProperties).set(name, cp);
          } else if (existing !== void 0 && objectAdditionalProperties !== void 0) {
            const cp = new Type_1.GenericClassProperty(existing.typeData.add(objectAdditionalProperties), existing.isOptional);
            (0, Support_1.defined)(this._objectProperties).set(name, cp);
          } else if (existing !== void 0) {
            (0, Support_1.defined)(this._objectProperties).delete(name);
          } else if (newProperty !== void 0 && this._additionalPropertyTypes !== void 0) {
            const types = new Set(this._additionalPropertyTypes).add(newProperty.type);
            (0, Support_1.defined)(this._objectProperties).set(name, new Type_1.GenericClassProperty(types, newProperty.isOptional));
          } else if (newProperty !== void 0) {
            (0, Support_1.defined)(this._objectProperties).delete(name);
          } else {
            return (0, Support_1.mustNotHappen)();
          }
        }
        if (this._additionalPropertyTypes !== void 0 && objectAdditionalProperties !== void 0) {
          this._additionalPropertyTypes.add(objectAdditionalProperties);
        } else if (this._additionalPropertyTypes !== void 0 || objectAdditionalProperties !== void 0) {
          this._additionalPropertyTypes = void 0;
          this._lostTypeAttributes = true;
        }
      }
      addUnionSet(members) {
        this.updatePrimitiveTypes(members);
        this.updateArrayItemTypes(members);
        this.updateObjectProperties(members);
      }
      addType(t) {
        let attributes = t.getAttributes();
        (0, TypeUtils_1.matchTypeExhaustive)(t, (_noneType) => {
          return (0, Support_1.panic)("There shouldn't be a none type");
        }, (_anyType) => {
          return (0, Support_1.panic)("The any type should have been filtered out in setOperationMembersRecursively");
        }, (nullType) => this.addUnionSet([nullType]), (boolType) => this.addUnionSet([boolType]), (integerType) => this.addUnionSet([integerType]), (doubleType) => this.addUnionSet([doubleType]), (stringType) => this.addUnionSet([stringType]), (arrayType) => this.addUnionSet([arrayType]), (_classType) => (0, Support_1.panic)("We should never see class types in intersections"), (_mapType) => (0, Support_1.panic)("We should never see map types in intersections"), (objectType) => this.addUnionSet([objectType]), (_enumType) => (0, Support_1.panic)("We should never see enum types in intersections"), (unionType) => {
          attributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", [attributes].concat(Array.from(unionType.members).map((m) => m.getAttributes())));
          this.addUnionSet(unionType.members);
        }, (transformedStringType) => this.addUnionSet([transformedStringType]));
        return (0, TypeAttributes_1.makeTypeAttributesInferred)(attributes);
      }
      get arrayData() {
        if (this._arrayItemTypes === void 0 || this._arrayItemTypes === false) {
          return (0, Support_1.panic)("This should not be called if the type can't be an array");
        }
        return this._arrayItemTypes;
      }
      get objectData() {
        if (this._objectProperties === void 0) {
          (0, Support_1.assert)(this._additionalPropertyTypes === void 0);
          return void 0;
        }
        return [this._objectProperties, this._additionalPropertyTypes];
      }
      get enumCases() {
        return (0, Support_1.panic)("We don't support enums in intersections");
      }
      getMemberKinds() {
        const kinds = (0, collection_utils_1.mapMap)((0, Support_1.defined)(this._primitiveTypes).entries(), (k) => (0, Support_1.defined)(this._primitiveAttributes.get(k)));
        const maybeDoubleAttributes = this._primitiveAttributes.get("double");
        if (maybeDoubleAttributes !== void 0 && !kinds.has("double") && kinds.has("integer")) {
          (0, collection_utils_1.mapUpdateInto)(kinds, "integer", (a) => {
            return (0, TypeAttributes_1.combineTypeAttributes)("intersect", (0, Support_1.defined)(a), maybeDoubleAttributes);
          });
        }
        if (this._arrayItemTypes !== void 0 && this._arrayItemTypes !== false) {
          kinds.set("array", this._arrayAttributes);
        } else if (this._arrayAttributes.size > 0) {
          this._lostTypeAttributes = true;
        }
        if (this._objectProperties !== void 0) {
          kinds.set("object", this._objectAttributes);
        } else if (this._objectAttributes.size > 0) {
          this._lostTypeAttributes = true;
        }
        return kinds;
      }
      get lostTypeAttributes() {
        return this._lostTypeAttributes;
      }
    };
    var IntersectionUnionBuilder = class extends UnionBuilder_1.UnionBuilder {
      constructor() {
        super(...arguments);
        this._createdNewIntersections = false;
      }
      makeIntersection(members, attributes) {
        const reconstitutedMembers = (0, collection_utils_1.setMap)(members, (t) => this.typeBuilder.reconstituteTypeRef(t.typeRef));
        const first = (0, Support_1.defined)((0, collection_utils_1.iterableFirst)(reconstitutedMembers));
        if (reconstitutedMembers.size === 1) {
          this.typeBuilder.addAttributes(first, attributes);
          return first;
        }
        this._createdNewIntersections = true;
        return this.typeBuilder.getUniqueIntersectionType(attributes, reconstitutedMembers);
      }
      get createdNewIntersections() {
        return this._createdNewIntersections;
      }
      makeObject(maybeData, typeAttributes, forwardingRef) {
        if (maybeData === void 0) {
          return (0, Support_1.panic)("Either properties or additional properties must be given to make an object type");
        }
        const [propertyTypes, maybeAdditionalProperties] = maybeData;
        const properties = (0, collection_utils_1.mapMap)(propertyTypes, (cp) => this.typeBuilder.makeClassProperty(this.makeIntersection(cp.typeData, TypeAttributes_1.emptyTypeAttributes), cp.isOptional));
        const additionalProperties = maybeAdditionalProperties === void 0 ? void 0 : this.makeIntersection(maybeAdditionalProperties, TypeAttributes_1.emptyTypeAttributes);
        return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
      }
      makeArray(arrays, typeAttributes, forwardingRef) {
        const itemsType = this.makeIntersection(arrays, TypeAttributes_1.emptyTypeAttributes);
        const tref = this.typeBuilder.getArrayType(typeAttributes, itemsType, forwardingRef);
        return tref;
      }
    };
    function resolveIntersections(graph, stringTypeMapping, debugPrintReconstitution) {
      let needsRepeat = false;
      function replace(types, builder, forwardingRef) {
        const intersections = (0, collection_utils_1.setFilter)(types, (t) => t instanceof Type_1.IntersectionType);
        const [members, intersectionAttributes] = (0, TypeUtils_1.setOperationMembersRecursively)(Array.from(intersections), "intersect");
        if (members.size === 0) {
          const t = builder.getPrimitiveType("any", intersectionAttributes, forwardingRef);
          return t;
        }
        if (members.size === 1) {
          return builder.reconstituteType((0, Support_1.defined)((0, collection_utils_1.iterableFirst)(members)), intersectionAttributes, forwardingRef);
        }
        const accumulator = new IntersectionAccumulator();
        const extraAttributes = (0, TypeAttributes_1.makeTypeAttributesInferred)((0, TypeAttributes_1.combineTypeAttributes)("intersect", Array.from(members).map((t) => accumulator.addType(t))));
        const attributes = (0, TypeAttributes_1.combineTypeAttributes)("intersect", intersectionAttributes, extraAttributes);
        const unionBuilder = new IntersectionUnionBuilder(builder);
        const tref = unionBuilder.buildUnion(accumulator, true, attributes, forwardingRef);
        if (unionBuilder.createdNewIntersections) {
          needsRepeat = true;
        }
        return tref;
      }
      const allIntersections = (0, collection_utils_1.setFilter)(graph.allTypesUnordered(), (t) => t instanceof Type_1.IntersectionType);
      const resolvableIntersections = (0, collection_utils_1.setFilter)(allIntersections, canResolve);
      const groups = (0, TypeUtils_1.makeGroupsToFlatten)(resolvableIntersections, void 0);
      graph = graph.rewrite("resolve intersections", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
      return [graph, !needsRepeat && allIntersections.size === resolvableIntersections.size];
    }
    exports.resolveIntersections = resolveIntersections;
  }
});

// node_modules/quicktype-core/dist/Run.js
var require_Run = __commonJS({
  "node_modules/quicktype-core/dist/Run.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.quicktype = exports.combineRenderResults = exports.quicktypeMultiFileSync = exports.quicktypeMultiFile = exports.defaultInferenceFlags = exports.inferenceFlags = exports.inferenceFlagNames = exports.inferenceFlagsObject = exports.getTargetLanguage = void 0;
    var collection_utils_1 = require_dist();
    var TypeNames_1 = require_TypeNames();
    var GatherNames_1 = require_GatherNames();
    var Inputs_1 = require_Inputs();
    var targetLanguages = __importStar(require_All());
    var MakeTransformations_1 = require_MakeTransformations();
    var Messages_1 = require_Messages();
    var CombineClasses_1 = require_CombineClasses();
    var ExpandStrings_1 = require_ExpandStrings();
    var FlattenStrings_1 = require_FlattenStrings();
    var FlattenUnions_1 = require_FlattenUnions();
    var InferMaps_1 = require_InferMaps();
    var ReplaceObjectType_1 = require_ReplaceObjectType();
    var ResolveIntersections_1 = require_ResolveIntersections();
    var Support_1 = require_Support();
    var TypeBuilder_1 = require_TypeBuilder();
    var TypeGraph_1 = require_TypeGraph();
    function getTargetLanguage(nameOrInstance) {
      if (typeof nameOrInstance === "object") {
        return nameOrInstance;
      }
      const language = targetLanguages.languageNamed(nameOrInstance);
      if (language !== void 0) {
        return language;
      }
      return (0, Messages_1.messageError)("DriverUnknownOutputLanguage", { lang: nameOrInstance });
    }
    exports.getTargetLanguage = getTargetLanguage;
    exports.inferenceFlagsObject = {
      /** Whether to infer map types from JSON data */
      inferMaps: {
        description: "Detect maps",
        negationDescription: "Don't infer maps, always use classes",
        explanation: "Infer maps when object keys look like map keys.",
        order: 1
      },
      /** Whether to infer enum types from JSON data */
      inferEnums: {
        description: "Detect enums",
        negationDescription: "Don't infer enums, always use strings",
        explanation: "If string values occur within a relatively small domain,\ninfer them as enum values.",
        order: 2
      },
      /** Whether to convert UUID strings to UUID objects */
      inferUuids: {
        description: "Detect UUIDs",
        negationDescription: "Don't convert UUIDs to UUID objects",
        explanation: "Detect UUIDs like '123e4567-e89b-12d3-a456-426655440000' (partial support).",
        stringType: "uuid",
        order: 3
      },
      /** Whether to assume that JSON strings that look like dates are dates */
      inferDateTimes: {
        description: "Detect dates & times",
        negationDescription: "Don't infer dates or times",
        explanation: "Infer dates from strings (partial support).",
        stringType: "date-time",
        order: 4
      },
      /** Whether to convert stringified integers to integers */
      inferIntegerStrings: {
        description: "Detect integers in strings",
        negationDescription: "Don't convert stringified integers to integers",
        explanation: 'Automatically convert stringified integers to integers.\nFor example, "1" is converted to 1.',
        stringType: "integer-string",
        order: 5
      },
      /** Whether to convert stringified booleans to boolean values */
      inferBooleanStrings: {
        description: "Detect booleans in strings",
        negationDescription: "Don't convert stringified booleans to booleans",
        explanation: 'Automatically convert stringified booleans to booleans.\nFor example, "true" is converted to true.',
        stringType: "bool-string",
        order: 6
      },
      /** Combine similar classes.  This doesn't apply to classes from a schema, only from inference. */
      combineClasses: {
        description: "Merge similar classes",
        negationDescription: "Don't combine similar classes",
        explanation: "Combine classes with significantly overlapping properties,\ntreating contingent properties as nullable.",
        order: 7
      },
      /** Whether to treat $ref as references within JSON */
      ignoreJsonRefs: {
        description: "Don't treat $ref as a reference in JSON",
        negationDescription: "Treat $ref as a reference in JSON",
        explanation: `Like in JSON Schema, allow objects like
'{ $ref: "#/foo/bar" }' to refer
to another part of the input.`,
        order: 8
      }
    };
    exports.inferenceFlagNames = Object.getOwnPropertyNames(exports.inferenceFlagsObject);
    exports.inferenceFlags = exports.inferenceFlagsObject;
    var defaultOptions = {
      lang: "ts",
      inputData: new Inputs_1.InputData(),
      alphabetizeProperties: false,
      allPropertiesOptional: false,
      fixedTopLevels: false,
      noRender: false,
      leadingComments: void 0,
      rendererOptions: {},
      indentation: void 0,
      outputFilename: "stdout",
      debugPrintGraph: false,
      checkProvenance: false,
      debugPrintReconstitution: false,
      debugPrintGatherNames: false,
      debugPrintTransformations: false,
      debugPrintTimes: false,
      debugPrintSchemaResolving: false
    };
    function makeDefaultInferenceFlags() {
      const flags = {};
      for (const flag of exports.inferenceFlagNames) {
        flags[flag] = true;
      }
      return flags;
    }
    exports.defaultInferenceFlags = makeDefaultInferenceFlags();
    var Run = class {
      constructor(options) {
        this._options = Object.assign({}, defaultOptions, exports.defaultInferenceFlags);
        for (const k of Object.getOwnPropertyNames(options)) {
          const v = options[k];
          if (v !== void 0) {
            this._options[k] = v;
          }
        }
      }
      get stringTypeMapping() {
        const targetLanguage = getTargetLanguage(this._options.lang);
        const mapping = new Map(targetLanguage.stringTypeMapping);
        for (const flag of exports.inferenceFlagNames) {
          const stringType = exports.inferenceFlags[flag].stringType;
          if (!this._options[flag] && stringType !== void 0) {
            mapping.set(stringType, "string");
          }
        }
        return mapping;
      }
      get debugPrintReconstitution() {
        return this._options.debugPrintReconstitution === true;
      }
      get debugPrintTransformations() {
        return this._options.debugPrintTransformations;
      }
      get debugPrintSchemaResolving() {
        return this._options.debugPrintSchemaResolving;
      }
      timeSync(name, f) {
        return __awaiter(this, void 0, void 0, function* () {
          const start = Date.now();
          const result = yield f();
          const end = Date.now();
          if (this._options.debugPrintTimes) {
            console.log(`${name} took ${end - start}ms`);
          }
          return result;
        });
      }
      time(name, f) {
        const start = Date.now();
        const result = f();
        const end = Date.now();
        if (this._options.debugPrintTimes) {
          console.log(`${name} took ${end - start}ms`);
        }
        return result;
      }
      makeGraphInputs() {
        const targetLanguage = getTargetLanguage(this._options.lang);
        const stringTypeMapping = this.stringTypeMapping;
        const conflateNumbers = !targetLanguage.supportsUnionsWithBothNumberTypes;
        const typeBuilder = new TypeBuilder_1.TypeBuilder(0, stringTypeMapping, this._options.alphabetizeProperties, this._options.allPropertiesOptional, this._options.checkProvenance, false);
        return { targetLanguage, stringTypeMapping, conflateNumbers, typeBuilder };
      }
      makeGraph(allInputs) {
        return __awaiter(this, void 0, void 0, function* () {
          const graphInputs = this.makeGraphInputs();
          yield this.timeSync("read input", () => __awaiter(this, void 0, void 0, function* () {
            return yield allInputs.addTypes(this, graphInputs.typeBuilder, this._options.inferMaps, this._options.inferEnums, this._options.fixedTopLevels);
          }));
          return this.processGraph(allInputs, graphInputs);
        });
      }
      makeGraphSync(allInputs) {
        const graphInputs = this.makeGraphInputs();
        this.time("read input", () => allInputs.addTypesSync(this, graphInputs.typeBuilder, this._options.inferMaps, this._options.inferEnums, this._options.fixedTopLevels));
        return this.processGraph(allInputs, graphInputs);
      }
      processGraph(allInputs, graphInputs) {
        const { targetLanguage, stringTypeMapping, conflateNumbers, typeBuilder } = graphInputs;
        let graph = typeBuilder.finish();
        if (this._options.debugPrintGraph) {
          graph.setPrintOnRewrite();
          graph.printGraph();
        }
        const debugPrintReconstitution = this.debugPrintReconstitution;
        if (typeBuilder.didAddForwardingIntersection || !this._options.ignoreJsonRefs) {
          this.time("remove indirection intersections", () => graph = (0, TypeGraph_1.removeIndirectionIntersections)(graph, stringTypeMapping, debugPrintReconstitution));
        }
        let unionsDone = false;
        if (allInputs.needSchemaProcessing || !this._options.ignoreJsonRefs) {
          let intersectionsDone = false;
          do {
            const graphBeforeRewrites = graph;
            if (!intersectionsDone) {
              this.time("resolve intersections", () => [graph, intersectionsDone] = (0, ResolveIntersections_1.resolveIntersections)(graph, stringTypeMapping, debugPrintReconstitution));
            }
            if (!unionsDone) {
              this.time("flatten unions", () => [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, true, debugPrintReconstitution));
            }
            if (graph === graphBeforeRewrites) {
              (0, Support_1.assert)(intersectionsDone && unionsDone, "Graph didn't change but we're not done");
            }
          } while (!intersectionsDone || !unionsDone);
        }
        this.time("replace object type", () => graph = (0, ReplaceObjectType_1.replaceObjectType)(graph, stringTypeMapping, conflateNumbers, targetLanguage.supportsFullObjectType, debugPrintReconstitution));
        do {
          this.time("flatten unions", () => [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution));
        } while (!unionsDone);
        if (this._options.combineClasses) {
          const combinedGraph = this.time("combine classes", () => (0, CombineClasses_1.combineClasses)(this, graph, this._options.alphabetizeProperties, true, false, debugPrintReconstitution));
          if (combinedGraph === graph) {
            graph = combinedGraph;
          } else {
            this.time("combine classes cleanup", () => graph = (0, CombineClasses_1.combineClasses)(this, combinedGraph, this._options.alphabetizeProperties, false, true, debugPrintReconstitution));
          }
        }
        if (this._options.inferMaps) {
          for (; ; ) {
            const newGraph = this.time("infer maps", () => (0, InferMaps_1.inferMaps)(graph, stringTypeMapping, true, debugPrintReconstitution));
            if (newGraph === graph) {
              break;
            }
            graph = newGraph;
          }
        }
        const enumInference = allInputs.needSchemaProcessing ? "all" : this._options.inferEnums ? "infer" : "none";
        this.time("expand strings", () => graph = (0, ExpandStrings_1.expandStrings)(this, graph, enumInference));
        this.time("flatten unions", () => [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution));
        (0, Support_1.assert)(unionsDone, "We should only have to flatten unions once after expanding strings");
        if (allInputs.needSchemaProcessing) {
          this.time("flatten strings", () => graph = (0, FlattenStrings_1.flattenStrings)(graph, stringTypeMapping, debugPrintReconstitution));
        }
        this.time("none to any", () => graph = (0, TypeGraph_1.noneToAny)(graph, stringTypeMapping, debugPrintReconstitution));
        if (!targetLanguage.supportsOptionalClassProperties) {
          this.time("optional to nullable", () => graph = (0, TypeGraph_1.optionalToNullable)(graph, stringTypeMapping, debugPrintReconstitution));
        }
        this.time("fixed point", () => graph = graph.rewriteFixedPoint(false, debugPrintReconstitution));
        this.time("make transformations", () => graph = (0, MakeTransformations_1.makeTransformations)(this, graph, targetLanguage));
        this.time("flatten unions", () => [graph, unionsDone] = (0, FlattenUnions_1.flattenUnions)(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution));
        (0, Support_1.assert)(unionsDone, "We should only have to flatten unions once after making transformations");
        this.time("GC", () => graph = graph.garbageCollect(this._options.alphabetizeProperties, debugPrintReconstitution));
        if (this._options.debugPrintGraph) {
          console.log("\n# gather names");
        }
        this.time("gather names", () => (0, GatherNames_1.gatherNames)(graph, !allInputs.needSchemaProcessing, this._options.debugPrintGatherNames));
        if (this._options.debugPrintGraph) {
          graph.printGraph();
        }
        return graph;
      }
      makeSimpleTextResult(lines) {
        return /* @__PURE__ */ new Map([[this._options.outputFilename, { lines, annotations: [] }]]);
      }
      preRun() {
        (0, TypeNames_1.initTypeNames)();
        const targetLanguage = getTargetLanguage(this._options.lang);
        const inputData = this._options.inputData;
        const needIR = inputData.needIR || !targetLanguage.names.includes("schema");
        const schemaString = needIR ? void 0 : inputData.singleStringSchemaSource();
        if (schemaString !== void 0) {
          const lines = JSON.stringify(JSON.parse(schemaString), void 0, 4).split("\n");
          lines.push("");
          const srr = { lines, annotations: [] };
          return /* @__PURE__ */ new Map([[this._options.outputFilename, srr]]);
        }
        return [inputData, targetLanguage];
      }
      run() {
        return __awaiter(this, void 0, void 0, function* () {
          const preRunResult = this.preRun();
          if (!Array.isArray(preRunResult)) {
            return preRunResult;
          }
          const [inputData, targetLanguage] = preRunResult;
          const graph = yield this.makeGraph(inputData);
          return this.renderGraph(targetLanguage, graph);
        });
      }
      runSync() {
        const preRunResult = this.preRun();
        if (!Array.isArray(preRunResult)) {
          return preRunResult;
        }
        const [inputData, targetLanguage] = preRunResult;
        const graph = this.makeGraphSync(inputData);
        return this.renderGraph(targetLanguage, graph);
      }
      renderGraph(targetLanguage, graph) {
        if (this._options.noRender) {
          return this.makeSimpleTextResult(["Done.", ""]);
        }
        return targetLanguage.renderGraphAndSerialize(graph, this._options.outputFilename, this._options.alphabetizeProperties, this._options.leadingComments, this._options.rendererOptions, this._options.indentation);
      }
    };
    function quicktypeMultiFile(options) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield new Run(options).run();
      });
    }
    exports.quicktypeMultiFile = quicktypeMultiFile;
    function quicktypeMultiFileSync(options) {
      return new Run(options).runSync();
    }
    exports.quicktypeMultiFileSync = quicktypeMultiFileSync;
    function offsetLocation(loc, lineOffset) {
      return { line: loc.line + lineOffset, column: loc.column };
    }
    function offsetSpan(span, lineOffset) {
      return { start: offsetLocation(span.start, lineOffset), end: offsetLocation(span.end, lineOffset) };
    }
    function combineRenderResults(result) {
      if (result.size <= 1) {
        const first = (0, collection_utils_1.mapFirst)(result);
        if (first === void 0) {
          return { lines: [], annotations: [] };
        }
        return first;
      }
      let lines = [];
      let annotations = [];
      for (const [filename, srr] of result) {
        const offset = lines.length + 2;
        lines = lines.concat([`// ${filename}`, ""], srr.lines);
        annotations = annotations.concat(srr.annotations.map((ann) => ({ annotation: ann.annotation, span: offsetSpan(ann.span, offset) })));
      }
      return { lines, annotations };
    }
    exports.combineRenderResults = combineRenderResults;
    function quicktype(options) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield quicktypeMultiFile(options);
        return combineRenderResults(result);
      });
    }
    exports.quicktype = quicktype;
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string2, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string2, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string2.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string2, offset, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string2, offset, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length);
    }
    function base64Write(buf, string2, offset, length) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length);
    }
    function ucs2Write(buf, string2, offset, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string2, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length);
          case "base64":
            return base64Write(this, string2, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string2.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    module.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    var { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController;
    module.exports.AbortSignal = AbortSignal;
    module.exports.default = AbortController;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    var bufferModule = require_buffer();
    var { kResistStopPropagation, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_browser().AbortSignal;
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    var { format, inspect, AggregateError: CustomAggregateError } = require_util();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE2(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/browser.js
var require_browser2 = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    var process2 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop() {
    }
    process2.on = noop;
    process2.addListener = noop;
    process2.once = noop;
    process2.off = noop;
    process2.removeListener = noop;
    process2.removeAllListeners = noop;
    process2.emit = noop;
    process2.prependListener = noop;
    process2.prependOnceListener = noop;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    var process2 = require_browser2();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var process2 = require_browser2();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { inspect } = require_util();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "ï¿½";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "ï¿½";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "ï¿½";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "ï¿½";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    var process2 = require_browser2();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    var process2 = require_browser2();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value)
            this.state |= bit;
          else
            this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if ((state.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0)
          state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process2.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process2.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    var process2 = require_browser2();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require_buffer();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process2.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process2.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process2.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    var process2 = require_browser2();
    var bufferModule = require_buffer();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE2(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex;
    var Readable = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    var process2 = require_browser2();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils();
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var PassThrough;
    var Readable;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    var AbortController = globalThis.AbortController || require_browser().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var { deprecate } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map2(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return (async function* map3() {
        const signal = require_util().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }).call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }).call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map2.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map2.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map2.call(this, fn, options);
      return (async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }).call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }).call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }).call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map: map2,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports, module) {
    var { Buffer: Buffer2 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream = module.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/browser.js
var require_browser3 = __commonJS({
  "node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    var CustomStream = require_stream();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/quicktype-core/dist/input/io/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/quicktype-core/dist/input/io/get-stream/buffer-stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var readable_stream_1 = require_browser3();
    function bufferStream(opts) {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = void 0;
      }
      let len = 0;
      const ret = [];
      const stream = new readable_stream_1.PassThrough({
        objectMode
      });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream.getBufferedLength = () => len;
      return stream;
    }
    exports.default = bufferStream;
  }
});

// node_modules/quicktype-core/dist/input/io/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/quicktype-core/dist/input/io/get-stream/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.array = exports.buffer = exports.getStream = void 0;
    var buffer_stream_1 = __importDefault(require_buffer_stream());
    function getStream(inputStream, opts = {}) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        if (!inputStream) {
          return yield Promise.reject(new Error("Expected a stream"));
        }
        opts = Object.assign({ maxBuffer: Infinity }, opts);
        const maxBuffer = (_a = opts.maxBuffer) !== null && _a !== void 0 ? _a : Infinity;
        let stream;
        let clean;
        const p = new Promise((resolve, reject) => {
          const error = (err) => {
            if (err) {
              err.bufferedData = stream.getBufferedValue();
            }
            reject(err);
          };
          stream = (0, buffer_stream_1.default)(opts);
          inputStream.once("error", error);
          inputStream.pipe(stream);
          stream.on("data", () => {
            if (stream.getBufferedLength() > maxBuffer) {
              reject(new Error("maxBuffer exceeded"));
            }
          });
          stream.once("error", error);
          stream.on("end", resolve);
          clean = () => {
            if (inputStream.unpipe) {
              inputStream.unpipe(stream);
            }
          };
        });
        return yield p.then(clean, clean).then(() => stream.getBufferedValue());
      });
    }
    exports.getStream = getStream;
    function buffer(stream, opts = {}) {
      void getStream(stream, Object.assign({}, opts, { encoding: "buffer" }));
    }
    exports.buffer = buffer;
    function array(stream, opts = {}) {
      void getStream(stream, Object.assign({}, opts, { array: true }));
    }
    exports.array = array;
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/browser-or-node/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/browser-or-node/dist/index.js"(exports, module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      isBrowser: () => isBrowser,
      isBun: () => isBun,
      isDeno: () => isDeno,
      isJsDom: () => isJsDom,
      isNode: () => isNode2,
      isWebWorker: () => isWebWorker
    });
    module.exports = __toCommonJS2(src_exports);
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    var isNode2 = (
      // @ts-expect-error
      typeof process !== "undefined" && // @ts-expect-error
      process.versions != null && // @ts-expect-error
      process.versions.node != null
    );
    var isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
    var isJsDom = typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && "userAgent" in navigator && typeof navigator.userAgent === "string" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
    var isDeno = (
      // @ts-expect-error
      typeof Deno !== "undefined" && // @ts-expect-error
      typeof Deno.version !== "undefined" && // @ts-expect-error
      typeof Deno.version.deno !== "undefined"
    );
    var isBun = typeof process !== "undefined" && process.versions != null && process.versions.bun != null;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var global2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
        var support = {
          searchParams: "URLSearchParams" in global2,
          iterable: "Symbol" in global2 && "iterator" in Symbol,
          blob: "FileReader" in global2 && "Blob" in global2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in global2,
          arrayBuffer: "ArrayBuffer" in global2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                  return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                  return Promise.resolve(
                    this._bodyArrayBuffer.buffer.slice(
                      this._bodyArrayBuffer.byteOffset,
                      this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                    )
                  );
                } else {
                  return Promise.resolve(this._bodyArrayBuffer);
                }
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = global2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && global2.location.href ? global2.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!global2.fetch) {
          global2.fetch = fetch;
          global2.Headers = Headers;
          global2.Request = Request;
          global2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/is-url/index.js
var require_is_url = __commonJS({
  "node_modules/is-url/index.js"(exports, module) {
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string2) {
      if (typeof string2 !== "string") {
        return false;
      }
      var match = string2.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// node_modules/quicktype-core/dist/input/io/NodeIO.js
var require_NodeIO = __commonJS({
  "node_modules/quicktype-core/dist/input/io/NodeIO.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readFromFileOrURL = exports.readableFromFileOrURL = void 0;
    var fs = __importStar(require_fs());
    var ts_necessities_1 = require_dist2();
    var browser_or_node_1 = require_dist3();
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var is_url_1 = __importDefault(require_is_url());
    var index_1 = require_dist4();
    var get_stream_1 = require_get_stream();
    var fetch = process.env.CI ? cross_fetch_1.default : (_a = global.fetch) !== null && _a !== void 0 ? _a : cross_fetch_1.default;
    function parseHeaders(httpHeaders) {
      if (!Array.isArray(httpHeaders)) {
        return {};
      }
      return httpHeaders.reduce(function(result, httpHeader) {
        if (httpHeader !== void 0 && httpHeader.length > 0) {
          const split = httpHeader.indexOf(":");
          if (split < 0) {
            return (0, index_1.panic)(`Could not parse HTTP header "${httpHeader}".`);
          }
          const key = httpHeader.slice(0, split).trim();
          const value = httpHeader.slice(split + 1).trim();
          result[key] = value;
        }
        return result;
      }, {});
    }
    function readableFromFileOrURL(fileOrURL, httpHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if ((0, is_url_1.default)(fileOrURL)) {
            const response = yield fetch(fileOrURL, {
              headers: parseHeaders(httpHeaders)
            });
            return (0, ts_necessities_1.defined)(response.body);
          } else if (browser_or_node_1.isNode) {
            if (fileOrURL === "-") {
              return process.stdin;
            }
            const filePath = fs.lstatSync(fileOrURL).isSymbolicLink() ? fs.readlinkSync(fileOrURL) : fileOrURL;
            if (fs.existsSync(filePath)) {
              return fs.createReadStream(filePath, "utf8");
            }
          }
        } catch (e) {
          return (0, index_1.messageError)("MiscReadError", { fileOrURL, message: (0, ts_necessities_1.exceptionToString)(e) });
        }
        return (0, index_1.messageError)("DriverInputFileDoesNotExist", { filename: fileOrURL });
      });
    }
    exports.readableFromFileOrURL = readableFromFileOrURL;
    function readFromFileOrURL(fileOrURL, httpHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        const readable = yield readableFromFileOrURL(fileOrURL, httpHeaders);
        try {
          return yield (0, get_stream_1.getStream)(readable);
        } catch (e) {
          return (0, index_1.messageError)("MiscReadError", { fileOrURL, message: (0, ts_necessities_1.exceptionToString)(e) });
        }
      });
    }
    exports.readFromFileOrURL = readFromFileOrURL;
  }
});

// node_modules/quicktype-core/dist/input/FetchingJSONSchemaStore.js
var require_FetchingJSONSchemaStore = __commonJS({
  "node_modules/quicktype-core/dist/input/FetchingJSONSchemaStore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchingJSONSchemaStore = void 0;
    var __1 = require_dist4();
    var NodeIO_1 = require_NodeIO();
    var JSONSchemaStore_1 = require_JSONSchemaStore();
    var FetchingJSONSchemaStore = class extends JSONSchemaStore_1.JSONSchemaStore {
      constructor(_httpHeaders) {
        super();
        this._httpHeaders = _httpHeaders;
      }
      fetch(address) {
        return __awaiter(this, void 0, void 0, function* () {
          return (0, __1.parseJSON)(yield (0, NodeIO_1.readFromFileOrURL)(address, this._httpHeaders), "JSON Schema", address);
        });
      }
    };
    exports.FetchingJSONSchemaStore = FetchingJSONSchemaStore;
  }
});

// node_modules/quicktype-core/dist/input/PostmanCollection.js
var require_PostmanCollection = __commonJS({
  "node_modules/quicktype-core/dist/input/PostmanCollection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sourcesFromPostmanCollection = void 0;
    var Support_1 = require_Support();
    function isValidJSON(s) {
      try {
        JSON.parse(s);
        return true;
      } catch (error) {
        return false;
      }
    }
    function sourcesFromPostmanCollection(collectionJSON, collectionJSONAddress) {
      const sources = [];
      const descriptions = [];
      function processCollection(c) {
        if (typeof c !== "object")
          return;
        if (Array.isArray(c.item)) {
          for (const item of c.item) {
            processCollection(item);
          }
          if (typeof c.info === "object" && typeof c.info.description === "string") {
            descriptions.push(c.info.description);
          }
        }
        if (typeof c.name === "string" && Array.isArray(c.response)) {
          const samples = [];
          for (const r of c.response) {
            if (typeof r === "object" && typeof r.body === "string" && isValidJSON(r.body)) {
              samples.push(r.body);
            }
          }
          if (samples.length > 0) {
            const source = { name: c.name, samples };
            const sourceDescription = [c.name];
            if (typeof c.request === "object") {
              const { method, url } = c.request;
              if (method !== void 0 && typeof url === "object" && url.raw !== void 0) {
                sourceDescription.push(`${method} ${url.raw}`);
              }
            }
            if (typeof c.request === "object" && typeof c.request.description === "string") {
              sourceDescription.push(c.request.description);
            }
            source.description = sourceDescription.length === 0 ? void 0 : sourceDescription.join("\n\n");
            sources.push(source);
          }
        }
      }
      processCollection((0, Support_1.parseJSON)(collectionJSON, "Postman collection", collectionJSONAddress));
      const joinedDescription = descriptions.join("\n\n").trim();
      let description = void 0;
      if (joinedDescription !== "") {
        description = joinedDescription;
      }
      return { sources, description };
    }
    exports.sourcesFromPostmanCollection = sourcesFromPostmanCollection;
  }
});

// node_modules/quicktype-core/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/quicktype-core/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassType = exports.ArrayType = exports.PrimitiveType = exports.Type = exports.messageAssert = exports.messageError = exports.QuickTypeError = exports.trainMarkovChain = exports.isLetterOrDigit = exports.legalizeCharacters = exports.allUpperWordStyle = exports.firstUpperWordStyle = exports.combineWords = exports.capitalize = exports.splitIntoWords = exports.inflateBase64 = exports.checkArray = exports.checkStringMap = exports.parseJSON = exports.assertNever = exports.defined = exports.assert = exports.panic = exports.IssueAnnotationData = exports.Namer = exports.funPrefixNamer = exports.Name = exports.parenIfNeeded = exports.singleWord = exports.modifySource = exports.languageNamed = exports.defaultTargetLanguages = exports.TargetLanguage = exports.getOptionValues = exports.Option = exports.Ref = exports.JSONSchemaInput = exports.jsonInputForTargetLanguage = exports.JSONInput = exports.InputData = exports.CompressedJSON = exports.inferenceFlagsObject = exports.defaultInferenceFlags = exports.inferenceFlagNames = exports.inferenceFlags = exports.combineRenderResults = exports.quicktype = exports.quicktypeMultiFileSync = exports.quicktypeMultiFile = exports.getTargetLanguage = void 0;
    exports.JavaScriptPropTypesRenderer = exports.JavaScriptPropTypesTargetLanguage = exports.javaScriptOptions = exports.JavaScriptRenderer = exports.JavaScriptTargetLanguage = exports.javaOptions = exports.JavaRenderer = exports.JavaTargetLanguage = exports.objcOptions = exports.ObjectiveCRenderer = exports.ObjectiveCTargetLanguage = exports.goOptions = exports.GoRenderer = exports.GoTargetLanguage = exports.pythonOptions = exports.PythonRenderer = exports.PythonTargetLanguage = exports.CSharpRenderer = exports.cSharpOptions = exports.CSharpTargetLanguage = exports.cPlusPlusOptions = exports.CPlusPlusRenderer = exports.CPlusPlusTargetLanguage = exports.cJSONOptions = exports.CJSONRenderer = exports.CJSONTargetLanguage = exports.uriTypeAttributeKind = exports.ConvenienceRenderer = exports.nullableFromUnion = exports.matchType = exports.removeNullFromUnion = exports.StringTypes = exports.namesTypeAttributeKind = exports.makeNamesTypeAttributes = exports.TypeNames = exports.emptyTypeAttributes = exports.TypeAttributeKind = exports.derefTypeRef = exports.TypeBuilder = exports.sourcesFromPostmanCollection = exports.JSONSchemaStore = exports.FetchingJSONSchemaStore = exports.readFromFileOrURL = exports.readableFromFileOrURL = exports.getStream = exports.ObjectType = exports.UnionType = exports.MapType = exports.EnumType = exports.ClassProperty = void 0;
    exports.elixirOptions = exports.ElixirRenderer = exports.ElixirTargetLanguage = exports.dartOptions = exports.DartRenderer = exports.DartTargetLanguage = exports.haskellOptions = exports.HaskellRenderer = exports.HaskellTargetLanguage = exports.CrystalRenderer = exports.CrystalTargetLanguage = exports.rubyOptions = exports.RubyRenderer = exports.RubyTargetLanguage = exports.rustOptions = exports.RustRenderer = exports.RustTargetLanguage = exports.JSONSchemaRenderer = exports.JSONSchemaTargetLanguage = exports.elmOptions = exports.ElmRenderer = exports.ElmTargetLanguage = exports.SmithyOptions = exports.Smithy4sRenderer = exports.SmithyTargetLanguage = exports.scala3Options = exports.Scala3Renderer = exports.Scala3TargetLanguage = exports.kotlinOptions = exports.KotlinRenderer = exports.KotlinTargetLanguage = exports.swiftOptions = exports.SwiftRenderer = exports.SwiftTargetLanguage = exports.tsFlowOptions = exports.FlowRenderer = exports.FlowTargetLanguage = exports.TypeScriptRenderer = exports.TypeScriptTargetLanguage = exports.javaScriptPropTypesOptions = void 0;
    var Run_1 = require_Run();
    Object.defineProperty(exports, "getTargetLanguage", { enumerable: true, get: function() {
      return Run_1.getTargetLanguage;
    } });
    Object.defineProperty(exports, "quicktypeMultiFile", { enumerable: true, get: function() {
      return Run_1.quicktypeMultiFile;
    } });
    Object.defineProperty(exports, "quicktypeMultiFileSync", { enumerable: true, get: function() {
      return Run_1.quicktypeMultiFileSync;
    } });
    Object.defineProperty(exports, "quicktype", { enumerable: true, get: function() {
      return Run_1.quicktype;
    } });
    Object.defineProperty(exports, "combineRenderResults", { enumerable: true, get: function() {
      return Run_1.combineRenderResults;
    } });
    Object.defineProperty(exports, "inferenceFlags", { enumerable: true, get: function() {
      return Run_1.inferenceFlags;
    } });
    Object.defineProperty(exports, "inferenceFlagNames", { enumerable: true, get: function() {
      return Run_1.inferenceFlagNames;
    } });
    Object.defineProperty(exports, "defaultInferenceFlags", { enumerable: true, get: function() {
      return Run_1.defaultInferenceFlags;
    } });
    Object.defineProperty(exports, "inferenceFlagsObject", { enumerable: true, get: function() {
      return Run_1.inferenceFlagsObject;
    } });
    var CompressedJSON_1 = require_CompressedJSON();
    Object.defineProperty(exports, "CompressedJSON", { enumerable: true, get: function() {
      return CompressedJSON_1.CompressedJSON;
    } });
    var Inputs_1 = require_Inputs();
    Object.defineProperty(exports, "InputData", { enumerable: true, get: function() {
      return Inputs_1.InputData;
    } });
    Object.defineProperty(exports, "JSONInput", { enumerable: true, get: function() {
      return Inputs_1.JSONInput;
    } });
    Object.defineProperty(exports, "jsonInputForTargetLanguage", { enumerable: true, get: function() {
      return Inputs_1.jsonInputForTargetLanguage;
    } });
    var JSONSchemaInput_1 = require_JSONSchemaInput();
    Object.defineProperty(exports, "JSONSchemaInput", { enumerable: true, get: function() {
      return JSONSchemaInput_1.JSONSchemaInput;
    } });
    var JSONSchemaInput_2 = require_JSONSchemaInput();
    Object.defineProperty(exports, "Ref", { enumerable: true, get: function() {
      return JSONSchemaInput_2.Ref;
    } });
    var RendererOptions_1 = require_RendererOptions();
    Object.defineProperty(exports, "Option", { enumerable: true, get: function() {
      return RendererOptions_1.Option;
    } });
    Object.defineProperty(exports, "getOptionValues", { enumerable: true, get: function() {
      return RendererOptions_1.getOptionValues;
    } });
    var TargetLanguage_1 = require_TargetLanguage();
    Object.defineProperty(exports, "TargetLanguage", { enumerable: true, get: function() {
      return TargetLanguage_1.TargetLanguage;
    } });
    var All_1 = require_All();
    Object.defineProperty(exports, "defaultTargetLanguages", { enumerable: true, get: function() {
      return All_1.all;
    } });
    Object.defineProperty(exports, "languageNamed", { enumerable: true, get: function() {
      return All_1.languageNamed;
    } });
    var Source_1 = require_Source();
    Object.defineProperty(exports, "modifySource", { enumerable: true, get: function() {
      return Source_1.modifySource;
    } });
    Object.defineProperty(exports, "singleWord", { enumerable: true, get: function() {
      return Source_1.singleWord;
    } });
    Object.defineProperty(exports, "parenIfNeeded", { enumerable: true, get: function() {
      return Source_1.parenIfNeeded;
    } });
    var Naming_1 = require_Naming();
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return Naming_1.Name;
    } });
    Object.defineProperty(exports, "funPrefixNamer", { enumerable: true, get: function() {
      return Naming_1.funPrefixNamer;
    } });
    Object.defineProperty(exports, "Namer", { enumerable: true, get: function() {
      return Naming_1.Namer;
    } });
    var Annotation_1 = require_Annotation();
    Object.defineProperty(exports, "IssueAnnotationData", { enumerable: true, get: function() {
      return Annotation_1.IssueAnnotationData;
    } });
    var Support_1 = require_Support();
    Object.defineProperty(exports, "panic", { enumerable: true, get: function() {
      return Support_1.panic;
    } });
    Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
      return Support_1.assert;
    } });
    Object.defineProperty(exports, "defined", { enumerable: true, get: function() {
      return Support_1.defined;
    } });
    Object.defineProperty(exports, "assertNever", { enumerable: true, get: function() {
      return Support_1.assertNever;
    } });
    Object.defineProperty(exports, "parseJSON", { enumerable: true, get: function() {
      return Support_1.parseJSON;
    } });
    Object.defineProperty(exports, "checkStringMap", { enumerable: true, get: function() {
      return Support_1.checkStringMap;
    } });
    Object.defineProperty(exports, "checkArray", { enumerable: true, get: function() {
      return Support_1.checkArray;
    } });
    Object.defineProperty(exports, "inflateBase64", { enumerable: true, get: function() {
      return Support_1.inflateBase64;
    } });
    var Strings_1 = require_Strings();
    Object.defineProperty(exports, "splitIntoWords", { enumerable: true, get: function() {
      return Strings_1.splitIntoWords;
    } });
    Object.defineProperty(exports, "capitalize", { enumerable: true, get: function() {
      return Strings_1.capitalize;
    } });
    Object.defineProperty(exports, "combineWords", { enumerable: true, get: function() {
      return Strings_1.combineWords;
    } });
    Object.defineProperty(exports, "firstUpperWordStyle", { enumerable: true, get: function() {
      return Strings_1.firstUpperWordStyle;
    } });
    Object.defineProperty(exports, "allUpperWordStyle", { enumerable: true, get: function() {
      return Strings_1.allUpperWordStyle;
    } });
    Object.defineProperty(exports, "legalizeCharacters", { enumerable: true, get: function() {
      return Strings_1.legalizeCharacters;
    } });
    Object.defineProperty(exports, "isLetterOrDigit", { enumerable: true, get: function() {
      return Strings_1.isLetterOrDigit;
    } });
    var MarkovChain_1 = require_MarkovChain();
    Object.defineProperty(exports, "trainMarkovChain", { enumerable: true, get: function() {
      return MarkovChain_1.train;
    } });
    var Messages_1 = require_Messages();
    Object.defineProperty(exports, "QuickTypeError", { enumerable: true, get: function() {
      return Messages_1.QuickTypeError;
    } });
    Object.defineProperty(exports, "messageError", { enumerable: true, get: function() {
      return Messages_1.messageError;
    } });
    Object.defineProperty(exports, "messageAssert", { enumerable: true, get: function() {
      return Messages_1.messageAssert;
    } });
    var Type_1 = require_Type();
    Object.defineProperty(exports, "Type", { enumerable: true, get: function() {
      return Type_1.Type;
    } });
    Object.defineProperty(exports, "PrimitiveType", { enumerable: true, get: function() {
      return Type_1.PrimitiveType;
    } });
    Object.defineProperty(exports, "ArrayType", { enumerable: true, get: function() {
      return Type_1.ArrayType;
    } });
    Object.defineProperty(exports, "ClassType", { enumerable: true, get: function() {
      return Type_1.ClassType;
    } });
    Object.defineProperty(exports, "ClassProperty", { enumerable: true, get: function() {
      return Type_1.ClassProperty;
    } });
    Object.defineProperty(exports, "EnumType", { enumerable: true, get: function() {
      return Type_1.EnumType;
    } });
    Object.defineProperty(exports, "MapType", { enumerable: true, get: function() {
      return Type_1.MapType;
    } });
    Object.defineProperty(exports, "UnionType", { enumerable: true, get: function() {
      return Type_1.UnionType;
    } });
    Object.defineProperty(exports, "ObjectType", { enumerable: true, get: function() {
      return Type_1.ObjectType;
    } });
    var get_stream_1 = require_get_stream();
    Object.defineProperty(exports, "getStream", { enumerable: true, get: function() {
      return get_stream_1.getStream;
    } });
    var NodeIO_1 = require_NodeIO();
    Object.defineProperty(exports, "readableFromFileOrURL", { enumerable: true, get: function() {
      return NodeIO_1.readableFromFileOrURL;
    } });
    Object.defineProperty(exports, "readFromFileOrURL", { enumerable: true, get: function() {
      return NodeIO_1.readFromFileOrURL;
    } });
    var FetchingJSONSchemaStore_1 = require_FetchingJSONSchemaStore();
    Object.defineProperty(exports, "FetchingJSONSchemaStore", { enumerable: true, get: function() {
      return FetchingJSONSchemaStore_1.FetchingJSONSchemaStore;
    } });
    var JSONSchemaStore_1 = require_JSONSchemaStore();
    Object.defineProperty(exports, "JSONSchemaStore", { enumerable: true, get: function() {
      return JSONSchemaStore_1.JSONSchemaStore;
    } });
    var PostmanCollection_1 = require_PostmanCollection();
    Object.defineProperty(exports, "sourcesFromPostmanCollection", { enumerable: true, get: function() {
      return PostmanCollection_1.sourcesFromPostmanCollection;
    } });
    var TypeBuilder_1 = require_TypeBuilder();
    Object.defineProperty(exports, "TypeBuilder", { enumerable: true, get: function() {
      return TypeBuilder_1.TypeBuilder;
    } });
    var TypeGraph_1 = require_TypeGraph();
    Object.defineProperty(exports, "derefTypeRef", { enumerable: true, get: function() {
      return TypeGraph_1.derefTypeRef;
    } });
    var TypeAttributes_1 = require_TypeAttributes();
    Object.defineProperty(exports, "TypeAttributeKind", { enumerable: true, get: function() {
      return TypeAttributes_1.TypeAttributeKind;
    } });
    Object.defineProperty(exports, "emptyTypeAttributes", { enumerable: true, get: function() {
      return TypeAttributes_1.emptyTypeAttributes;
    } });
    var TypeNames_1 = require_TypeNames();
    Object.defineProperty(exports, "TypeNames", { enumerable: true, get: function() {
      return TypeNames_1.TypeNames;
    } });
    Object.defineProperty(exports, "makeNamesTypeAttributes", { enumerable: true, get: function() {
      return TypeNames_1.makeNamesTypeAttributes;
    } });
    Object.defineProperty(exports, "namesTypeAttributeKind", { enumerable: true, get: function() {
      return TypeNames_1.namesTypeAttributeKind;
    } });
    var StringTypes_1 = require_StringTypes();
    Object.defineProperty(exports, "StringTypes", { enumerable: true, get: function() {
      return StringTypes_1.StringTypes;
    } });
    var TypeUtils_1 = require_TypeUtils();
    Object.defineProperty(exports, "removeNullFromUnion", { enumerable: true, get: function() {
      return TypeUtils_1.removeNullFromUnion;
    } });
    Object.defineProperty(exports, "matchType", { enumerable: true, get: function() {
      return TypeUtils_1.matchType;
    } });
    Object.defineProperty(exports, "nullableFromUnion", { enumerable: true, get: function() {
      return TypeUtils_1.nullableFromUnion;
    } });
    var ConvenienceRenderer_1 = require_ConvenienceRenderer();
    Object.defineProperty(exports, "ConvenienceRenderer", { enumerable: true, get: function() {
      return ConvenienceRenderer_1.ConvenienceRenderer;
    } });
    var URIAttributes_1 = require_URIAttributes();
    Object.defineProperty(exports, "uriTypeAttributeKind", { enumerable: true, get: function() {
      return URIAttributes_1.uriTypeAttributeKind;
    } });
    var CJSON_1 = require_CJSON();
    Object.defineProperty(exports, "CJSONTargetLanguage", { enumerable: true, get: function() {
      return CJSON_1.CJSONTargetLanguage;
    } });
    Object.defineProperty(exports, "CJSONRenderer", { enumerable: true, get: function() {
      return CJSON_1.CJSONRenderer;
    } });
    Object.defineProperty(exports, "cJSONOptions", { enumerable: true, get: function() {
      return CJSON_1.cJSONOptions;
    } });
    var CPlusPlus_1 = require_CPlusPlus();
    Object.defineProperty(exports, "CPlusPlusTargetLanguage", { enumerable: true, get: function() {
      return CPlusPlus_1.CPlusPlusTargetLanguage;
    } });
    Object.defineProperty(exports, "CPlusPlusRenderer", { enumerable: true, get: function() {
      return CPlusPlus_1.CPlusPlusRenderer;
    } });
    Object.defineProperty(exports, "cPlusPlusOptions", { enumerable: true, get: function() {
      return CPlusPlus_1.cPlusPlusOptions;
    } });
    var CSharp_1 = require_CSharp();
    Object.defineProperty(exports, "CSharpTargetLanguage", { enumerable: true, get: function() {
      return CSharp_1.CSharpTargetLanguage;
    } });
    Object.defineProperty(exports, "cSharpOptions", { enumerable: true, get: function() {
      return CSharp_1.cSharpOptions;
    } });
    Object.defineProperty(exports, "CSharpRenderer", { enumerable: true, get: function() {
      return CSharp_1.CSharpRenderer;
    } });
    var Python_1 = require_Python();
    Object.defineProperty(exports, "PythonTargetLanguage", { enumerable: true, get: function() {
      return Python_1.PythonTargetLanguage;
    } });
    Object.defineProperty(exports, "PythonRenderer", { enumerable: true, get: function() {
      return Python_1.PythonRenderer;
    } });
    Object.defineProperty(exports, "pythonOptions", { enumerable: true, get: function() {
      return Python_1.pythonOptions;
    } });
    var Golang_1 = require_Golang();
    Object.defineProperty(exports, "GoTargetLanguage", { enumerable: true, get: function() {
      return Golang_1.GoTargetLanguage;
    } });
    Object.defineProperty(exports, "GoRenderer", { enumerable: true, get: function() {
      return Golang_1.GoRenderer;
    } });
    Object.defineProperty(exports, "goOptions", { enumerable: true, get: function() {
      return Golang_1.goOptions;
    } });
    var Objective_C_1 = require_Objective_C();
    Object.defineProperty(exports, "ObjectiveCTargetLanguage", { enumerable: true, get: function() {
      return Objective_C_1.ObjectiveCTargetLanguage;
    } });
    Object.defineProperty(exports, "ObjectiveCRenderer", { enumerable: true, get: function() {
      return Objective_C_1.ObjectiveCRenderer;
    } });
    Object.defineProperty(exports, "objcOptions", { enumerable: true, get: function() {
      return Objective_C_1.objcOptions;
    } });
    var Java_1 = require_Java();
    Object.defineProperty(exports, "JavaTargetLanguage", { enumerable: true, get: function() {
      return Java_1.JavaTargetLanguage;
    } });
    Object.defineProperty(exports, "JavaRenderer", { enumerable: true, get: function() {
      return Java_1.JavaRenderer;
    } });
    Object.defineProperty(exports, "javaOptions", { enumerable: true, get: function() {
      return Java_1.javaOptions;
    } });
    var JavaScript_1 = require_JavaScript();
    Object.defineProperty(exports, "JavaScriptTargetLanguage", { enumerable: true, get: function() {
      return JavaScript_1.JavaScriptTargetLanguage;
    } });
    Object.defineProperty(exports, "JavaScriptRenderer", { enumerable: true, get: function() {
      return JavaScript_1.JavaScriptRenderer;
    } });
    Object.defineProperty(exports, "javaScriptOptions", { enumerable: true, get: function() {
      return JavaScript_1.javaScriptOptions;
    } });
    var JavaScriptPropTypes_1 = require_JavaScriptPropTypes();
    Object.defineProperty(exports, "JavaScriptPropTypesTargetLanguage", { enumerable: true, get: function() {
      return JavaScriptPropTypes_1.JavaScriptPropTypesTargetLanguage;
    } });
    Object.defineProperty(exports, "JavaScriptPropTypesRenderer", { enumerable: true, get: function() {
      return JavaScriptPropTypes_1.JavaScriptPropTypesRenderer;
    } });
    Object.defineProperty(exports, "javaScriptPropTypesOptions", { enumerable: true, get: function() {
      return JavaScriptPropTypes_1.javaScriptPropTypesOptions;
    } });
    var TypeScriptFlow_1 = require_TypeScriptFlow();
    Object.defineProperty(exports, "TypeScriptTargetLanguage", { enumerable: true, get: function() {
      return TypeScriptFlow_1.TypeScriptTargetLanguage;
    } });
    Object.defineProperty(exports, "TypeScriptRenderer", { enumerable: true, get: function() {
      return TypeScriptFlow_1.TypeScriptRenderer;
    } });
    Object.defineProperty(exports, "FlowTargetLanguage", { enumerable: true, get: function() {
      return TypeScriptFlow_1.FlowTargetLanguage;
    } });
    Object.defineProperty(exports, "FlowRenderer", { enumerable: true, get: function() {
      return TypeScriptFlow_1.FlowRenderer;
    } });
    Object.defineProperty(exports, "tsFlowOptions", { enumerable: true, get: function() {
      return TypeScriptFlow_1.tsFlowOptions;
    } });
    var Swift_1 = require_Swift();
    Object.defineProperty(exports, "SwiftTargetLanguage", { enumerable: true, get: function() {
      return Swift_1.SwiftTargetLanguage;
    } });
    Object.defineProperty(exports, "SwiftRenderer", { enumerable: true, get: function() {
      return Swift_1.SwiftRenderer;
    } });
    Object.defineProperty(exports, "swiftOptions", { enumerable: true, get: function() {
      return Swift_1.swiftOptions;
    } });
    var Kotlin_1 = require_Kotlin();
    Object.defineProperty(exports, "KotlinTargetLanguage", { enumerable: true, get: function() {
      return Kotlin_1.KotlinTargetLanguage;
    } });
    Object.defineProperty(exports, "KotlinRenderer", { enumerable: true, get: function() {
      return Kotlin_1.KotlinRenderer;
    } });
    Object.defineProperty(exports, "kotlinOptions", { enumerable: true, get: function() {
      return Kotlin_1.kotlinOptions;
    } });
    var Scala3_1 = require_Scala3();
    Object.defineProperty(exports, "Scala3TargetLanguage", { enumerable: true, get: function() {
      return Scala3_1.Scala3TargetLanguage;
    } });
    Object.defineProperty(exports, "Scala3Renderer", { enumerable: true, get: function() {
      return Scala3_1.Scala3Renderer;
    } });
    Object.defineProperty(exports, "scala3Options", { enumerable: true, get: function() {
      return Scala3_1.scala3Options;
    } });
    var Smithy4s_1 = require_Smithy4s();
    Object.defineProperty(exports, "SmithyTargetLanguage", { enumerable: true, get: function() {
      return Smithy4s_1.SmithyTargetLanguage;
    } });
    Object.defineProperty(exports, "Smithy4sRenderer", { enumerable: true, get: function() {
      return Smithy4s_1.Smithy4sRenderer;
    } });
    Object.defineProperty(exports, "SmithyOptions", { enumerable: true, get: function() {
      return Smithy4s_1.SmithyOptions;
    } });
    var Elm_1 = require_Elm();
    Object.defineProperty(exports, "ElmTargetLanguage", { enumerable: true, get: function() {
      return Elm_1.ElmTargetLanguage;
    } });
    Object.defineProperty(exports, "ElmRenderer", { enumerable: true, get: function() {
      return Elm_1.ElmRenderer;
    } });
    Object.defineProperty(exports, "elmOptions", { enumerable: true, get: function() {
      return Elm_1.elmOptions;
    } });
    var JSONSchema_1 = require_JSONSchema();
    Object.defineProperty(exports, "JSONSchemaTargetLanguage", { enumerable: true, get: function() {
      return JSONSchema_1.JSONSchemaTargetLanguage;
    } });
    Object.defineProperty(exports, "JSONSchemaRenderer", { enumerable: true, get: function() {
      return JSONSchema_1.JSONSchemaRenderer;
    } });
    var Rust_1 = require_Rust();
    Object.defineProperty(exports, "RustTargetLanguage", { enumerable: true, get: function() {
      return Rust_1.RustTargetLanguage;
    } });
    Object.defineProperty(exports, "RustRenderer", { enumerable: true, get: function() {
      return Rust_1.RustRenderer;
    } });
    Object.defineProperty(exports, "rustOptions", { enumerable: true, get: function() {
      return Rust_1.rustOptions;
    } });
    var ruby_1 = require_ruby();
    Object.defineProperty(exports, "RubyTargetLanguage", { enumerable: true, get: function() {
      return ruby_1.RubyTargetLanguage;
    } });
    Object.defineProperty(exports, "RubyRenderer", { enumerable: true, get: function() {
      return ruby_1.RubyRenderer;
    } });
    Object.defineProperty(exports, "rubyOptions", { enumerable: true, get: function() {
      return ruby_1.rubyOptions;
    } });
    var Crystal_1 = require_Crystal();
    Object.defineProperty(exports, "CrystalTargetLanguage", { enumerable: true, get: function() {
      return Crystal_1.CrystalTargetLanguage;
    } });
    Object.defineProperty(exports, "CrystalRenderer", { enumerable: true, get: function() {
      return Crystal_1.CrystalRenderer;
    } });
    var Haskell_1 = require_Haskell();
    Object.defineProperty(exports, "HaskellTargetLanguage", { enumerable: true, get: function() {
      return Haskell_1.HaskellTargetLanguage;
    } });
    Object.defineProperty(exports, "HaskellRenderer", { enumerable: true, get: function() {
      return Haskell_1.HaskellRenderer;
    } });
    Object.defineProperty(exports, "haskellOptions", { enumerable: true, get: function() {
      return Haskell_1.haskellOptions;
    } });
    var Dart_1 = require_Dart();
    Object.defineProperty(exports, "DartTargetLanguage", { enumerable: true, get: function() {
      return Dart_1.DartTargetLanguage;
    } });
    Object.defineProperty(exports, "DartRenderer", { enumerable: true, get: function() {
      return Dart_1.DartRenderer;
    } });
    Object.defineProperty(exports, "dartOptions", { enumerable: true, get: function() {
      return Dart_1.dartOptions;
    } });
    var Elixir_1 = require_Elixir();
    Object.defineProperty(exports, "ElixirTargetLanguage", { enumerable: true, get: function() {
      return Elixir_1.ElixirTargetLanguage;
    } });
    Object.defineProperty(exports, "ElixirRenderer", { enumerable: true, get: function() {
      return Elixir_1.ElixirRenderer;
    } });
    Object.defineProperty(exports, "elixirOptions", { enumerable: true, get: function() {
      return Elixir_1.elixirOptions;
    } });
  }
});
export default require_dist4();
/*! Bundled license information:

urijs/src/punycode.js:
  (*! https://mths.be/punycode v1.4.0 by @mathias *)

urijs/src/IPv6.js:
  (*!
   * URI.js - Mutating URLs
   * IPv6 Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/SecondLevelDomains.js:
  (*!
   * URI.js - Mutating URLs
   * Second Level Domain (SLD) Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/URI.js:
  (*!
   * URI.js - Mutating URLs
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=quicktype-core.js.map
